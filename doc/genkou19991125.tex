\documentclass{jarticle}

\title{\bf Open XM(タイトル未定)}
\author{
        Maekawa \\
        Noro \\
        : \\
        : \\
}
\date{ 1999年, 11月25日}

%\pagestyle{empty}

\begin{document}
\maketitle

\section{OpenXM の計算モデル}

OpenXM は数学ソフト間でメッセージを交換するための規約である。
OpenXM とは Open message eXchange protocol for Mathematics の略である。
数学ソフト間でメッセージをやりとりさせることにより、
ある数学ソフトから他の数学ソフトを呼び出して計算を行なったり、
他のマシンで計算を行なわせたりできるようにする。
発端は野呂正行と高山信毅により、 asir と kan/sm1 を
相互に呼び出す機能を実装したことである。
現在の目標は、フリーの数学ソフトを相互に接続して
好きな言語から簡単に他の数学ソフトを使えるようにすることである。

発端となった asir と kan/sm1 での実装時には、
お互いに相手側のコマンド文字列を送っていた。
この方法は現在の OpenXM 規約でも可能であり、
使いやすくはあるが、効率的であるとはいい難い。
さらに、この方法では相手側のソフトが asir なのか kan/sm1 なのかを
判別して、相手側に合わせてコマンド文字列を作成する必要がある。

これ以外の方法として、 OpenXM 規約では共通表現形式による
メッセージを用意している。
OpenXM 規約独自のデータ形式である CMO 形式(Common Mathematical Object format)
以外にも、 MP や OpenMath の XML, binary 表現形式といった他の形式をも
扱えるようにしてある。


\section{OpenXM のメッセージの構造}

OpenXM で規定しているメッセージは論理的に
OX 層、 SM 層、 CMO 層に分けることができる。
この中で、メッセージとして送ることが可能なのは
OX 層で定義されたものだけであり、
SM 層、 CMO 層で定義されているデータは
OX 層で定義されているデータの一部に埋め込まれて
送られる。
SM 層、 CMO 層で定義されているデータ以外にも
前述の MP や OpenMath の XML, binary 表現も
OX 層に埋め込まれて送られるわけであるが、
どのようなデータが埋め込まれているかは、
OX 層の先頭にある tag を見れば判別できるようになっている。


\section{OpenXM の計算の進行方法}

OpenXM 規約でのメッセージの交換はサーバとクライアントの間で
行なわれる。クライアントからサーバへ計算させたいデータを
メッセージとして送り、次いでサーバに行なわせたい動作に
対応したデータを送ることによって、計算などの、なんらかの動作を
サーバに行なわせる。サーバは結果の送信も命令されなければ
行なうことはなく、クライアントは結果を受け取らずにサーバに次々と
計算を行なわせることも可能である。なお、サーバに対する動作に対応した
データは SM 層で定義されており、 SM 層以外のデータではサーバは
データを受け取る以外の動作をしないことになっている。

サーバはスタックを持っていると仮定されており、受け取った
メッセージはすべてスタックに積まれる。ここで、 SM 層で定義された
データを受け取った場合には、それに対応する動作を行なう。
このとき、必要があればサーバはスタックからデータを取り出す。
クライアントからの命令による動作中にエラーが発生したとしても、
サーバはエラーオブジェクトをスタックに積むだけで、
明示されない限りエラーを返さないことに注意しなければならない。

結果が生じる動作をサーバが行なった場合、
サーバは動作の結果をスタックに積んでいる。
サーバに行なわせた動作の結果をクライアントが知りたい場合、
スタックからデータを取り出し送信を行なう命令に対応した SM 層のデータを
サーバ側へ送ればよい。

クライアントがサーバへ計算を行なわせ、結果を得るという手順を追っていくと、
次のようになる。

\begin{enumerate}
\item	まず、クライアントがサーバへ計算させたいデータを送る。
	サーバは送られてきたデータをスタックに積む。
\item	クライアントがサーバに計算を行なう動作に対応したデータを
	送ると、サーバは必要なだけスタックからデータを取り出し、
	実行した計算の結果をスタックに積む。
\item	最後に「データを取り出し送信を行なう命令に対応したデータ」を
	サーバへ送ると、サーバはスタックから計算結果の入っている
	データを取り出し、クライアントへ送出する。
\end{enumerate}


\section{CMO のデータ構造}

OpenXM 間でやりとりされるメッセージを実際に作成する場合、
CMO 層で定義されている多倍長整数を理解しておくと、
CMO 層の他のデータ構造だけでなく、 OX 層、 SM 層のデータを
理解する助けになると思えるので、 CMO 層の多倍長整数の
データ構造について説明する。

CMO 層で定義されているデータは多倍長整数以外にも
文字列やリストなどがある。どのようなデータであるかは
データの先頭にある tag を見れば判別できるようになっている。
これは OX 層でのデータの判別の仕方とおなじである。
なお、 tag は各データ毎に 32 bit の整数で表されており、
多倍長整数は 20 となっている。
ここで 32 bit の整数の表現方法について説明する必要がある。
%昨今のコンピュータ事情から、
%32 bit 整数も 8 bit 単位で扱うほうが都合がよい。
OpenXM では 8 bit 単位で $( \mbox{\tt 00 00 00 14})_{2^8}$ と表す方法と
$( \mbox{\tt 14 00 00 00})_{2^8}$ と表す方法がある。
この表現方法の違いはクライアントとサーバの最初の接続時に
双方の合意で決定することになっている。なお、合意がない場合には
前者の表現方法(以後、この表現方法を network byte order と呼ぶ)を
使うことになっている。
また、負の数を表現する必要があるときには、
2 の補数表現を使うことになっている。

表現したい多倍長整数の絶対値を 2 進数で表した場合の桁数を $n$ と
したとき、次にくるデータは $[(n+31)/32]$ を 32 bit の整数となる。
これは多倍長整数の絶対値を $2^{32}$ 進数で表した場合の桁数ととってもよい。
ただし、表現したい数が負の場合はこの 32 bit の整数値は 2 の補数表現で負になる。

%表現したい多倍長整数が負であってもこれ以降の説明は正の場合と
%変わらないので、以後多倍長整数は正とみなす。

表現したい多倍長整数の絶対値が $2^{32}$ 進数で $(b_0 b_1 ...)_{2^{32}}$
と表せるとき、次にくるデータは $b_0$, $b_1$, $\cdots$ を
32 bit の整数で表現した値となる。

ここで具体例をだそう。
$4294967298 = 1 \times 2^{32} + 2$ を network byte order の多倍長整数で
表現すると、
\begin{center}
	{\tt 00 00 00 14 00 00 00 02 00 00 00 02 00 00 00 01}
\end{center}
となる。また、同じ表現方法で $-1$ を表現すると、
\begin{center}
	{\tt 00 00 00 14 ff ff ff ff 00 00 00 01}
\end{center}
となる。


\section{MathCap について}

%前節で見たように、 1 つのメッセージの長さは決まっていない。
サーバおよびクライアント双方ともに OpenXM で規定されている
すべてのメッセージを理解できるわけではない。
そこで、 OpenXM では相手の理解可能なメッセージを
収得する方法を用意している。
CMO 層で定義されている MathCap データは
理解可能なメッセージを表すデータであり、
要求されればサーバは MathCap をスタックに積む。
また、クライアントから MathCap をサーバへ送ることもでき、
MathCap をサーバとクライアントで交換することによって、
お互いに相手の理解不可能なメッセージを送ってしまうことを
防ぐことができる。
なお、 MathCap のデータの中では CMO 層で定義されている
32 bit 整数、文字列、リスト構造を使っており、
MathCap を理解できるためには必然的にこれらも理解できる
必要がある。

OpenXM 対応版の asir である ox\_asir が返す MathCap を
以下に示す。なお、 $a_0$, $a_1$, $\cdots$, $a_n$ を要素に
持つリスト構造を {\tt [$a_0$, $a_1$, $\cdots$, $a_n$]} 、
文字列 ``string'' を {\tt "string"} 、 32 bit 整数を
それに対応する 10 進数の整数で示す。

%↓手で作ったので間違えている可能性あり。
%%古いバージョン。差し替えの必要あり。
\begin{verbatim}
[ [199901160,"ox_asir"],
  [276,275,258,262,263,266,267,268,274
    ,269,272,265,264,273,300,270,271],
  [ [514,[1,2,3,4,5,2130706433,2130706434
          ,17,19,20,21,22,24,25,26,31,27,33,60]],
    [2144202544,[0,1]]
  ]
]
\end{verbatim}

この MathCap データのリスト構造の最初の要素はサーバの情報が入っている。
この最初の要素がまたリスト構造となっており、
最初の要素はバージョンナンバーを、次の要素はサーバの名前を表している。

次の要素は SM 層で定義されている理解可能なデータを表している。
サーバの動作に対するデータは SM 層ではすべて 32 bit の整数で
表されており、この 2 番めの要素は理解可能な SM 層のデータに
対する 32 bit 整数のリストとなっている。

最後の要素は理解可能なデータを表している。
%このリストの要素はまたリストとなっており、
この最後の部分もまたリストとなっており、
あるデータ形式で理解可能なものを表現したリストを要素としている。
{\tt [514,[1, 2, $\cdots$]]} の最初の 514 はこのリストが CMO 形式
での理解可能なデータを表していることを示しており、
その後のリストでは CMO 層で定義されているデータのうち、
理解可能なデータの tag が並んでいる。
前節で CMO 形式では多倍長整数を表す tag が 20 であることを述べたが、
このリストに 20 が含まれているので、 ox\_asir は CMO 形式の
多倍長整数が理解できることがわかる。

最初のリストがサーバの情報を表しているといったことが理解できることと、
データが受け取れることとはまったく別物であるので
注意する必要がある。


\section{security 対策}

OpenXM では幾らかのセキュリティ対策を行なっている。

まず、接続が必要になった時に、クライアントがサーバ側からの
接続を待つようになっている。これは常に接続を待つことによって、
侵入者に接続の機会を与えてしまうことを減らすためである。

次に、クライアントが接続毎に接続を待つ port 番号をランダムに決定する
ことになっている。これにより、侵入者がどこに接続を行なえばよいのか
わかりにくくしている。

最後に、接続時にクライアントが 1 回のみ有効なパスワードを発行し、
認証を行なうようになっている。このパスワードは一旦使用されると
無効になるので、もし仮になんらかの手段でパスワードが洩れたとしても
安全である。なお、このパスワードは安全な手段で送られていないと
いけない。また、現在の実装ではサーバ、およびクライアントの動作している
コンピュータ上ではこのパスワードがわかってしまうため、
同一のコンピュータ上に悪意のあるユーザはいないと仮定している
ことに注意しなければならない。

なお、接続が確立した後のメッセージの送受信に関しては、
特に暗号化などの処置が行なわれているわけではない。
もし必要があれば、通信路の暗号化を行なう機能がある
ソフトウェアを使うことを考えている。


\section{他のプロジェクト}

他のプロジェクトについて幾つか紹介する。

OpenMath プロジェクトは数学的なオブジェクトを
コンピュータ上で表現する方法を決定している。
表現方法は

%NetSolve

%MP

%MCP

\section{現在提供されているソフトウェア}

現在 OpenXM 規格に対応しているクライアントソフトウェアには
asir, sm1, Mathematica がある。
これらのクライアントソフトウェアから
OpenXM 規格に対応したサーバを呼び出すことができる。
現在 OpenXM 規約に対応しているサーバソフトウェアには、
 asir, sm1, gnuplot, Mathematica などがあり、
それぞれ ox\_asir, ox\_sm1, ox\_math という名前で提供されている。
また、 OpenMath 規格の XML 表現で表現されたデータと CMO 形式の
データを変換するソフトウェアが JAVA によって実装されており、
OMproxy という名前で提供されている。

\end{document}
