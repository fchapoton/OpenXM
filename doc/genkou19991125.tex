\documentclass{jarticle}

\title{\bf Open XM(タイトル未定)}
\author{
%Maekawa, Masahide  (Oct., 1999 -- : CVS server) \\
前川 まさひで,
%↑漢字調べ中。 commit 見たら教えてね。どうせ明日聞けるけど。
%Noro, Masayuki     (Jan., 1996 -- : OpenXM Protocol, asir99) \\
野呂 正行,
%Ohara, Katsuyoshi  (Jan., 1998 -- : ox\_math) \\
小原 功任, \\
%Okutani, Yukio     (Oct., 1999 -- : asir contrib) \\
奥谷 幸夫,
%Takayama, Nobuki   (Jan., 1996 -- : OpenXM Protocol, kan) \\
高山 信毅,
%Tamura, Yasushi    (Nov., 1998 -- : OpenMath proxy) \\
田村 恭士
}
\date{1999年11月25日}

%\pagestyle{empty}

\begin{document}
\maketitle

\section{OpenXM の計算モデル}

OpenXM は数学ソフト間でメッセージを交換するための規約である。
数学的なデータを含んだメッセージなどを用いて
数学ソフト間でメッセージをやりとりさせることにより、
ある数学ソフトから他の数学ソフトを呼び出して計算を行なったり、
他のマシンで計算を行なわせたりすることが目的である。
発端は野呂正行と高山信毅により、 asir と kan/sm1 を
相互に呼び出す機能を実装したことである。
現在の目標は、フリーの数学ソフトを相互に接続して
好きな言語から簡単に他の数学ソフトを使えるようにすることである。
なお、 OpenXM とは Open message eXchange protocol for Mathematics の
略である。

発端となった asir と kan/sm1 での実装時には、
お互いに相手側のコマンド文字列を送っていた。
この方法は現在の OpenXM 規約でも形を変えて可能ではあるが、
使いやすい反面、効率的であるとはいい難い。
さらに、この方法では相手側のソフトが asir なのか kan/sm1 なのかを
判別して、相手側に合わせてコマンド文字列を作成する必要がある。

これ以外の方法として、
OpenXM 規約では共通表現形式によるメッセージも用意している。
OpenXM 規約独自のデータ形式である CMO 形式(Common Mathematical Object format)
以外にも、 MP や OpenMath の XML, binary 表現形式といった他の形式をも
扱えるようにしてある。
なお、現在の OpenXM 規約では、
前述のコマンド文字列も CMO 形式などの何らかのデータ形式の中の
文字列として表現して送る必要がある。

OpenXM 規約でのメッセージの交換はサーバとクライアントの間で行なわれる。
サーバはスタックマシンであると仮定されており、
サーバがクライアントから受け取ったメッセージはすべてスタックに積まれる。
OpenXM のメッセージの中にはサーバに行なわせたい動作に対応するデータがあり、
このメッセージを受け取ったサーバはそれに対応する動作を
行なうことが期待されている。
ただし、サーバは命令されない限り何も動作を行なおうとはしない。


\section{OpenXM のメッセージの構造}

OpenXM のメッセージは複数の種類のデータを表現することが可能である。
メッセージがどのようなデータなのかは、
先頭にある tag をみれば分かるようになっている。
この tag をみることによって、
CMO 形式や、 OpenMath の XML 表現などの、
メッセージに含まれているデータの種類が分かるようになっている。

メッセージの中の実際にデータの入っている部分は
 tag 以降にある body の部分である。
body の中のデータがどのように格納されているかは
各データ形式がそれぞれ独立に決められるようになっている。
もし、 OpenXM 規約でメッセージのやりとりを行ないたいが、
まだ規約で定義されていないデータ形式を使いたい場合は、
tag をまだ使われてなさそうな値
(システム固有の表現のために推奨されている値がある)
に設定し、 body の部分にデータを埋め込めばよい。
なお、すべてのメッセージに body が必要というわけではなく、
body のないメッセージも OpenXM 規約には存在することに
注意しなければならない。

サーバに対する動作に対応したデータは SM 形式として定義されている。
SM 形式以外のデータでは、サーバは受け取ったデータをスタックに積む
以外の動作をしないことになっている。
つまり、 SM 形式のデータがデータを受け取る以外の動作を
サーバに行なわせる唯一のデータ形式である。
このデータを受け取る以外の動作の中には、
データになんらかの加工を施す動作も入っている。
このデータになんらかの加工を施す動作の中には
数学的な演算を行なう動作も含まれている。
以後、データになんらかの加工を施す動作のことを計算と呼ぶことにする。


\section{OpenXM の計算の進行方法}

クライアントがサーバへなんらかの計算を行なわせる場合、
クライアントからサーバへ計算させたいデータをメッセージとして送り、
そしてその結果をサーバからメッセージで受け取ることによって計算は行なわれる。
ただし、サーバは結果の送信すらも命令されなければ行なうことはなく、
クライアントは結果を受け取らずにサーバに次々と
計算を行なわせることも可能である。

サーバがクライアントから受け取ったメッセージはすべてスタックに積まれる。
ただし、このままでは受け取ったメッセージに含まれるデータを
スタックに積み上げていくだけで、サーバは計算を行なおうとはしない。
次いでサーバに行なわせたい動作に対応したデータを送ると、
初めてサーバは計算などの、なんらかの動作を行なう。
このとき、必要があればサーバはスタックから必要なだけデータを取り出す。
ここで、クライアントからの命令による動作中にたとえエラーが発生したとしても
サーバはエラーオブジェクトをスタックに積むだけで、
明示されない限りエラーを返さないことに注意しなければならない。

結果が生じる動作をサーバが行なった場合、
サーバは動作の結果をスタックに積んでいる。
サーバに行なわせた動作の結果をクライアントが知りたい場合、
スタックからデータを取り出し送信を行なう命令に対応した SM 形式のデータを
サーバ側へ送ればよい。

クライアントがサーバへ計算を行なわせ、結果を得るという手順を追っていくと、
次のようになる。

\begin{enumerate}
\item	まず、クライアントがサーバへ計算させたいデータを送る。
	サーバは送られてきたデータをスタックに積む。
\item	クライアントがサーバに「計算を行なう動作に対応したデータ」を
	送ると、サーバは必要なだけスタックからデータを取り出し、
	実行した計算の結果をスタックに積む。
\item	最後に「データを取り出し送信を行なう命令に対応したデータ」を
	サーバへ送ると、サーバはスタックから計算結果の入っている
	データを取り出し、クライアントへ送出する。
\end{enumerate}


\section{CMO のデータ構造}

OpenXM 間でやりとりされるメッセージを実際に作成する場合、
CMO 形式で定義されている多倍長整数を理解しておくと、
CMO 形式の他のデータ構造だけでなく、 OX 形式、 SM 形式のデータを
理解する助けになると思えるので、 CMO 形式の多倍長整数の
データ構造について説明する。

CMO 形式で定義されているデータは多倍長整数以外にも
文字列やリスト構造などがある。どのようなデータであるかは
データの先頭にある tag を見れば判別できるようになっている。
これはメッセージのデータの判別の仕方とおなじである。
なお、 tag は各データ毎に 32 bit の整数で表されており、
多倍長整数は 20 となっている。
ここで 32 bit の整数の表現方法について説明する必要がある。
OpenXM ではバイト列で 32 bit の整数 20 を
{\tt 00 00 00 14} と表す方法と {\tt 14 00 00 00} と表す方法がある。
この表現方法の違いはクライアントとサーバの最初の接続時に
双方の合意で決定することになっている。
なお、合意がない場合には
前者の表現方法(以後、この表現方法を network byte order と呼ぶ)を
使うことになっている。
また、負の数を表現する必要があるときには、
2 の補数表現を使うことになっている。

表現したい多倍長整数の絶対値を 2 進数で表した場合の桁数を $n$ と
したとき、次にくるデータは $[(n+31)/32]$ を 32 bit の整数となる。
これは多倍長整数の絶対値を $2^{32}$ 進数で表した場合の桁数ととってもよい。
ただし、表現したい数が負の場合は $[(n+31)/32]$ を 32 bit の整数で表した値を
 2 の補数表現で負にして、正の場合と区別する。

表現したい多倍長整数の絶対値が $2^{32}$ 進数で $(b_0 b_1 ... b_k)_{2^{32}}$
と表せるとき、次にくるデータは $b_0$, $b_1$, $\cdots$, $b_k$ を
それぞれ 32 bit の整数で表現した値となる。
%以下は書き直しの必要があるかも...
なお、 GNU MP LIBRARY を用いると、
C 言語から多倍長整数や任意精度浮動小数を扱うことができる。
$b_0$, $b_1$, $\cdots$, $b_k$ をそれぞれ 32 bit 整数で表現した値は
この GNU MP LIBRARY で用いられている多倍長整数で使われている形式を
参考にして合わせてある。

ここで具体例をだそう。
$4294967298 = 1 \times 2^{32} + 2$ を network byte order の多倍長整数で
表現すると、
\begin{center}
	{\tt 00 00 00 14 00 00 00 02 00 00 00 02 00 00 00 01}
\end{center}
となる。また、同じ表現方法で $-1$ を表現すると、
\begin{center}
	{\tt 00 00 00 14 ff ff ff ff 00 00 00 01}
\end{center}
となる。


\section{MathCap について}

サーバおよびクライアント双方ともに OpenXM で規定されている
メッセージの中のデータ形式をすべて受け取れるわけではない。
しかも、 OpenXM 規約で規定されているデータ形式だけが
受渡しに使われるというわけではない。
そこで、 OpenXM では相手側が受け取ることができるデータ形式を
収得する方法を用意している。

CMO 形式で定義されている MathCap データは
%理解可能なメッセージの
受け取ることができるデータ形式を表すデータであり、
要求されればサーバはサーバ自身の MathCap データをスタックに積む。
また、クライアントから MathCap データをサーバへ送ることもでき、
MathCap データをサーバとクライアントの間で交換することによって、
お互いに相手側が受け取ることができないデータ形式で
メッセージを送ってしまうのを防ぐことができる。
なお、 MathCap データの中では CMO 形式で定義されている
32 bit 整数、文字列、リスト構造が使われており、
MathCap データに含まれている内容を理解できるためには
必然的にこれらも理解できる必要がある。

OpenXM 対応版の asir サーバである ox\_asir が返す MathCap を以下に示す。

%なお、 $a_1$, $a_2$, $\cdots$, $a_n$ を要素に
%持つリスト構造を {\tt [$a_1$, $a_2$, $\cdots$, $a_n$]} 、
%文字列 ``string'' を {\tt "string"} 、 32 bit 整数を
%それに対応する 10 進数の整数で示す。

%↓手で作ったので間違えている可能性あり。
%%古いバージョン。差し替えの必要あり。
\begin{verbatim}
[ [199901160,"ox_asir"],
  [276,275,258,262,263,266,267,268,274
    ,269,272,265,264,273,300,270,271],
  [ [514,[1,2,3,4,5,2130706433,2130706434
          ,17,19,20,21,22,24,25,26,31,27,33,60]],
    [2144202544,[0,1]]
  ]
]
\end{verbatim}

この MathCap データのリスト構造は大きく分けて 3 つの部分に分かれる。
最初の {\tt [199901160,"ox\_asir"]} の部分にはサーバの情報が入っている。
%この最初の要素がまたリスト構造となっており、
最初の要素はバージョンナンバーを、次の要素はサーバの名前を表している。

次の {\tt [276,275,$\cdots$,271]} の部分は
サーバに対する動作に対応した理解可能なデータの種類を表している。
サーバの動作に対するデータはすべて 32 bit の整数で表しており、
このリストは理解可能なデータに対応する 32 bit 整数のリストとなっている。

最後の {\tt [ [514,[1,2,3,$\cdots$,60]],[2144202544,[0,1]] ]} の部分は
理解可能なデータの形式を表している。
この部分はさらに {\tt [514,[1,2,3,$\cdots$,60]]} と
{\tt [2144202544,[0,1]]} にの部分に分けることができ、
それぞれが一つのデータ形式についての情報となっている。
どのデータ形式についての情報かは最初の要素にある整数値をみれば
分かるようになっている。
この整数値は CMO 形式では 514 となっている。
最初のデータ形式を区別する整数値以後の要素は
各データ形式によってどのように使われるか定まっている。
CMO 形式では理解可能なデータの tag がリストの中に収まっている。
前節で CMO 形式では多倍長整数を表す tag が 20 であることを述べたが、
このリストに 20 が含まれているので、
ox\_asir は CMO 形式の多倍長整数を受け取れることがわかる。

%%このリストの要素はまたリストとなっており、
%この最後の部分もまたリストとなっており、
%あるデータ形式で理解可能なものを表現したリストを要素としている。
%{\tt [514,[1, 2, $\cdots$]]} の最初の 514 はこのリストが CMO 形式
%での理解可能なデータを表していることを示しており、
%その後のリストでは CMO 層で定義されているデータのうち、
%理解可能なデータの tag が並んでいる。

なお、データが受け取れることと、
データの論理構造が理解できることとはまったく別物であるので
注意する必要がある。


\section{セキュリティ対策}

OpenXM では幾らかのセキュリティ対策を考えている。
OpenXM に対応したソフトウェアをクラックしても
大した利点はないと思えるが、それは設計上の話であって、
予期せぬ手段で攻撃を受けた場合にどのような事態を
招くかは想像し難い。


%まず、接続が必要になった時に、クライアントがサーバ側からの
%接続を待つようになっている。これは常に接続を待つことによって、
%侵入者に接続の機会を与えてしまうことを減らすためである。

%次に、クライアントが接続毎に接続を待つ port 番号をランダムに決定する
%ことになっている。これにより、侵入者がどこに接続を行なえばよいのか
%わかりにくくしている。

%最後に、接続時にクライアントが 1 回のみ有効なパスワードを発行し、
%認証を行なうようになっている。このパスワードは一旦使用されると
%無効になるので、もし仮になんらかの手段でパスワードが洩れたとしても
%安全である。なお、このパスワードは安全な手段で送られていないと
%いけない。また、現在の実装ではサーバ、およびクライアントの動作している
%コンピュータ上ではこのパスワードがわかってしまうため、
%同一のコンピュータ上に悪意のあるユーザはいないと仮定している
%ことに注意しなければならない。

%なお、接続が確立した後のメッセージの送受信に関しては、
%特に暗号化などの処置が行なわれているわけではない。
%もし必要があれば、通信路の暗号化を行なう機能がある
%ソフトウェアを使うことを考えている。


\section{他のプロジェクト}

他のプロジェクトについて幾つか紹介する。

OpenMath プロジェクトは数学的なオブジェクトを
コンピュータ上で表現する方法を決定している。
各ソフトウェア間でオブジェクトを交換する際の
オブジェクトの変換手順についても述べられている。
表現方法は一つだけでなく、 XML 表現や binary 表現などが
用意されている。

%以下、調べる必要あり。
%NetSolve

%MP

%MCP

\section{現在提供されているソフトウェア}

現在 OpenXM 規格に対応しているクライアントソフトウェアには
asir, sm1, Mathematica がある。
これらのクライアントソフトウェアから
OpenXM 規格に対応したサーバを呼び出すことができる。
現在 OpenXM 規約に対応しているサーバソフトウェアには、
 asir, sm1, gnuplot, Mathematica などがあり、
それぞれ ox\_asir, ox\_sm1, ox\_math という名前で提供されている。
また、 OpenMath 規格の XML 表現で表現されたデータと CMO 形式の
データを変換するソフトウェアが JAVA によって実装されており、
OMproxy という名前で提供されている。

\end{document}
