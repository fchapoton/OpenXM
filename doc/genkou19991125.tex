\documentclass{jarticle}

\title{タイトル未定}
\author{
前川 将秀\thanks{神戸大学理学部数学科},
野呂 正行\thanks{富士通研究所},
小原 功任\thanks{金沢大学理学部計算科学教室}, \\
奥谷 行央
%\thanks{神戸大学大学院自然科学研究科博士課程前期課程数学専攻},
\thanks{神戸大学大学院自然科学研究科数学専攻},
高山 信毅\thanks{神戸大学理学部数学教室},
田村 恭士
%\thanks{神戸大学大学院自然科学研究科博士課程後期課程情報メディア科学専攻計算システム講座}
\thanks{神戸大学大学院自然科学研究科情報メディア科学専攻}
}
\date{1999年11月25日}
%\pagestyle{empty}

\begin{document}
\maketitle

\section{OpenXMとは}

OpenXM は数学プロセス間でメッセージを交換するための規約である。
数学プロセス間でメッセージをやりとりすることにより、
ある数学プロセスから他の数学プロセスを呼び出して計算を行なったり、
他のマシンで計算を行なわせたりすることが目的である。
なお、 OpenXM とは Open message eXchange protocol for Mathematics の略である。
OpenXM の開発の発端は野呂と高山により、
asir と kan/sm1 を相互に呼び出す機能を実装したことである。

%発端となった asir と kan/sm1 での実装時には、
初期の実装では、相手側のローカル言語の文法に従った文字列を送っていた。
現在の OpenXM 規約では共通表現形式によるメッセージを用いている。
この方法では相手側のソフトが asir なのか kan/sm1 なのかを判別するなどして、
相手側のローカル言語の文法に合わせた文字列を作成する必要がなくなる。
しかし、ローカル言語の文法に従った文字列を送る方法も、
効率的であるとはいい難いが、使いやすい。
そのため、 OpenXM 規約では共通表現形式の中の文字列として、
ローカル言語の文法に従った文字列を用いた
メッセージの交換も可能となっている。

%OpenXM 規約独自のデータ形式である CMO 形式(Common Mathematical Object format)
%以外にも、 MP や OpenMath の XML, binary 表現形式といった他の形式をも
%扱えるようにしてある。

OpenXM 規約では通信路の確保の方法に幾らかの自由度があるが、
現在は TCP/IP ソケットを用いた実装しかない。
%通信の実現方法は通信路のとりかたにより変わる。
そこで、以後ここでは具体的な実装は TCP/IP ソケットを
用いていると仮定する。


\section{OpenXM のメッセージの構造}

OpenXM で規定されている TCP/IP 実装によるメッセージは
バイトストリームとなっており、
次のような構造になっている。

\begin{tabular}{|c|c|} \hline
ヘッダ	& \hspace{10mm} ボディ \hspace{10mm} \\ \hline
\end{tabular}

ヘッダの長さは 8 バイトであると定められている。
ボディの長さはメッセージごとに異なっているが、
長さは $0$ でもよい。

ヘッダは次の二つの情報を持っている。
\begin{enumerate}
\item	前半の 4 バイト。メッセージの種類を表わす識別子であり、
	タグと呼ばれる。
\item	後半の 4 バイト。メッセージにつけられた通し番号である。
\end{enumerate}
それぞれの 4 バイトは 32 ビット整数とみなされて扱われる。
この場合に用いられる整数の表現方法の説明については後述するが、
基本的に表現方法はいくつかの選択肢から選ぶことが可能となっており、
またその選択は通信路の確立時に一度だけなされることに注意しなければならない。
OpenXM 規約で定義されているタグの整数値で
よく使われると思うものを以下にあげておく。

\begin{verbatim}
#define	OX_COMMAND	513
#define	OX_DATA	514
\end{verbatim}

ボディの中身はタグによるメッセージの種類によって
それぞれ独立に決められるようになっている。
もし、システム固有の表現を OpenXM 規約のメッセージに
埋め込んで使いたい場合には、
タグの値をこのような用途のために推奨されている
整数値の範囲に設定し、
システム固有の表現をボディに埋め込めばよい。


\section{OpenXM の計算モデル}

%{\Huge この節では計算モデルの話をしなければいけません}

OpenXM 規約での計算とはメッセージを交換することである。
また、 OpenXM 規約ではクライアント・サーバモデルを採用しているので、
メッセージの交換はサーバとクライアントの間で行なわれる。
クライアントからサーバへメッセージを送り、
サーバからクライアントがメッセージを受け取ることによって
計算の結果が得られる。

サーバはスタックマシンであると仮定されており、
サーバがクライアントから受け取ったメッセージは、
タグが OX\_COMMAND でなければすべてスタックに積まれる。
タグが OX\_COMMAND となっているメッセージは
スタックマシンへの命令であり、このメッセージを受け取ったサーバは
それに対応する動作を行なうことが期待されている。
しかし、サーバはメッセージを受け取らない限り、
自ら何か動作を行なおうとはしない。
これは毎回サーバへメッセージを送るたびに、
いつもサーバからのメッセージをクライアントが待つ必要がないことを意味する。
このため、クライアントはサーバの状態を気にせずにメッセージを送り、
一旦メッセージを送付し終えた後、
サーバへ送ったメッセージの結果を
サーバから待つことなしに次の動作に移ることができる。


\section{OpenXM の計算の進行方法}

サーバが行うのは基本的に次の事柄だけである。
クライアントからメッセージを受け取ると、
サーバはまずメッセージの識別子を調べ、
タグが OX\_COMMAND のメッセージでなければスタックに積む。
タグが OX\_COMMAND のメッセージであればメッセージのボディから
スタックマシンの命令コードを取りだし、
あらかじめ規約で定められた動作を行なう。

上の説明でわかるように、
サーバはクライアントからの指示なしに、
自らメッセージを送らないことに注意する必要がある。
%(例外? ox\_asir の mathcap)。

サーバがクライアントから受け取ったメッセージはすべてスタックに積まれている。
次いでサーバにスタックマシンへの命令を送ると、
初めてサーバはデータをスタックに積む以外のなんらかの動作を行なう。
このとき、必要があればサーバはスタックから必要なだけデータを取り出す。
ここで、クライアントからの命令による動作中にたとえエラーが発生したとしても
サーバはエラーオブジェクトをスタックに積むだけで、
明示されない限りエラーをクライアントへ返さないことに注意しなければならない。

結果が生じる動作をサーバが行なった場合、
サーバは動作の結果をスタックに積む。
サーバに行なわせた動作の結果をクライアントが知りたい場合、
スタックからデータを取り出し送信を行なう命令をサーバ側へ送ればよい。

%{\Huge 以下、書き直し}

クライアントがサーバへメッセージを送り、
計算の結果を得るという手順を追っていくと次のようになる。

\begin{enumerate}
\item	まず、クライアントがサーバへメッセージを送る。
	サーバは送られてきたメッセージをスタックに積む。
\item	クライアントがサーバにスタックマシンへの命令を送ると、
	サーバは必要なだけスタックからデータを取り出し、
	実行した結果をスタックに積む。
\item	最後に「スタックからデータを取り出し送信を行なう命令」を
	サーバへ送ると、サーバはスタックから計算結果の入っている
	データを取り出し、クライアントへ送出する。
\end{enumerate}


\section{CMO のデータ構造}

OpenXM 規約では、数学的オブジェクトを表現するオリジナルの方法として
CMO 形式(Common Mathematical Object format)を定義している。
この CMO 形式を使ってメッセージを送るには、
タグを OX\_DATA にすればよい。
CMO 形式におけるメッセージのボディ部分について以下で説明するが、
%OpenXM 規約で定義されているメッセージを実際に作成する場合、
CMO 形式で定義されている多倍長整数を理解しておくと、
CMO 形式の他のデータ構造だけでなく、
OpenXM 規約で定義されている様々なデータ構造を理解する助けになると思えるので、
ここでは CMO 形式の多倍長整数のデータ構造についてのみ説明する。

CMO 形式で定義されているデータは多倍長整数以外にも
文字列やリスト構造などがある。どのようなデータであるかは
データの先頭にある(メッセージの識別子とは別にある)タグを見れば
判別できるようになっている。
これはメッセージの種類の判別の仕方とおなじである。
なお、タグは各データ毎に 32 bit の整数で表されており、
多倍長整数は 20 となっている。
よく使われると思われる CMO 形式のタグをあげておく。
\begin{verbatim}
#define CMO_INT32  2  /* 32 ビット整数 */
#define CMO_STRING 4  /* 文字列        */
#define CMO_LIST   17 /* リスト構造    */
#define CMO_ZZ     20 /* 多倍長整数    */
\end{verbatim}

ここで TCP/IP 実装における 32 bit の整数の
表現方法について説明する必要がある。
OpenXM 規約の TCP/IP 実装ではバイトストリームで 32 bit の整数 20 を
{\tt 00 00 00 14} と表す方法と {\tt 14 00 00 00} と表す方法がある。
この表現方法の違いはクライアントとサーバの最初の接続時に
双方の合意で決定することになっている。
なお、合意がない場合には前者の表現方法
(以後、この表現方法をネットワークバイトオーダーと呼ぶ)を
使うことになっている。
また、負の数を表現する必要があるときには、
2 の補数表現を使うことになっている。

CMO 形式の多倍長整数は、 GNU MP LIBRARY 等を参考にしており、
符合付き絶対値表現を用いている。
タグ以降の形式は次のようになる。

\begin{tabular}{|c|c|c|c|c|} \hline
$f$ & $b_0$ & $b_1$ & $\cdots$ & $b_{n-1}$ \\ \hline
\end{tabular}

ここで、 1 つの枠は 4 バイトを表し、
$f$ は符合付き 32 ビット整数を、
$b_0$, $b_1$, $\cdots$, $b_{n-1}$ は符合なし 32 ビット整数を表している。
さらに、 $|f| = n$ が成り立たなければならない。
このオブジェクトは
\[ \mbox{sgn}(f) \times \{ b_0 (2^{32})^0 + b_1 (2^{32})^1 + \cdots
	+ b_{n-1} (2^{32})^{n-1} \}	\]
という整数であると定義されている。
ただし、
\[ \mbox{sgn}(f) = \left\{ \begin{array}{ll}
        1       & f>0 \\
        0       & f=0 \\
        -1      & f<0 \\ \end{array} \right.	\]
である。

ここで具体例をだそう。
$4294967298 = 1 \times 2^{32} + 2$ を CMO 形式の
ネットワークバイトオーダー、多倍長整数で表現すると、
\begin{center}
	{\tt 00 00 00 14 00 00 00 02 00 00 00 02 00 00 00 01}
\end{center}
となる。また、同じ表現方法で $-1$ を表現すると、
\begin{center}
	{\tt 00 00 00 14 ff ff ff ff 00 00 00 01}
\end{center}
となる。


\section{MathCap について}

OpenXM 規約では、通信時に用いられるメッセージの種類を
各ソフトウェアが制限する方法を用意している。
なぜなら、サーバおよびクライアント双方ともに OpenXM で規定されている
すべてのメッセージの種類を受け取れるわけではないからである。
そこで、 OpenXM では相手側が受け取ることができる
メッセージの種類を収得する方法を用意している。

CMO 形式で定義されている MathCap データは
%理解可能なメッセージの
受け取ることができるデータ形式を表すデータであり、
要求されればサーバはサーバ自身の MathCap データをスタックに積む。
また、クライアントから MathCap データをサーバへ送ることもでき、
MathCap データをサーバとクライアントの間で交換することによって、
お互いに相手側が受け取ることができないデータ形式で
メッセージを送ってしまうのを防ぐことができる。
なお、 MathCap データの中では CMO 形式で定義されている
32 bit 整数、文字列、リスト構造が使われており、
MathCap データに含まれている内容を理解できるためには
必然的にこれらも理解できる必要がある。

OpenXM 対応版の asir サーバである ox\_asir が返す MathCap を以下に示す。

なお、 $a_1$, $a_2$, $\cdots$, $a_n$ を要素に
持つリスト構造を {\tt [$a_1$, $a_2$, $\cdots$, $a_n$]} 、
文字列 ``string'' を {\tt "string"} 、 32 bit 整数を
それに対応する 10 進数の整数で示す。

%↓手で作ったので間違えている可能性あり。
%%古いバージョン。差し替えの必要あり。
\begin{verbatim}
[ [199901160,"ox_asir"],
  [276,275,258,262,263,266,267,268,274
    ,269,272,265,264,273,300,270,271],
  [ [514,[1,2,3,4,5,2130706433,2130706434
          ,17,19,20,21,22,24,25,26,31,27,33,60]],
    [2144202544,[0,1]]
  ]
]
\end{verbatim}

この MathCap データのリスト構造は大きく分けて 3 つの部分に分かれる。
最初の {\tt [199901160,"ox\_asir"]} の部分にはサーバの情報が入っている。
%この最初の要素がまたリスト構造となっており、
最初の要素はバージョンナンバーを、次の要素はサーバの名前を表している。

次の {\tt [276,275,$\cdots$,271]} の部分は
スタックマシンに対する命令のうち、利用可能な命令の種類を表している。
スタックマシンへの命令はすべて 32 ビットの整数で表しており、
このリストは利用可能な命令に対応する 32 ビットの整数のリストとなっている。

最後の {\tt [ [514,[1,2,3,$\cdots$,60]],[2144202544,[0,1]] ]} の部分は
理解可能なデータの形式を表している。
この部分はさらに {\tt [514,[1,2,3,$\cdots$,60]]} と
{\tt [2144202544,[0,1]]} にの部分に分けることができ、
それぞれが一つのデータ形式についての情報となっている。
どのデータ形式についての情報かは最初の要素にある整数値をみれば
分かるようになっている。
この整数値は CMO 形式では 514 となっている。
最初のデータ形式を区別する整数値以後の要素は
各データ形式によってどのように使われるか定まっている。
CMO 形式では理解可能なデータのタグがリストの中に収まっている。
前節で CMO 形式では多倍長整数を表すタグが 20 であることを述べたが、
このリストに 20 が含まれているので、
ox\_asir は CMO 形式の多倍長整数を受け取れることがわかる。

なお、データが受け取れることと、
データの論理構造が理解できることとはまったく別物であるので
注意する必要がある。


\section{セキュリティ対策}

OpenXM では幾らかのセキュリティ対策を考えている。
OpenXM に対応したソフトウェアをクラックしても
大した利点はないと思えるが、それは設計上の話であって、
予期せぬ手段で攻撃を受けた場合にどのような事態を
招くかは想像し難い。

そこで、 OpenXM では侵入者に攻撃の機会を
できるだけ与えないようにしている。
具体的には、接続が必要になった時のみ接続を待つようにし、
常に接続に関与するといったことは避けている。

しかし、これだけでは侵入者が接続を行なう一瞬のすきを
狙ってくる可能性もある。
そこで接続を行なう時に、
接続を待つポート番号をランダムに決めている。
こうすることで、特定のポート番号を狙って接続を行なう
瞬間を待つ手口を幾らか防ぐことができる。

さらにもう一段安全性を高めるために、
接続時に 1 回だけ使用可能なパスワードを作成し、
そのパスワードを使って認証を行なう。
このパスワードは一旦使用されれば無効にするので、
もし仮になんらかの手段でパスワードが洩れたとしても安全である。

なお、上記のポート番号とパスワードは安全な手段で送られて
いると仮定している。
また、同一のコンピュータ上に悪意のあるユーザはいないと仮定している
ことに注意しなければならない。
なぜなら、現在の実装ではサーバ、およびクライアントの動作している
コンピュータ上ではこのポート番号とパスワードがわかってしまうためである。

なお、接続が確立した後のメッセージの送受信に関しては、
特に暗号化などの処置が行なわれているわけではない。
もし必要があれば、通信路の暗号化を行なう機能がある
ソフトウェアを使うことを考えている。


\section{他のプロジェクト}

他のプロジェクトについても触れておこう。

OpenMath プロジェクトは数学的なオブジェクトを
コンピュータ上で表現する方法を決定している。
各ソフトウェア間でオブジェクトを交換する際の
オブジェクトの変換手順についても述べられている。
表現方法は一つだけでなく、 XML 表現や binary 表現などが
用意されている。
詳細は

http://www.openmath.org/omsoc/index.html A.M.Cohen


以下は書いてる途中。

NetSolve

http://www.cs.utk.edu/netsolve/


MP

http://symbolicNet.mcs.kent.edu/SN/areas/protocols/mp.html


MCP

http://horse.mcs.kent.edu/~pwang/


\section{現在提供されているソフトウェア}

現在 OpenXM 規格に対応しているクライアントには
asir, sm1, Mathematica がある。
これらのクライアントから
OpenXM 規格に対応したサーバを呼び出すことができる。
現在 OpenXM 規約に対応しているサーバソフトウェアには、
 asir, sm1, gnuplot, Mathematica などがあり、
それぞれ ox\_asir, ox\_sm1, ox\_math という名前で提供されている。
また、 OpenMath 規格の XML 表現で表現されたデータと CMO 形式の
データを変換するソフトウェアが JAVA によって実装されており、
OMproxy という名前で提供されている。


\end{document}
