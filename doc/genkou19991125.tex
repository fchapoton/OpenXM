\documentclass{jarticle}

\title{\bf Open XM(タイトル未定)}
\author{
        Maekawa \\
        Noro \\
        : \\
        : \\
}
\date{ 1999年, 11月25日}

%\pagestyle{empty}

\begin{document}
\maketitle

\section{OpenXM の計算モデル}

OpenXM は数学ソフト間でメッセージを交換するための規約である。
OpenXM とは Open message eXchange protocol for Mathematics の略である。
数学ソフト間でメッセージをやりとりさせることにより、
ある数学ソフトから他の数学ソフトを呼び出して計算を行なったり、
他のマシンで計算を行なわせたりできるようにする。
発端は野呂正行と高山信毅により、 asir と kan/sm1 を
相互に呼び出す機能を実装したことである。
現在の目標は、フリーの数学ソフトを相互に接続して
好きな言語から簡単に他の数学ソフトを使えるようにすることである。

発端となった asir と kan/sm1 での実装時には、
お互いに相手側のコマンド文字列を送っていた。
この方法は現在の OpenXM 規約でも可能であり、
使いやすくはあるが、効率的であるとはいい難い。
さらに、この方法では相手側のソフトが asir なのか kan/sm1 なのかを
判別して、相手側に合わせてコマンド文字列を作成する必要がある。

これ以外の方法として、 OpenXM 規約では共通表現形式による
メッセージを用意している。
OpenXM 規約独自のデータ形式である CMO 形式(Common Mathematical Object format)
以外にも、 MP や OpenMath の XML, binary 表現形式といった他の形式をも
扱えるようにしてある。


\section{OpenXM のメッセージの構造}

OpenXM で規定しているメッセージは論理的に
OX 層、 SM 層、 CMO 層に分けることができる。
この中で、メッセージとして送ることが可能なのは
OX 層で定義されたものだけであり、
SM 層、 CMO 層で定義されているデータは
OX 層で定義されているデータの一部に埋め込まれて
送られる。
SM 層、 CMO 層で定義されているデータ以外にも
前述の MP や OpenMath の XML, binary 表現も
OX 層に埋め込まれて送られるわけであるが、
どのようなデータが埋め込まれているかは、
OX 層の先頭の tag を見れば判別できるようになっている。


\section{OpenXM の計算の進行方法}

OpenXM 規約でのメッセージの交換はサーバとクライアントの間で
行なわれる。クライアントからサーバへ計算させたいデータを
メッセージとして送り、次いでサーバに行なわせたい動作に
対応したデータを送ることによって、計算などの、なんらかの動作を
サーバに行なわせる。サーバは結果の送信も命令されなければ
行なうことはなく、クライアントは結果を受け取らずにサーバに次々と
計算を行なわせることも可能である。なお、サーバに対する動作に対応した
データは SM 層で定義されており、 SM 層以外のデータではサーバは
データを受け取る以外の動作をしないことになっている。

サーバはスタックを持っていると仮定されており、受け取った
メッセージはすべてスタックに積まれる。ここで、 SM 層で定義された
データを受け取った場合には、それに対応する動作を行なう。
このとき、必要があればサーバはスタックからデータを取り出す。
クライアントからの命令による動作中にエラーが発生したとしても、
サーバはエラーオブジェクトをスタックに積むだけで、
明示されない限りエラーを返さないことに注意しなければならない。

結果が生じる動作をサーバが行なった場合、
サーバは動作の結果をスタックに積んでいる。
サーバに行なわせた動作の結果をクライアントが知りたい場合、
スタックからデータを取り出し送信を行なう命令に対応した SM 層のデータを
サーバ側へ送ればよい。

クライアントがサーバへ計算を行なわせ、結果を得るという手順を追っていくと、
次のようになる。

\begin{enumerate}
\item	まず、クライアントがサーバへ計算させたいデータを送る。
	サーバは送られてきたデータをスタックに積む。
\item	クライアントがサーバに計算を行なう動作に対応したデータを
	送ると、サーバは必要なだけスタックからデータを取り出し、
	実行した計算の結果をスタックに積む。
\item	最後に「データを取り出し送信を行なう命令に対応したデータ」を
	サーバへ送ると、サーバはスタックから計算結果の入っている
	データを取り出し、クライアントへ送出する。
\end{enumerate}


\section{CMO のデータ構造}

OpenXM 間でやりとりされるメッセージを実際に作成する場合、
CMO 層で定義されている多倍長整数を理解しておくと、
CMO 層の他のデータ構造だけでなく、 OX 層、 SM 層のデータを
理解する助けになると思えるので、 CMO 層の多倍長整数の
データ構造について説明する。

CMO 層で定義されているデータは多倍長整数以外にも
文字列やリストなどがある。どのようなデータであるかは
データの先頭にある tag を見れば判別できるようになっている。
これは OX 層でのデータの判別の仕方とおなじである。
なお、 tag は各データ毎に 32 bit の整数で表されており、
多倍長整数は 20 となっている。
ここで 32 bit の整数の表現方法について説明する必要がある。
%昨今のコンピュータ事情から、
%32 bit 整数も 8 bit 単位で扱うほうが都合がよい。
OpenXM では 8 bit 単位で $( \mbox{\tt 00 00 00 14})_{2^8}$ と表す方法と
$( \mbox{\tt 14 00 00 00})_{2^8}$ と表す方法がある。
この表現方法の違いはクライアントとサーバの最初の接続時に
双方の合意で決定することになっている。なお、合意がない場合には
前者の表現方法(以後、この表現方法を network byte order と呼ぶ)を
使うことになっている。
また、負の数を表現する必要があるときには、
2 の補数表現を使うことになっている。

表現したい多倍長整数の絶対値を 2 進数で表した場合の桁数を $n$ と
したとき、次にくるデータは $[(n+31)/32]$ を 32 bit の整数となる。
これは多倍長整数の絶対値を $2^{32}$ 進数で表した場合の桁数ととってもよい。
ただし、表現したい数が負の場合はこの 32 bit の整数値は 2 の補数表現で負になる。

%表現したい多倍長整数が負であってもこれ以降の説明は正の場合と
%変わらないので、以後多倍長整数は正とみなす。

表現したい多倍長整数の絶対値が $2^{32}$ 進数で $(b_0 b_1 ...)_{2^{32}}$
と表せるとき、次にくるデータは $b_0$, $b_1$, $\cdots$ を
32 bit の整数で表現した値となる。

ここで具体例をだそう。
$4294967298 = 1 \times 2^{32} + 2$ を network byte order の多倍長整数で
表現すると、
\begin{center}
	{\tt 00 00 00 14 00 00 00 02 00 00 00 02 00 00 00 01}
\end{center}
となる。また、同じ表現方法で $-1$ を表現すると、
\begin{center}
	{\tt 00 00 00 14 ff ff ff ff 00 00 00 01}
\end{center}
となる。


\section{MathCap について}

%前節で見たように、 1 つのメッセージの長さは決まっていない。
サーバおよびクライアント双方ともに OpenXM で規定されている
すべてのメッセージを理解できるわけではない。
そこで、 OpenXM では相手の理解可能なメッセージを
収得する方法を用意している。
CMO 層で定義されている MathCap データは



\section{security 対策}

\section{他のプロジェクト}

\section{現在提供されているソフトウェア}

\end{document}
