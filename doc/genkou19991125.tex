\documentclass{jarticle}

\title{タイトル未定}
\author{
前川 将秀\thanks{神戸大学理学部数学科},
野呂 正行\thanks{富士通研究所},
小原 功任\thanks{金沢大学}, \\
奥谷 幸夫\thanks{神戸大学大学院自然科学研究科博士課程前期課程数学専攻},
高山 信毅\thanks{神戸大学理学部数学教室},
田村 恭士\thanks{神戸大学大学院自然科学研究科博士課程後期課程情報メディア科学専攻計算システム講座}
}
\date{1999年11月25日}
%\pagestyle{empty}

\begin{document}
\maketitle

\section{OpenXMとは}

OpenXM は数学プロセス間でメッセージを交換するための規約である。数学プロ
セス間でメッセージをやりとりさせることにより、ある数学プロセスから他の数
学プロセスを呼び出して計算を行なったり、他のマシンで計算を行なわせたりす
ることが目的である。なお、 OpenXM とは Open message eXchange protocol
for Mathematics の略である。
OpenXM の開発の発端は野呂正行と高山信毅により、 asir と kan/sm1 を
相互に呼び出す機能を実装したことである。
%\footnote{この段落必要?}

発端となった asir と kan/sm1 での実装時には、
お互いに相手側のコマンド文字列を送っていた。
この方法は現在の OpenXM 規約でも形を変えて可能ではあるが、
使いやすい反面、効率的であるとはいい難い。
さらに、この方法では相手側のソフトが asir なのか kan/sm1 なのかを
判別して、相手側に合わせてコマンド文字列を作成する必要がある。

これ以外の方法として、
OpenXM 規約では共通表現形式によるメッセージも用意している。
OpenXM 規約独自のデータ形式である CMO 形式(Common Mathematical Object format)
以外にも、 MP や OpenMath の XML, binary 表現形式といった他の形式をも
扱えるようにしてある。
なお、現在の OpenXM 規約では、
前述のコマンド文字列も CMO 形式などの何らかのデータ形式の中の
文字列として表現して送る必要がある。

\section{OpenXM の計算モデル}

{\Huge この節では計算モデルの話をしなければいけませんよ、田村君}

OpenXM 規約での計算とはメッセージを交換することである。
そして、そのメッセージの交換はサーバとクライアントの間で行なわれる。
クライアントからサーバへメッセージを送り、
メッセージに対する返答を受け取ることによって
計算の結果が得られる。

サーバはスタックマシンであると仮定されており、
サーバがクライアントから受け取ったメッセージはすべてスタックに積まれる。
OpenXM のメッセージの中にはサーバに行なわせたい動作に対応するデータがあり、
このメッセージを受け取ったサーバはそれに対応する動作を
行なうことが期待されている。
ただし、サーバは命令されない限り何も動作を行なおうとはしない。
このため、クライアントはサーバへ送ったメッセージの結果を
サーバから

これはクライアントがサーバへ一旦メッセージを送付し終えると、
あとはサーバ側の状態を気にせずにクライアントは
クライアント自身の仕事に戻れることを意味する。


\section{OpenXM のメッセージの構造}

{\Huge この節では構造の話をしなければいけませんよ、田村君}

OpenXM のメッセージはバイトストリームであり、次のような構造を持つ。
\begin{verbatim}
ヘッダ  ボディ
\end{verbatim}
ヘッダの長さは8バイトであると定められている。ボディの長さはメッセージご
とに異なる($0$でもよい)。
ヘッダは次の二つの情報を持つ。
\begin{enumerate}
\item 前半の4バイト。タグと呼ばれ、メッセージの種類を表わす識別子である。
\item 後半の4バイト。メッセージにつけられた通し番号である。
\end{enumerate}

それぞれの4バイトは32ビット整数とみなされて処理される。
この場合に用いられる整数の表現方法については後述するが、基本的に
表現方法はいくつかの選択肢から選ぶことが可能であり、
また選択は通信路の確立時に一度だけなされることに注意しておこう。

{\Huge 以下、書き直してね。}

ボディの中のデータがどのように格納されているかは
各データ形式がそれぞれ独立に決められるようになっている。
もし、 OpenXM 規約でメッセージのやりとりを行ないたいが、
まだ規約で定義されていないデータ形式を使いたい場合は、
タグをまだ使われてなさそうな値
(システム固有の表現のために推奨されている値がある)
に設定し、 ボディの部分にデータを埋め込めばよい。
なお、すべてのメッセージに ボディが必要というわけではなく、
ボディのないメッセージも OpenXM 規約には存在することに
注意しなければならない。

サーバに対する動作に対応したデータは SM 形式として定義されている。
SM 形式以外のデータでは、サーバは受け取ったデータをスタックに積む
以外の動作をしないことになっている。
つまり、 SM 形式のデータがデータを受け取る以外の動作を
サーバに行なわせる唯一のデータ形式である。
このデータを受け取る以外の動作の中には、
データになんらかの加工を施す動作も入っている。
このデータになんらかの加工を施す動作の中には
数学的な演算を行なう動作も含まれている。
以後、データになんらかの加工を施す動作のことを計算と呼ぶことにする。

\section{OpenXM の計算の進行方法}

OpenXM における計算とはメッセージの交換のことである。既に計算モデルの節
で説明したが(説明されているはずである)、OpenXM はサーバ・クライアントモ
デルを採用していて、サーバはスタックマシンの構造を持つ。サーバが行うのは
基本的に次の事柄に限られる。クライアントからメッセージを送られるとサーバ
は、まずメッセージの識別子を調べ、OX\_COMMAND でなければスタックに積む。
OX\_COMMAND であればメッセージのボディからスタックマシンのオペコードを取
りだし、あらかじめ規約で定められたアクションを起こす。

上の説明でわかるように、サーバはクライアントからの指示なしに、自らメッセー
ジを送ることはない(例外? ox\_asir の mathcap)。

{\Huge 以下、書き直してね、田村君}


% クライアントがサーバへなんらかの計算を行なわせる場合、
% クライアントからサーバへ計算させたいデータをメッセージとして送り、
% そしてその結果をサーバからメッセージで受け取ることによって計算は行なわれる。
% ただし、サーバは結果の送信すらも命令されなければ行なうことはなく、
% クライアントは結果を受け取らずにサーバに次々と
% 計算を行なわせることも可能である。

サーバがクライアントから受け取ったメッセージはすべてスタックに積まれる。
ただし、このままでは受け取ったメッセージに含まれるデータを
スタックに積み上げていくだけで、サーバは計算を行なおうとはしない。
次いでサーバに行なわせたい動作に対応したデータを送ると、
初めてサーバは計算などの、なんらかの動作を行なう。
このとき、必要があればサーバはスタックから必要なだけデータを取り出す。
ここで、クライアントからの命令による動作中にたとえエラーが発生したとしても
サーバはエラーオブジェクトをスタックに積むだけで、
明示されない限りエラーを返さないことに注意しなければならない。

結果が生じる動作をサーバが行なった場合、
サーバは動作の結果をスタックに積んでいる。
サーバに行なわせた動作の結果をクライアントが知りたい場合、
スタックからデータを取り出し送信を行なう命令に対応した SM 形式のデータを
サーバ側へ送ればよい。

クライアントがサーバへ計算を行なわせ、結果を得るという手順を追っていくと、
次のようになる。

\begin{enumerate}
\item	まず、クライアントがサーバへ計算させたいデータを送る。
	サーバは送られてきたデータをスタックに積む。
\item	クライアントがサーバに「計算を行なう動作に対応したデータ」を
	送ると、サーバは必要なだけスタックからデータを取り出し、
	実行した計算の結果をスタックに積む。
\item	最後に「データを取り出し送信を行なう命令に対応したデータ」を
	サーバへ送ると、サーバはスタックから計算結果の入っている
	データを取り出し、クライアントへ送出する。
\end{enumerate}


\section{CMO のデータ構造}

OpenXM 間でやりとりされるメッセージを実際に作成する場合、
CMO 形式で定義されている多倍長整数を理解しておくと、
CMO 形式の他のデータ構造だけでなく、 OX 形式、 SM 形式のデータを
理解する助けになると思えるので、 CMO 形式の多倍長整数の
データ構造について説明する。

CMO 形式で定義されているデータは多倍長整数以外にも
文字列やリスト構造などがある。どのようなデータであるかは
データの先頭にあるタグを見れば判別できるようになっている。
これはメッセージのデータの判別の仕方とおなじである。
なお、タグは各データ毎に 32 bit の整数で表されており、
多倍長整数は 20 となっている。
ここで 32 bit の整数の表現方法について説明する必要がある。
OpenXM ではバイト列で 32 bit の整数 20 を
{\tt 00 00 00 14} と表す方法と {\tt 14 00 00 00} と表す方法がある。
この表現方法の違いはクライアントとサーバの最初の接続時に
双方の合意で決定することになっている。
なお、合意がない場合には
前者の表現方法(以後、この表現方法を network byte order と呼ぶ)を
使うことになっている。
また、負の数を表現する必要があるときには、
2 の補数表現を使うことになっている。

表現したい多倍長整数の絶対値を 2 進数で表した場合の桁数を $n$ と
したとき、次にくるデータは $[(n+31)/32]$ を 32 bit の整数となる。
これは多倍長整数の絶対値を $2^{32}$ 進数で表した場合の桁数ととってもよい。
ただし、表現したい数が負の場合は $[(n+31)/32]$ を 32 bit の整数で表した値を
 2 の補数表現で負にして、正の場合と区別する。

表現したい多倍長整数の絶対値が $2^{32}$ 進数で $(b_0 b_1 ... b_k)_{2^{32}}$
と表せるとき、次にくるデータは $b_0$, $b_1$, $\cdots$, $b_k$ を
それぞれ 32 bit の整数で表現した値となる。
%以下は書き直しの必要があるかも...
なお、 GNU MP LIBRARY を用いると、
C 言語から多倍長整数や任意精度浮動小数を扱うことができる。
$b_0$, $b_1$, $\cdots$, $b_k$ をそれぞれ 32 bit 整数で表現した値は
この GNU MP LIBRARY で用いられている多倍長整数で使われている形式を
参考にして合わせてある。

ここで具体例をだそう。
$4294967298 = 1 \times 2^{32} + 2$ を network byte order の多倍長整数で
表現すると、
\begin{center}
	{\tt 00 00 00 14 00 00 00 02 00 00 00 02 00 00 00 01}
\end{center}
となる。また、同じ表現方法で $-1$ を表現すると、
\begin{center}
	{\tt 00 00 00 14 ff ff ff ff 00 00 00 01}
\end{center}
となる。


\section{MathCap について}

サーバおよびクライアント双方ともに OpenXM で規定されている
メッセージの中のデータ形式をすべて受け取れるわけではない。
しかも、 OpenXM 規約で規定されているデータ形式だけが
受渡しに使われるというわけではない。
そこで、 OpenXM では相手側が受け取ることができるデータ形式を
収得する方法を用意している。

CMO 形式で定義されている MathCap データは
%理解可能なメッセージの
受け取ることができるデータ形式を表すデータであり、
要求されればサーバはサーバ自身の MathCap データをスタックに積む。
また、クライアントから MathCap データをサーバへ送ることもでき、
MathCap データをサーバとクライアントの間で交換することによって、
お互いに相手側が受け取ることができないデータ形式で
メッセージを送ってしまうのを防ぐことができる。
なお、 MathCap データの中では CMO 形式で定義されている
32 bit 整数、文字列、リスト構造が使われており、
MathCap データに含まれている内容を理解できるためには
必然的にこれらも理解できる必要がある。

OpenXM 対応版の asir サーバである ox\_asir が返す MathCap を以下に示す。

%なお、 $a_1$, $a_2$, $\cdots$, $a_n$ を要素に
%持つリスト構造を {\tt [$a_1$, $a_2$, $\cdots$, $a_n$]} 、
%文字列 ``string'' を {\tt "string"} 、 32 bit 整数を
%それに対応する 10 進数の整数で示す。

%↓手で作ったので間違えている可能性あり。
%%古いバージョン。差し替えの必要あり。
\begin{verbatim}
[ [199901160,"ox_asir"],
  [276,275,258,262,263,266,267,268,274
    ,269,272,265,264,273,300,270,271],
  [ [514,[1,2,3,4,5,2130706433,2130706434
          ,17,19,20,21,22,24,25,26,31,27,33,60]],
    [2144202544,[0,1]]
  ]
]
\end{verbatim}

この MathCap データのリスト構造は大きく分けて 3 つの部分に分かれる。
最初の {\tt [199901160,"ox\_asir"]} の部分にはサーバの情報が入っている。
%この最初の要素がまたリスト構造となっており、
最初の要素はバージョンナンバーを、次の要素はサーバの名前を表している。

次の {\tt [276,275,$\cdots$,271]} の部分は
サーバに対する動作に対応した理解可能なデータの種類を表している。
サーバの動作に対するデータはすべて 32 bit の整数で表しており、
このリストは理解可能なデータに対応する 32 bit 整数のリストとなっている。

最後の {\tt [ [514,[1,2,3,$\cdots$,60]],[2144202544,[0,1]] ]} の部分は
理解可能なデータの形式を表している。
この部分はさらに {\tt [514,[1,2,3,$\cdots$,60]]} と
{\tt [2144202544,[0,1]]} にの部分に分けることができ、
それぞれが一つのデータ形式についての情報となっている。
どのデータ形式についての情報かは最初の要素にある整数値をみれば
分かるようになっている。
この整数値は CMO 形式では 514 となっている。
最初のデータ形式を区別する整数値以後の要素は
各データ形式によってどのように使われるか定まっている。
CMO 形式では理解可能なデータの tag がリストの中に収まっている。
前節で CMO 形式では多倍長整数を表す tag が 20 であることを述べたが、
このリストに 20 が含まれているので、
ox\_asir は CMO 形式の多倍長整数を受け取れることがわかる。

%%このリストの要素はまたリストとなっており、
%この最後の部分もまたリストとなっており、
%あるデータ形式で理解可能なものを表現したリストを要素としている。
%{\tt [514,[1, 2, $\cdots$]]} の最初の 514 はこのリストが CMO 形式
%での理解可能なデータを表していることを示しており、
%その後のリストでは CMO 層で定義されているデータのうち、
%理解可能なデータの tag が並んでいる。

なお、データが受け取れることと、
データの論理構造が理解できることとはまったく別物であるので
注意する必要がある。


\section{セキュリティ対策}

OpenXM では幾らかのセキュリティ対策を考えている。
OpenXM に対応したソフトウェアをクラックしても
大した利点はないと思えるが、それは設計上の話であって、
予期せぬ手段で攻撃を受けた場合にどのような事態を
招くかは想像し難い。

そこで、 OpenXM では侵入者に攻撃の機会を
できるだけ与えないようにしている。
具体的には、接続が必要になった時のみ接続を待つようにし、
常に接続に関与するといったことは避けている。

しかし、これだけでは侵入者が接続を行なう一瞬のすきを
狙ってくる可能性もある。
そこで接続を行なう時に、
接続を待つ port 番号をランダムに決めている。
こうすることで、特定の port 番号を狙って接続を行なう
瞬間を待つ手口を幾らか防ぐことができる。

さらにもう一段安全性を高めるために、
接続時に 1 回だけ使用可能なパスワードを作成し、
そのパスワードを使って認証を行なう。
このパスワードは一旦使用されれば無効にするので、
もし仮になんらかの手段でパスワードが洩れたとしても安全である。

なお、上記の port 番号とパスワードは安全な手段で送られて
いると仮定している。
また、同一のコンピュータ上に悪意のあるユーザはいないと仮定している
ことに注意しなければならない。
なぜなら、現在の実装ではサーバ、およびクライアントの動作している
コンピュータ上ではこの port 番号とパスワードがわかってしまうためである。

なお、接続が確立した後のメッセージの送受信に関しては、
特に暗号化などの処置が行なわれているわけではない。
もし必要があれば、通信路の暗号化を行なう機能がある
ソフトウェアを使うことを考えている。


\section{他のプロジェクト}

他のプロジェクトについても触れておこう。

OpenMath プロジェクトは数学的なオブジェクトを
コンピュータ上で表現する方法を決定している。
各ソフトウェア間でオブジェクトを交換する際の
オブジェクトの変換手順についても述べられている。
表現方法は一つだけでなく、 XML 表現や binary 表現などが
用意されている。
詳細は

http://www.openmath.org/omsoc/index.html A.M.Cohen


以下は書いてる途中。

NetSolve

http://www.cs.utk.edu/netsolve/


MP

http://symbolicNet.mcs.kent.edu/SN/areas/protocols/mp.html


MCP

http://horse.mcs.kent.edu/~pwang/


\section{現在提供されているソフトウェア}

現在 OpenXM 規格に対応しているクライアントには
asir, sm1, Mathematica がある。
これらのクライアントから
OpenXM 規格に対応したサーバを呼び出すことができる。
現在 OpenXM 規約に対応しているサーバソフトウェアには、
 asir, sm1, gnuplot, Mathematica などがあり、
それぞれ ox\_asir, ox\_sm1, ox\_math という名前で提供されている。
また、 OpenMath 規格の XML 表現で表現されたデータと CMO 形式の
データを変換するソフトウェアが JAVA によって実装されており、
OMproxy という名前で提供されている。


\end{document}
