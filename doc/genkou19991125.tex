\documentclass{jarticle}

%% $OpenXM: OpenXM/doc/genkou19991125.tex,v 1.72 1999/12/24 12:03:33 tam Exp $

\usepackage{jssac}
\title{
1. 意味もない修飾過剰な語句は排除しましょう。\\
3. せっかく fill しているのをいじらないでくれ。\\
4. 田村が遊んでばかりでおればかり仕事をしているのはどう考えても不公平だ。
なんで仕事をしないのか、いい加減仕事をしろ、田村。
}

\author{奥 谷 　 行 央\affil{神戸大学大学院自然科学研究科}
		\mail{okutani@math.sci.kobe-u.ac.jp}
  \and	小 原 　 功 任\affil{金沢大学理学部}
		\mail{ohara@kappa.s.kanazawa-u.ac.jp}
  \and	高 山 　 信 毅\affil{神戸大学理学部}
		\mail{takayama@math.sci.kobe-u.ac.jp}
  \and	田 村 　 恭 士\affil{神戸大学大学院自然科学研究科}
		\mail{tamura@math.sci.kobe-u.ac.jp}
  \and	野 呂 　 正 行\affil{富士通研究所}
		\mail{noro@para.flab.fujitsu.co.jp}
  \and	前 川 　 将 秀\affil{神戸大学理学部}
		\mail{maekawa@math.sci.kobe-u.ac.jp}
}
%\art{}

\begin{document}
\maketitle

\section{OpenXMとは}

OpenXM は数学プロセス間でメッセージを交換するための規約である。
数学プロセス間でメッセージをやりとりすることにより、
ある数学プロセスから他の数学プロセスを呼び出して計算を行なったり、
他のマシンで計算を行なわせたりすることが目的である。
なお、 OpenXM とは Open message eXchange protocol for Mathematics の略である。
OpenXM の開発の発端は野呂と高山により、
asir と kan/sm1 を相互に呼び出す機能を実装したことである。

初期の実装では、相手側のローカル言語の文法に従った文字列を送っていた。
この方法では相手側のソフトが asir なのか kan/sm1 なのかを判別するなどして、
相手側のローカル言語の文法に合わせた文字列を作成しなければならない。
このローカル言語の文法に従った文字列を送る方法は、
効率的であるとはいい難いが、使いやすいとも言える。

現在の OpenXM 規約では共通表現形式によるメッセージを用いている。
上記の文字列を送る方法の利点を生かすため、
OpenXM 規約では共通表現形式の中の文字列として、
ローカル言語の文法に従った文字列を用いたメッセージの交換も可能となっている。

OpenXM 規約では通信の方法に幾らかの自由度があるが、
現在のところは TCP/IP を用いた通信しか実装されていない。
そこで、この論文では具体的な実装は TCP/IP を用いていると仮定する。

\section{OpenXM のメッセージの構造}

通信の方法によってメッセージの構造は変わる。
前節で仮定したとおり、この論文では TCP/IP の場合についてのみ説明を行なう。

OpenXM 規約で規定されているメッセージはバイトストリームとなっており、
次のような構造になっている。

\begin{tabular}{|c|c|}
\hline
ヘッダ	& \hspace{10mm} ボディ \hspace{10mm} \\ 
\hline
\end{tabular}

ヘッダの長さは 8 バイトであると定められている。
ボディの長さはメッセージごとに異なっているが、
長さは $0$ でもよい。

ヘッダは次の二つの情報を持っている。
\begin{enumerate}
\item	前半の 4 バイト。メッセージの種類を表わす識別子であり、
	タグと呼ばれる。
\item	後半の 4 バイト。メッセージにつけられた通し番号である。
\end{enumerate}
それぞれの 4 バイトは 32 ビット整数とみなされて扱われる。
この場合に用いられる整数の表現方法については後述するが、
基本的に表現方法はいくつかの選択肢から選ぶことが可能となっており、
またその選択は通信路の確立時に一度だけなされることに注意しなければならない。
現在のOpenXM 規約では、タグ(整数値)として
以下のものが定義されている。

\begin{verbatim}
#define	OX_COMMAND              513
#define	OX_DATA	                514
#define OX_SYNC_BALL            515
#define OX_DATA_WITH_LENGTH     521
#define OX_DATA_OPENMATH_XML    523
#define OX_DATA_OPENMATH_BINARY 524
#define OX_DATA_MP              525
\end{verbatim}

ボディの構造はメッセージの種類によって異なる。
タグが OX\_COMMAND となっているメッセージはスタックマシンへの命令であり、
それ以外のメッセージは何らかのオブジェクトを表している。
この論文では OX\_DATA と OX\_COMMAND で識別される
メッセージについてのみ、説明する。

既存のメッセージでは対応できない場合は、新しい識別子を定義することで新し
い種類のメッセージを作成することができる。この方法は各数学ソフトウェアの
固有の表現を含むメッセージを作成したい場合などに有効である。新しい識別子
の定義方法については、\cite{OpenXM-1999} を参照すること。

\section{OpenXM の計算モデル}

OpenXM 規約での計算とはメッセージを交換することである。また、 OpenXM 規
約ではクライアント・サーバモデルを採用しているので、メッセージの交換はサー
バとクライアントの間で行なわれる。クライアントからサーバへメッセージを送
り、クライアントがサーバからメッセージを受け取ることによって計算の結果が
得られる。このメッセージのやりとりはクライアントの主導で行われる。つまり、
クライアントは自由にメッセージをサーバに送付してもよいが、サーバからは自
発的にメッセージが送付されることはない。この原理はサーバはスタックマシン
であることで実現される。スタックマシンの構造については \ref{sec:oxsm} 節
で述べる。

サーバがクライアントから受け取ったオブジェクト(つまり OX\_COMMAND でない
メッセージのボディ)はすべてスタックに積まれる。スタックマシンへの命令
(OX\_COMMAND で識別されるメッセージのボディ)を受け取ったサーバは命令に対
応する動作を行なう。このとき、命令によってはスタックからオブジェクトを取
り出すことがあり、また(各数学システムでの)計算結果をスタックに積むことが
ある。もし、与えられたデータが正しくないなどの理由でエラーが生じた場合に
はサーバはエラーオブジェクトをスタックに積む。計算結果をクライアントが得
る場合にはスタックマシンの命令 SM\_popCMO または SM\_popString をサーバ
に送らなければならない。これらの命令を受け取ってはじめて、サーバからクラ
イアントへメッセージが送られる。

{\Huge 以下、書き直し}

まとめると、クライアントがサーバへメッセージを送り、
計算の結果を得るという手順を追っていくと次のようになる。

\begin{enumerate}
\item
まず、クライアントがサーバへオブジェクトを送る。サーバは送られてきたオブ
ジェクトをスタックに積む。
\item
クライアントがサーバに命令を送ると、サーバは必要なだけスタックからデータ
を取り出し、実行した結果をスタックに積む。
って書いてるけど、命令がSM\_popCMO とか SM\_shutdown の場合は?
\item
最後に「スタックからデータを取り出し送信を行なう命令」をサーバへ送ると、
サーバはスタックから計算結果の入っているデータを取り出し、クライアントへ
送出する。
\end{enumerate}

\section{OpenXM スタックマシン}\label{sec:oxsm}

OpenXM 規約ではサーバはスタックマシンであると定義している。以下、OpenXM 
スタックマシンと呼ぶ。この節ではOpenXM スタックマシンの構造について説明
しよう。

まず、OpenXM 規約は通信時にやりとりされる共通のデータ形式については規定
するが、OpenXM スタックマシンがスタックに積む、オブジェクトの構造までは
規定しない。つまり、オブジェクトの構造は各数学システムごとに異なっている
ということである。このことは通信路からデータを受け取った際に、各数学シス
テムが固有のデータ構造に変換してからスタックに積むことを意味する。この変
換は1対1対応である必要はない。

次に OpenXM スタックマシンの命令コードについて説明する。OpenXM スタック
マシンにおけるすべての命令は4バイトの長さを持つ。OpenXM 規約の他の規定と
同様に、4バイトのデータは32ビット整数と見なされるので、この論文でもその
表記にしたがう。OpenXM スタックマシンに対する命令はスタックに積まれるこ
とはない。現在のところ、OpenXM 規約では以下の命令が定義されている。

\begin{verbatim}
#define SM_popSerializedLocalObject               258
#define SM_popCMO                                 262
#define SM_popString                              263

#define SM_mathcap                                264
#define SM_pops                                   265
#define SM_setName                                266
#define SM_evalName                               267
#define SM_executeStringByLocalParser             268 
#define SM_executeFunction                        269
#define SM_beginBlock                             270
#define SM_endBlock                               271
#define SM_shutdown                               272
#define SM_setMathCap                             273
#define SM_executeStringByLocalParserInBatchMode  274
#define SM_getsp                                  275
#define SM_dupErrors                              276

#define SM_DUMMY_sendcmo                          280
#define SM_sync_ball                              281

#define SM_control_kill                          1024
#define SM_control_to_debug_mode                 1025
#define SM_control_exit_debug_mode               1026
#define SM_control_ping                          1027
#define SM_control_start_watch_thread            1028
#define SM_control_stop_watch_thread             1029
#define SM_control_reset_connection              1030
\end{verbatim}

以下、どういうときに結果をスタックに積むかエラーの場合どうするかの説明が
必要であろう。


\section{CMO のデータ構造}\label{sec:cmo}

OpenXM 規約では、数学的オブジェクトを表現する方法として CMO 形式(Common
Mathematical Object format)を定義している。この CMO 形式にしたがったデー
タは、識別子が OX\_DATA であるようなメッセージのボディになることを想定し
ている。

CMO 形式におけるデータ構造は次のような構造をもつ。

\begin{tabular}{|c|c|} \hline
ヘッダ        & \hspace{10mm} ボディ \hspace{10mm} \\ \hline
\end{tabular}

ヘッダは4バイトである。ボディの長さはそれぞれのデータによって異なるが、
0でもよい。

メッセージと同様にヘッダは4バイト単位に管理される。すなわち、CMO ではヘッ
ダは一つだけの情報を含む。この4バイトのヘッダのことをタグともいう。さて、
CMO では、タグによってボディの論理的構造が決定する。すなわち、タグはそれ
ぞれのデータ構造と1対1に対応する識別子である。それぞれの論理的構造は 
\cite{OpenXM-1999} に詳述されている。現在の OpenXM 規約では以下の CMO が
定義されている。

\begin{verbatim}
#define CMO_ERROR2 0x7f000002
#define CMO_NULL   1
#define CMO_INT32  2
#define CMO_DATUM  3
#define CMO_STRING 4
#define CMO_MATHCAP 5

#define CMO_START_SIGNATURE    0x7fabcd03     
#define     CMO_ARRAY  16
#define     CMO_LIST 17
#define     CMO_ATOM 18
#define     CMO_MONOMIAL32  19
#define     CMO_ZZ          20
#define     CMO_QQ          21
#define     CMO_ZERO        22
#define     CMO_DMS_GENERIC     24
#define     CMO_DMS_OF_N_VARIABLES 25
#define     CMO_RING_BY_NAME  26
#define     CMO_RECURSIVE_POLYNOMIAL 27
#define     CMO_LIST_R   28

#define     CMO_INT32COEFF  30
#define     CMO_DISTRIBUTED_POLYNOMIAL 31
#define     CMO_POLYNOMIAL_IN_ONE_VARIABLE 33
#define     CMO_RATIONAL 34

#define     CMO_64BIT_MACHINE_DOUBLE   40
#define     CMO_ARRAY_OF_64BIT_MACHINE_DOUBLE  41
#define     CMO_128BIT_MACHINE_DOUBLE   42
#define     CMO_ARRAY_OF_128BIT_MACHINE_DOUBLE  43

#define     CMO_BIGFLOAT    50
#define     CMO_IEEE_DOUBLE_FLOAT 51

#define     CMO_INDETERMINATE  60
#define     CMO_TREE           61
#define     CMO_LAMBDA         62
\end{verbatim}

この中で CMO\_INT32, ... で識別されるオブジェクトは最も基本的なオブジェ
クトであって、すべての OpenXM 対応システムに実装されていなければならない。

これらについての解説を行う前に記法について、少し説明しておく。
この論文では、大文字で CMO\_INT32 と書いた場合には、上記で定義した識別子
を表わす。また CMO\_INT32 で識別されるオブジェクトのクラス(あるいはデー
タ構造)を cmo\_int32 と小文字で表わすことにする。

さて cmo を表現するための一つの記法を導入する。この記法は CMO expression
と呼ばれている。その正確な形式的定義は \cite{OpenXM-1999} を参照すること。

まず CMO expssion は Lisp 風表現の一種で、 cmo を括弧で囲んだリストとし
て表現する。それぞれの要素はカンマで区切る。
例えば、
\begin{quote}
(17, {\sl int32}, (CMO\_NULL), (2, {\sl int32} $n$))
\end{quote}
は CMO expression である。ここで、小文字の斜体で表された``{\sl int32}'' 
は 4バイトの任意のデータを表す記号であり、``{\sl int32} $n$'' は同じく 4
バイトのデータであるが以下の説明で $n$ と表すことを示す。また数字 17, 2 
などは 4バイトのデータで整数値としてみたときの値を意味する。CMO\_NULL は
識別子(すなわち数字 1 と等価)である。この記法から上記のデータは 20 バイ
トの大きさのデータであることが分かる。

さて、この記法のもとで cmo\_int32 を次のデータ構造を持つと定義する。
\begin{quote}
cmo\_int32 := (CMO\_INT32,  {\sl int32})
\end{quote}

{\Huge 同様に cmo\_string, cmo\_list などを定義!!}

% ここで 32 bit の整数の表現方法について触れておく。
% OpenXM 規約ではバイトストリームで 32 bit の整数 20 を
% {\tt 00 00 00 14} と表す方法と {\tt 14 00 00 00} と表す方法がある。
% この表現方法の違いはクライアントとサーバの最初の接続時に
% 双方の合意で決定することになっている。
% なお、合意がない場合には前者の表現方法
% (以後、この表現方法をネットワークバイトオーダーと呼ぶ)を
% 使うことになっている。
% また、負の数を表現する必要があるときには、
% 2 の補数表現を使うことになっている。

% 先ほどの、 (CMO\_INT32, 123456789) をネットワークバイトオーダーで
% バイト列に直すと、
% \begin{center}
% 	{\tt 00 00 00 02 07 5b cd 15}
% \end{center}
% となり、
% (CMO\_STRING, 6, ``OpenXM'') は
% \begin{center}
% 	{\tt 00 00 00 04 00 00 00 06 4f 70 65 6e 58 4d}
% \end{center}
% となる。

% CMO 形式の多倍長整数は、 Gnu MPライブラリ等を参考にしており、
% 符号付き絶対値表現を用いている。
% タグ以降の形式は次のようになる。

% \begin{tabular}{|c|c|c|c|c|} \hline
% $f$ & $b_0$ & $b_1$ & $\cdots$ & $b_{n-1}$ \\ \hline
% \end{tabular}

% ここで、 1 つの枠は 4 バイトを表し、
% $f$ は符号付き 32 ビット整数を、
% $b_0$, $b_1$, $\cdots$, $b_{n-1}$ は符号なし 32 ビット整数を表している。
% さらに、 $|f| = n$ が成り立たなければならない。
% このオブジェクトは
% \[ \mbox{sgn}(f) \times \{ b_0 (2^{32})^0 + b_1 (2^{32})^1 + \cdots
% 	+ b_{n-1} (2^{32})^{n-1} \}	\]
% という整数であると定義されている。
% ただし、
% \[ \mbox{sgn}(f) = \left\{ \begin{array}{ll}
%         1       & f>0 \\
%         0       & f=0 \\
%         -1      & f<0 \\ \end{array} \right.	\]
% である。

% ここで具体例をだそう。
% $4294967298 = 1 \times 2^{32} + 2$ を CMO 形式の
% ネットワークバイトオーダー、多倍長整数で表現すると、
% \begin{center}
% 	{\tt 00 00 00 14 00 00 00 02 00 00 00 02 00 00 00 01}
% \end{center}
% となる。また、同じ表現方法で $-1$ を表現すると、
% \begin{center}
% 	{\tt 00 00 00 14 ff ff ff ff 00 00 00 01}
% \end{center}
% となる。


\section{mathcap について}

OpenXM 規約では、通信時に用いられるメッセージの種類を各ソフトウェアが制
限する方法を用意している。これは各ソフトウェアの実装によってはすべてのメッ
セージをサポートするのが困難な場合があるからである。また、各ソフトウェア
でメッセージの種類を拡張したい場合にも有効である。この制限(あるいは拡張) 
は mathcap と呼ばれるデータ構造によって行われる。この節では mathcap のデー
タ構造と、具体的なメッセージの制限の手続きについて説明する。

では、手続きについて説明しよう。

第一にサーバの機能を制限するには次のようにする。クライアントが mathcap 
オブジェクトをサーバへ送ると、サーバは受け取ったmathcap をスタックに積む。
次にクライアントが命令 SM\_setMathCap を送ると、サーバはスタックの最上位
に積まれている mathcap オブジェクトを取り出し、mathcap で設定されていな
いメッセージをクライアントへ送らないように制限を行う。

第二にクライアントを制限するには次のようにする。クライアントがサーバに命
令 SM\_mathcap を送ると、サーバは mathcap オブジェクトをスタックに積む。
さらに命令 SM\_popCMO を送ると、サーバはスタックの最上位のオブジェクト
(すなわち mathcap オブジェクト)をボディとするメッセージをクライアントに
送付する。クライアントはそのオブジェクトを解析して、制限をかける。

次に mathcap のデータ構造について説明する。
mathcap は CMO の一種であるので、すでに説明したように
\begin{verbatim}
ヘッダ     ボディ
\end{verbatim}
の構造を持ちヘッダの値は 5 である(\ref{sec:cmo} 節を参照のこと)。
ボディは cmo\_list オブジェクトでなければならない。

さて、mathcap オブジェクトのボディの cmo\_list オブジェクトは以下の条件を
満たすことを要求される。

まず、その cmo\_list オブジェクトは少なくともリスト長が 3 以上でなければ
ならない。

\[	\begin{tabular}{|c|c|c|} \hline
	$A$ & $B$ & $C$	\\ \hline
	\end{tabular}	\]

第一要素 $A$ はまた cmo\_list であり、リスト長は 4 以上、
$a_1$ は 32 ビット整数でバージョンナンバーを、
$a_2$ は文字列でシステムの名前を表すことになっている。

\[	\begin{tabular}{|c|c|} \hline
	$a_1$ & $a_2$	\\ \hline
	\end{tabular}	\]

2 番目の要素 $B$ の部分は次のようなリスト構造をしている。
この $b_1$, $b_2$, $\cdots$, $b_n$ はすべて 32 ビットの整数である。
スタックマシンへの命令はすべて 32 ビットの整数で表しており、
各 $b_i$ は利用可能な命令に対応する 32 ビットの整数となっている。

\[	\begin{tabular}{|c|c|c|c|} \hline
	$b_1$ & $b_2$ & $\cdots$ & $b_n$	\\ \hline
	\end{tabular}	\]

3 番目の要素 $C$ は以下のようなリスト構造をしている。
\[  \overbrace{
	\begin{tabular}{|c|c|c|c|} \hline
	$c_1$ & $c_2$ & $\cdots$ & $c_n$	\\ \hline
	\end{tabular}
   }^{C}	\]
%$n$ は OX\_COMMAND 以外の受け取れるメッセージのタグの種類の数に等しい。
%要素数は 1 でももちろん構わない。
各 $c_i$ もまた以下のようなリスト構造となっており、
どの $c_i$ も最初の要素が 32 ビットの整数となっている。
\[  \overbrace{
	\begin{tabular}{|c|c|c|c|c|} \hline
	$c_{i1}$ (32 ビットの整数) & $c_{i2}$ & $c_{i3}$ &
		$\cdots$ & $c_{im}$	\\ \hline
	\end{tabular}
   }^{c_i}	\]
このリストの最初の整数値は受け取れるメッセージのタグが入っている。
$c_{i2}$ 以降については最初の $c_{i1}$ の値によってそれぞれ異なる。
ここでは、最初の要素が OX\_DATA の場合についてのみ説明する。
この $c_{i1}$ が OX\_DATA の場合、
リスト $c_i$ は CMO 形式についての情報を表しており、
$m=2$ と決められている。
$c_{i1}$ にはもちろんのこと OX\_DATA が入っており、
$c_{i2}$ は以下の図のようなリスト構造になっている。
各要素は 32 ビットの整数であり、
受け取ることが可能な CMO 形式のタグが入る。
\[  \overbrace{
	\begin{tabular}{|c|c|c|c|c|} \hline
	$c_{i21}$ & $c_{i22}$ & $\cdots$ & $c_{i2l}$	\\ \hline
	\end{tabular}
   }^{c_{i2}}	\]

%なお、 mathcap データの中では CMO 形式で定義されている
%32 bit 整数、文字列、リスト構造が使われており、
%mathcap データに含まれている内容を理解できるためには
%必然的にこれらも理解できる必要がある
%(ってことは CMO 形式のところでこれらを
%説明しなければならないってことです)。

具体的な mathcap の例をあげよう。
%なお、 $a_1$, $a_2$, $\cdots$, $a_n$ を要素に
%持つリスト構造を {\tt [$a_1$, $a_2$, $\cdots$, $a_n$]} 、
%文字列 ``string'' を {\tt "string"} 、 32 bit 整数を
%それに対応する 10 進数の整数で示す。
名前が ``ox\_test''、バージョンナンバーが 199911250 のサーバであれば、
$A$ の部分は
\begin{tabular}{|c|c|} \hline
199911250 & "ox\_test" \\ \hline
\end{tabular}
となる。
さらに、このサーバのスタックマシンが
命令コード 2, 3, 5, 7, 11 番を利用可能
(実際にはこのような命令コードは存在しない)であれば、 $B$ の部分は
\begin{tabular}{|c|c|c|c|c|} \hline
2 & 3 & 5 & 7 & 11 \\ \hline
\end{tabular}
となり、
CMO 形式の 32 ビット整数、文字列、 mathcap 、リスト構造のみが
受け取れるときには、 $C$ の部分は
\begin{tabular}{|c|} \hline
	\\[-5mm]
	\begin{tabular}{|c|c|} \hline
		& \\[-5mm]
		OX\_DATA &
		\begin{tabular}{|c|c|c|c|} \hline
		CMO\_INT32 & CMO\_STRING & CMO\_MATHCAP & CMO\_LIST \\ \hline
		\end{tabular} \\[0.8mm] \hline
	\end{tabular} \\[1.4mm] \hline
\end{tabular} \\
となる。
CMO\_ZZ がないので、このサーバは多倍長整数が送られてこないことを期待して
いる。

なお、データが受け取れることと、データの論理構造が理解できることとはまっ
たく別物であるので注意する必要がある。

{\Huge ってなんででしょうか? データの論理構造を知らないと受け取れないと
思うんですが$\ldots$}


\section{セキュリティ対策}

OpenXM 規約は TCP/IP を用いて通信を行うことを考慮している。ネットワーク
によって接続される現代の多くのソフトウェアと同様、OpenXM 規約もまた通信
時のセキュリティについて注意している。以下、このことについて説明しよう。

{\large\bf 意味不明なことを書いているが、}

侵入者に攻撃の機会をできるだけ与えないようするた
めに、接続が必要になった時のみ接続を待つようにし、
常に接続に関与するといったことは避けている(やっぱり意味不明である)。

また、侵入者が接続を行なう一瞬のすきを狙ってくる可能性もあるので、
接続を行なう時に接続を待つポート番号をランダムに決めている(誰が決めてい
るのかはやっぱり不明であるが)。
さらにもう一段安全性を高めるために、
接続時に 1 回だけ使用可能なパスワードを作成し、
そのパスワードを使って認証を行なう(誰がパスワードを決めて誰が認証を行っ
ているのかが不明だけど)。
このパスワードは一旦使用されれば無効にするので、
もし仮になんらかの手段でパスワードが洩れたとしても安全だと考えている。

なお、接続が確立した後のメッセージの送受信に関しては、
特に暗号化などの処置を行っているわけではない。
もし必要があれば、通信路の暗号化を行なう機能がある
ソフトウェア ssh を使うことを考えている。

\section{他のプロジェクト}

他のプロジェクトについても触れておこう。

\begin{itemize}
\item OpenMath\\
OpenMath プロジェクトは数学的なオブジェクトをコンピュータ上で表現する方
法を規定している。各ソフトウェア間でオブジェクトを交換する際のオブジェク
トの変換手順につても定められている。表現方法は幾つかの段階で定められて
いて、XML 表現やバイナリ表現などが用意されている。詳細は

http://www.openmath.org/omsoc/   A.M.Cohen

\item NetSolve

http://www.cs.utk.edu/netsolve/

\item MP

http://symbolicNet.mcs.kent.edu/SN/areas/protocols/mp.html

\item MCP

http://horse.mcs.kent.edu/~pwang/
\end{itemize}


\section{現在提供されているソフトウェア}

現在 OpenXM 規約に対応しているクライアントにはasir, sm1, Mathematica が
ある。これらのクライアントから OpenXM 規約に対応したサーバを呼び出すこと
ができる。現在 OpenXM 規約に対応しているサーバソフトウェアには、asir,
sm1, gnuplot, Mathematica などがあり、それぞれ ox\_asir, ox\_sm1,
ox\_sm1\_gnuplot, ox\_math という名前で提供されている。また、 OpenMath 
規約の XML 表現で表現されたオブジェクトと CMO 形式のオブジェクトを変換す
るソフトウェアが JAVA によって実装されており、OMproxy という名前で提供さ
れている。

\begin{thebibliography}{99}
\bibitem{Ohara-Takayama-Noro-1999}
小原功任, 高山信毅, 野呂正行:
{Open asir 入門}, 1999, 数式処理, Vol 7, No 2, 2--17. (ISBN4-87243-086-7, SEG 出版, Tokyo).
\bibitem{OpenXM-1999}
野呂正行, 高山信毅:
{Open XM の設計と実装 --- Open message eXchange protocol for Mathematics},
1999/11/22
\end{thebibliography}

\end{document}
