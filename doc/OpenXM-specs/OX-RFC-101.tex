%#!make OX-RFC-101-ja.dvi
% $OpenXM: OpenXM/doc/OpenXM-specs/OX-RFC-101.tex,v 1.2 2000/11/30 08:46:23 ohara Exp $
\documentclass{article}
%%\IfFileExists{epsfig.sty}{\usepackage{epsfig}}{}
\usepackage{html}
/*&jp
\title{{\bf エンジン起動プロトコル, OpenXM RFC 101 Draft}}
\author{ 小原功任\thanks{{金沢大学理学部計算科学教室, \htmladdnormallink{http://omega.s.kanazawa-u.ac.jp/ohara/}{http://omega.s.kanazawa-u.ac.jp/ohara/}}}}
\date{ 2000年, 11月30日}
*/
/*&eg
\title{{\bf Protocol to Start Engines, OpenXM RFC 101 Draft}}
\author{ Katsuyoshi Ohara\thanks{Department of Computational Science, Kanazawa University, \htmladdnormallink{http://www.s.kanazawa.ac.jp}{http://www.s.kanazawa.ac.jp}}}
\date{ November 30, 2000 }
*/

\begin{document}
\maketitle
\section{Session Management}

/*&jp
この文書では ``OpenXM RFC 100, OpenXM の設計と実装''\ 
\htmladdnormallink{http://www.math.kobe-u.ac.jp/OpenXM/OpenXM-RFC.html}{http://www.math.kobe-u.ac.jp/OpenXM/OpenXM-RFC.html}
で定義されたコントロールサーバを置き換える新しいコントロールサーバの
仕様を説明する.
*/

/*&eg
This document describes a new control server specification
which is intended to be
a replacement of the control server defined in 
``Design and implementation of OpenXM, OpenXM RFC 100''\ 
\htmladdnormallink{http://www.math.kobe-u.ac.jp/OpenXM/OpenXM-RFC.html}{http://www.math.kobe-u.ac.jp/OpenXM/OpenXM-RFC.html}.
*/

\subsection{New OpenXM control servers}

/*&jp

我々は新しいコントロールサーバを提案する。そのサンプル実装として oxc が
提供される。新しいコントロールサーバは以下の点で従来のものと異なる。
\begin{enumerate}
\item コントロールサーバは OpenXM スタックマシンであり、
CMObject/Primitive をサポートする。
\item 計算サーバの起動はスタックマシンコマンドを介して行う。
\item 一つのコントロールサーバから複数の計算サーバを起動できる。
\end{enumerate}

oxc の導入により、いままでのサーバの起動手順はコントロールサーバの起動と
計算サーバの起動に分離される。コントロールサーバを起動するには次の手順を
取る。まず、適当なオプション(後述)をつけて、コントロールサーバを起動する
と、コントロールサーバはソケットを作成し、connect する。クライアントは、
listen, accept する。接続後、最初にバイトオーダを決定する。バイトオーダ
の決定方法については、従来のものと変更はない
(OpenXM/doc/OpenXM-specs/control.tex を見よ)。その後、コントロールサーバ
は待機状態にはいる。コントロールサーバは OpenXM スタックマシンであるから、
mathcap の交換などの手続きに入ってもよい。

\subsection{OpenXM control stack machine}

コントロールサーバは、次のスタックマシンコマンドを実装しなければならない。
それぞれのスタックコマンドの意味は、{\bf 以前のコントロールサーバとは異なる。}

\begin{enumerate}
\item
\begin{verbatim}
SM_control_spawn_server
\end{verbatim}
新たに計算サーバを起動する。計算サーバの起動に成功すると、その ID を返す。

Request:
\begin{tabular}{|c|c|}  \hline
{\tt int32 OX\_COMMAND} & {\tt int32 SM\_control\_spawn\_server}  \\
\hline
\end{tabular}

Stack before the request: 
\begin{tabular}{|c|c|}  \hline
{\sl Integer32} Port & {\sl String} ServerName \\
\hline
\end{tabular}

Stack after the request: 
\begin{tabular}{|c|c|}  \hline
{\sl Integer32} ServerID \\
\hline
\end{tabular}

Output: none.

\item
\begin{verbatim}
SM_control_terminate_server
\end{verbatim}
指定された計算サーバに SIGKILL を送る。

Request:
\begin{tabular}{|c|c|}  \hline
{\tt int32 OX\_COMMAND} & {\tt int32 SM\_control\_terminate\_server}  \\
\hline
\end{tabular}

Stack before the request:
\begin{tabular}{|c|c|}  \hline
{\sl Integer32} ServerID \\
\hline
\end{tabular}

Output: none.

\item
\begin{verbatim}
SM_control_kill
\end{verbatim}
全ての計算サーバに SIGKILL を送る。

Request:
\begin{tabular}{|c|c|}  \hline
{\tt int32 OX\_COMMAND} & {\tt int32 SM\_control\_kill}  \\
\hline
\end{tabular}

Output: none.

\item
\begin{verbatim}
SM_control_reset_connection_server
\end{verbatim}
指定された計算サーバに SIGUSR1 を送る。

Request:
\begin{tabular}{|c|c|}  \hline
{\tt int32 OX\_COMMAND} & {\tt int32 SM\_control\_reset\_connection\_server}  \\
\hline
\end{tabular}

Stack before the request:
\begin{tabular}{|c|c|}  \hline
{\sl Integer32} ServerID \\
\hline
\end{tabular}

Output: none.

\item
\begin{verbatim}
SM_control_reset_connection
\end{verbatim}
全ての計算サーバに SIGUSR1 を送る。これは下位互換性のための措置である。

Request:
\begin{tabular}{|c|c|}  \hline
{\tt int32 OX\_COMMAND} & {\tt int32 SM\_control\_reset\_connection}  \\
\hline
\end{tabular}

Output: none.

\end{enumerate}

\bigskip
\bigskip

\subsection{A sample implementation}

\subsubsection{Command Line Arguments}
コントロールサーバの実行形式は getopt(3) に ``c:p:h:x'' で指定するオプショ
ンを持つ。すなわち、
\begin{verbatim}
oxc -c [password] -h [hostname] -p [portnumber] -x
\end{verbatim}

{\tt -h} では、クライアントのホスト名を指定する。クライアントはあらかじめ、
hostname:port を開いて待ち受けなければならない。

{\tt -x} オプションはなくてもよい。-x を指定し、かつ環境変数 DISPLAY が
設定されていると、oxc は新たに端末(ウィンドウ)を作成して、メッセージをそ
の端末に出力する。oxc の用いる端末の種類は環境変数OpenXM\_XTERM で指定す
る。デフォルトは xterm である。

\subsubsection{Local Functions}

コントロールサーバの各実装は、独自にローカル関数をサポートしてもよい。
実際、サンプル実装 oxc はローカル関数をサポートしている。

ここでは、oxc のローカル関数 spawn について説明しよう。

spawn は計算サーバを起動し、少なくとも 2 個の引数を持つ。すなわち、
\begin{verbatim}
spawn(計算サーバ名, ポート番号, モード, ...)
\end{verbatim}
という形式である。「モード」はなくてもよい。ここで、「計算サーバ名」は 
CMO\_STRING 型のオブジェクト、「ポート番号」、「モード」は CMO\_INT32型
のオブジェクトである。ローカル関数の実行は SM\_executeFunction による。
すなわち各引数を順にスタックに積み、最後にSM\_executeFunction を実行する。
SM\_executeStringByLocalParser は利用できないので注意する。

spawn は、計算サーバの起動に成功したら (CMO\_INT32, サーバID) を、失
敗したらエラーオブジェクトをスタックに積む。例えば計算サーバが発見できな
かった場合にはエラーオブジェクトを積むことになる。コントロールサーバは 
access(2) を用いて PATH から計算サーバを探す。もし見つからなければ、fork 
をせずに、エラーオブジェクトをスタックに積む。

*/

/*&eg

This document has not yet been translated into English from Japanese.

*/

\end{document}
