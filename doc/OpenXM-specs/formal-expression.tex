%% $OpenXM$
//&jp \section{ CMO の形式的表現方法 }
//&eg \section{ A formal expression of CMO }

/*&jp
前の節で CMO の表現方法を形式的に定義せず, 
CMO のBasic0 の表現法を説明したが,
ここでは, CMO の Lisp 風表現 (Lisp-like expression)
である
CMOexpression
および前節で説明した CMO の標準 encoding 法をもう一度説明する.
% (タグの省略記法がほしい.)
*/
/*&eg
In the previous setion, we have explained the format of CMO's in the
Basic0 group.
In this section, we will introduce CMOexpression which is like the 
bracket expression of Lisp. 
We again explain a standard encoding method of CMO,
which we have already explained in the previous section.
*/

/*&jp

まず, CMOexpression を形式的に 拡張 BNF 記法を用いて定義しよう.
タイプライタフォントでかかれた記号は終端記号を意味する.
``:'' は定義を意味する. ``$|$'' は''または''を意味する.
\{ X \} は X の 0 回以上の繰り返しを表す.
[ x ] は X が 0 回または 1 回出現することを表す.
この記法を用いると CMOexpression は次のように定義できる.

*/
/*&eg

Let us define CMOexpression by the extended BNF expression.
Symbols in the type writer fonts mean terminals.
``:'' means a definition.
``$|$'' means ''or''.
\{ X \} is a repetition of X of more than or equal to 0 times.
[ x ] stands for X or nothing.
By using this notation, CMOexpression is defined as follows.

*/

/*&C
\begin{eqnarray*}
\mbox{CMOexpression}  
&:& \quad
\mbox{\tt (} \mbox{\tt cmo\_tag} \ 
\{ \mbox{ expression} \} \mbox{\tt )}\\
\mbox{expression}
&:& \quad  \mbox{CMOexpression} \\
&   &|\   \mbox{\tt int32}  \\
&   &|\   \mbox{\tt string} \\
&   &|\   \mbox{\tt byte} \\
\end{eqnarray*}
*/
/*&jp
終端記号 {\tt int32} は, 32 bit integer を表す, 10 進または 16 進の数字の
列である.
終端記号 {\tt string} は''文字''の列である.
終端記号 {\tt byte} は 8 bit データを表す, 10 進または 16 進の数字の列である.

*/
/*&jp
Terminal {\tt int32} is signed 32 bit integer. 
Terminal {\tt string} is a byte array which usually expresses a string.
Terminal {\tt byte} is 8 bit data.

*/

/*&jp
CMOexpression にあらわれる各要素を区切るために {\tt ,} (コンマ) を用いてもよい.
{\tt cmo\_tag} は {\tt CMO\_} で始まる定数である.
CMOexpression で表現される object を CMObject と呼ぶ.

*/
/*&eg
The comma ({\tt ,}) may be used to separate each element in CMOexpressions.
{\tt cmo\_tag} is a constant that starts with {\tt CMO\_}.

*/

/*&jp
この表記法 CMOexpression を利用して, CMO Basic0 の object を記述
してみよう.
Object 自体の構造を説明するため,
BNF をもうすこし拡張して, 非終端記号, 終端記号名のみならず, 変数の
名前も書くことにする. こうすることにより, object の意味の説明も容易になる
からである. また ``---'' でコメントのはじまりを表すものとする. 
*/
/*&eg
Let us describe CMO's in the Basic0 group.
In order to explain the meaning of objects,
we may also put variable names to CMOexpressions.
The start of comments are denoted by ``---''.
*/
/*&jp
たとえば, (CMObject の) 32 bit integer である integer32 を
BNFで定義すれば,
\begin{center}
Integer32 \  : \ ({\tt CMO\_INT32}, {\tt int32})
\end{center}
と書くのが本来の書き方による記法であるが, ここでは,
\begin{eqnarray*}
\mbox{Integer32} \  &:& \ ({\tt CMO\_INT32}, {\sl int32}\  n) \\
& & \  \mbox{--- 32 bit integer $n$ を表す. } \\
\end{eqnarray*}
と書くことを許すことにする.
このように書くことにより, 非終端記号  Integer32 は,
\begin{center}
Integer32 \  : \ ({\tt CMO\_INT32}, {\tt int32})
\end{center}
のように, 終端記号 {\tt CMO\_INT32} と {\tt int32} を成分にもち,
CMObject の 
({\tt CMO\_INT32}, {\sl int32}\ n)
は, 
32 bit integer $n$ を表現しているんだということが, 1 行でわかる.
*/
/*&eg
(This part has not yet been translated.)
*/
/*&jp
この記法を用いて, 前節で導入した, Basic0 の CMObject を
形式的に定義しよう.
*/
/*&eg
By using this notation, let us define formally CMObjects in the group
Basic0.
*/

/*&C

\bigbreak
\noindent
Group CMObject/Basic0  requires nothing. \\
Error2, Null, Integer32, Datum, Cstring, Mathcap, List $\in$ CMObject/Basic0. \\
Document of CMObject/Basic0 is at {\tt http://www.math.kobe-u.ac.jp/OpenXM}
(in English and Japanese) \\
\begin{eqnarray*}
\mbox{Error2}&:& ({\tt CMO\_ERROR2}, {\sl CMObject}\, \mbox{ob}) \\
\mbox{Null}  &:& ({\tt CMO\_NULL}) \\
\mbox{Integer32}
&:& ({\tt CMO\_INT32}, {\sl int32}\ \mbox{n}) \\
\mbox{Datum} &:& ({\tt CMO\_DATUM}, {\sl int32}\, \mbox{n}, {\sl byte}\, 
\mbox{data[0]}, 
\ldots , {\sl byte}\, \mbox{data[n-1]}) \\
\mbox{Cstring}&:& ({\tt CMO\_STRING},{\sl int32}\,  \mbox{ n}, 
{\sl string}\, \mbox{s}) \\
\mbox{Mathcap}&:& ({\tt CMO\_MATHCAP},{\sl CMObject}\,  \mbox{ob} ) \\
\mbox{List} &:& 
\mbox{({\tt CMO\_LIST}, {\sl int32}\, m, {\sl CMObject}\, ob[0], $\ldots$,
{\sl CMObject}\, ob[m-1])} \\
& & \mbox{---  m is the length of the list.} 
\end{eqnarray*}

*/


//&jp Cstring で, {\sl string} s の部分を {\tt byte} に分解すれば,
//&eg In the definition of ``Cstring'', if we decompose  ``{\sl string} s'' into bytes, then  ``Cstring'' should be defined as
/*&C
\begin{eqnarray*}
\mbox{Cstring}&:& ({\tt CMO\_STRING},{\sl int32}\,  \mbox{ n}, 
{\sl byte}\, \mbox{s[0]},
\ldots, {\sl byte}\ \mbox{s[n-1]})
\end{eqnarray*}
*/
//&jp となる.
/*&jp
また, 
``Group CMObject/Basic0  requires nothing''
は, 以下は, グループ CMObject/Basic0 の定義であり,
このグループの CMObject を定義するのに, 要請される CMObject のグループは
ないことを示す.
``Error2, Null, Integer32, Datum, Cstring, Mathcap, List
$\in$ CMObject/Basic0''
は, グループ CMObject/Basic0 には,  Error2, Null, Integer32,
Datum, Cstring なるクラスの object が属することを示す.
*/
/*&eg
また, 
``Group CMObject/Basic0  requires nothing''
means that there is no super group to define CMO's in the group Basic0.
``Error2, Null, Integer32, Datum, Cstring, Mathcap, List
$\in$ CMObject/Basic0''
means that
Error2, Null, Integer32, Datum, Cstring
are members of the group CMObject/Basic0.
*/

/*&C

*/

/*&jp 
では, 実際のデータの表現の例をみてみよう.
たとえば, 32 bit integer の 1234 は,
*/
/*&eg
Let us see examples.
32 bit integer 1234 is expressed as
*/
/*&C
\begin{center}
({\tt CMO\_INT32}, 1234)
\end{center}
*/
/*&jp
とかく.
文字列 ``Hello''  は
*/
/*&eg
The string ``Hello'' is expressed as
*/
/*&C
\begin{center}
({\tt CMO\_STRING}, 5, "Hello")
\end{center}
*/
//&jp と書く.

/*&C

*/
/*&jp
CMOexpression と, CMObject の区別を理解しておくのは重要である.
たとえば
\begin{center}
({\tt CMO\_INT32}, 234, "abc",({\tt CMO\_STRING}))
\end{center}
は CMOexpression ではあるが, CMObject ではない.
これは, 文法的には正しいプログラムだが, なにをやるのかは全く不明な
プログラムと似ている.

さて, Open math 風 (\cite{openmath}) 
の SGML 表現法も可能であり, その場合は, 上の二つの例は次のように
書く.
\begin{verbatim}
<CMO_INT32>
1234
</CMO_INT32>

<CMO_STRING>
5
"Hello"
</CMO_STRING>
\end{verbatim}
*/

/*&C

*/

/*&jp
次に, 標準 encoding 法を説明しよう.
標準 encoding 法では, cmo\_tag を ネットワークバイトオーダーの
32 bit integer {\tt int32} に,
その他のフィールドは, 定義に記述されているデータ型に従い,
byte データ {\tt byte} かまたは 
ネットワークバイトオーダーの 32 bit integer {\tt int32} に, 変換する.
*/
/*&eg
Let us explain the standard encoding method.
All {\tt int32} data are encoded into network byte order 32 bit integers
and byte data are encoded as it is.
*/

/*&C

*/

/*&jp
高速の通信方法を用いて
効率を重視する接続の場合には, {\tt int32} を network byte order
に変換する操作がおおきなオーバヘッドとなることが
報告されている.
100Mbps の通信路で 12Mbytes の {\tt CMO\_ZZ} の転送では 
約 90\% の時間が network byte order への変換についやされているという
実験データもある.
効率を重視した encoding 法については後述する.
*/
/*&eg
When we are using a high speed network,
the translation from the internal expression of 32 bit integers to
network byte order may become a bottle neck.
There are experimental data which presents that 90 percents of the transmission
time are
for the translation to the network byte order to send {\tt CMO\_ZZ} of size
12M bytes on a 100Mbps network.
In a later section, we will discuss a protocol to avoid the translation.
*/

/*&C

*/

/*&jp
標準 encoding と CMOexpression の間の変換は容易である.
前節で用いたデータの表記法,
たとえば, 
*/
/*&eg
The translation between the standard encoding and CMOexpression
is easy.
For example,
*/
/*&C
\begin{center}
\begin{tabular}{|c|c|}
\hline
{\tt int32 CMO\_INT32}& {\tt int32 1234}  \\ 
\hline
\end{tabular} 
\end{center}
*/
/*&jp
は, CMOexpression 
*/
/*&eg
is the encoding of the CMOexpression
*/
/*&C
\begin{center}
({\tt CMO\_INT32}, 1234)
\end{center}
*/
/*&jp
の 標準 encoding 法による表現である.
*/


