% $OpenXM: OpenXM/doc/issac2000/openxm-stackmachines.tex,v 1.8 2000/01/15 03:46:27 noro Exp $

\section{OpenXM Stack machines}\label{sec:ox-stackmachines}

In OpenXM specification, all servers are stack machines.
%These are called OpenXM stack machines.
When a server ox\_xyz gets an OX data message,
it translates the data into a local object of ox\_xyz
and pushes the object onto the stack.
According to the OpenMath specification, 
the translation scheme together with definitions of mathematical operations
of the system ox\_xyz is called the {\it PhraseBook} of ox\_xyz.

Any OX command message starts with the int32 tag OX\_COMMAND.
The body is an OpenXM stack machine operation code expressed by int32.
The codes are listed below.
\begin{verbatim}
#define SM_popSerializedLocalObject               258
#define SM_popCMO                                 262
#define SM_popString                              263
#define SM_mathcap                                264
#define SM_pops                                   265
#define SM_setName                                266
#define SM_evalName                               267
#define SM_executeStringByLocalParser             268
#define SM_executeFunction                        269
#define SM_beginBlock                             270
#define SM_endBlock                               271
#define SM_shutdown                               272
#define SM_setMathCap                             273
#define SM_executeStringByLocalParserInBatchMode  274
#define SM_getsp                                  275
#define SM_dupErrors                              276
#define SM_control_kill                          1024
#define SM_control_to_debug_mode                 1025
#define SM_control_exit_debug_mode               1026
#define SM_control_reset_connection              1030
\end{verbatim}

OpenXM does not have a standard for mathematical operation sets
while it is a work in progress in the GAP group \cite{gap}.
Each OpenXM server has its own set of mathematical operations,
which are performed as follows.
First, arguments for a mathematical operation
and the number of the arguments are pushed.
Second, 
the mathematical operator name, 
such as {\tt fctr} (asir factorization command),
is pushed as a string.
Finally, the stack machine command
{\tt SM\_executeFunction} (269) evaluates the operator and
pushes the result onto the stack
after poping the operator name, the number of arguments
and arguments.
For example, the following code factorizes $x^{100}-1$ by calling
{\tt ox\_asir} from asir.
\begin{verbatim}
P = ox_launch(); 
ox_push_cmo(P,x^100-1); ox_push_cmo(P,ntoint32(1));
ox_push_cmd(P,269); 
Ans = ox_pop_cmo(P);
\end{verbatim}

When an error has occurred on an OpenXM server,
an error object is pushed to the stack instead of a result of the computation.
The error object consists of the serial number of the OX message
which caused the error, and an error message.
\begin{verbatim}
[341] ox_rpc(0,"fctr",1.2*x)$
[342] ox_pop_cmo(0);
error([8,fctr : invalid argument])
\end{verbatim}

OpenXM server won't send error messages to the client
except when it receives a {\tt SM\_pop*} command.
OX stackmachines work in the asynchronous mode which is similar 
to X servers.
For servers for graphic and sound applications, it is an advantageous feature.
It is also easy to emulate RPC and a web server for MCP \cite{iamc} 
on our asynchronous OX stackmachines.





