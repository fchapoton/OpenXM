% $OpenXM: OpenXM/doc/issac2000/openxm-stackmachines.tex,v 1.11 2000/01/16 06:39:39 takayama Exp $

\section{OpenXM Stack machines}\label{sec:ox-stackmachines}

In OpenXM specification, all servers are stack machines.
%These are called OpenXM stack machines.
When a server ox\_xyz gets an OX data message,
it translates the data into a local object of ox\_xyz
and pushes the object onto the stack.
According to the OpenMath specification, 
the translation scheme 
%% together with definitions of mathematical operations
%% of the system ox\_xyz 
is called the {\it PhraseBook} of ox\_xyz.
For example, the Asir command {\tt ox\_push\_cmo(P,1)}
(push integer $1$ onto the server $P$)
sends an OX data message
{\tt (OX\_DATA,(CMO\_ZZ,1))} to the server $P$.
Here,
{\tt OX\_DATA} stands for {\tt OX\_DATA} header and 
{\tt (CMO\_ZZ,1)} is a body standing for $1$ expressed 
by the CMO.
The server tranlates {\tt (CMO\_ZZ, 1)} to its internal object of
the integer  $1$
and pushes the object onto the stack.

If the server gets an {\it OX command} message, then the server 
executes the command.
Any OX command message starts with the int32 tag OX\_COMMAND.
The body is a stack machine operation code expressed by int32.
The codes are listed below \cite{noro-takayama}.
\begin{verbatim}
#define SM_popSerializedLocalObject               258
#define SM_popCMO                                 262
#define SM_popString                              263
#define SM_mathcap                                264
#define SM_pops                                   265
#define SM_setName                                266
#define SM_evalName                               267
#define SM_executeStringByLocalParser             268
#define SM_executeFunction                        269
#define SM_beginBlock                             270
#define SM_endBlock                               271
#define SM_shutdown                               272
#define SM_setMathCap                             273
#define SM_executeStringByLocalParserInBatchMode  274
#define SM_getsp                                  275
#define SM_dupErrors                              276
#define SM_control_kill                          1024
#define SM_control_to_debug_mode                 1025
#define SM_control_exit_debug_mode               1026
#define SM_control_reset_connection              1030
\end{verbatim}

OpenXM does not have a standard for mathematical operation sets
while it is a work in progress in the GAP group \cite{gap}.
Each OpenXM server has its own set of mathematical operations,
which are performed as follows.
First, arguments for a mathematical operation
and the number of the arguments are pushed.
Second, 
the mathematical operator name, 
such as {\tt fctr} (the factorization command of Asir),
is pushed as a string.
Finally, the stack machine command
{\tt SM\_executeFunction} (269) evaluates the operator and
pushes the result onto the stack
after poping the operator name, the number of arguments
and arguments.
For example, the following code factorizes $x^{100}-1$ by calling
{\tt ox\_asir} from Asir.
\begin{verbatim}
P = ox_launch(); 
ox_push_cmo(P,x^100-1); ox_push_cmo(P,ntoint32(1));
ox_push_cmo(P,"fctr");  ox_push_cmd(P,269); 
Ans = ox_pop_cmo(P);
\end{verbatim}

When an error has occurred on an OpenXM server,
an error object is pushed onto the stack 
instead of a result of the computation.
The error object consists of the serial number of the OX message
which caused the error, and an error message.
\begin{verbatim}
[340] P = ox_launch()$
[341] ox_rpc(P,"fctr",1.2*x)$
[342] ox_pop_cmo(P);
error([8,fctr : invalid argument])
\end{verbatim}

OpenXM server won't send error messages to the client
except when it receives a {\tt SM\_pop*} command.
OX stackmachines work in the asynchronous mode which is similar 
to X servers.
For servers of graphic and sound applications, 
it may be an advantageous feature.
It is also possible to emulate RPC and a web server for MCP \cite{iamc} 
on our asynchronous OX stackmachines.





