% $OpenXM$
\documentclass{slides}
\usepackage{color}
\usepackage{rgb}
\usepackage{graphicx}
\usepackage{epsfig}
\newcommand{\qed}{$\Box$}
\newcommand{\mred}[1]{\smash{\mathop{\hbox{\rightarrowfill}}\limits_{\scriptstyle #1}}}
\newcommand{\tmred}[1]{\smash{\mathop{\hbox{\rightarrowfill}}\limits_{\scriptstyle #1}\limits^{\scriptstyle *}}}
\def\gr{Gr\"obner basis }
\def\st{\, s.t. \,}
\def\ni{\noindent} 
\def\ve{\vfill\eject} 
\textwidth 9.2in
\textheight 7.2in
\columnsep 0.33in
\topmargin -1in
\begin{document}
\setlength{\parskip}{10pt}
%\begin{slide}{}
%\begin{center}
%\fbox{\large Part II : Algorithms and implementations in Risa/Asir}
%\end{center}
%\end{slide}

\begin{slide}{}
\fbox{Ground fields}

\begin{itemize}
\item The rational number field
\item Algebraic number fields

represented by successive extensions
\item Finite fields
\begin{itemize}
\item $GF(p)$ ($p<2^{30}$); represented by a single word
\item $GF(p^n)$ ($p^n < 2^{20}$); represented by a primitive root
\item $GF(2^n)$; represented by a bit string
\item $GF(p)$ ($p$ : arbitrary prime)
\item $GF(p^n)$ ($p$ : arbitrary odd prime)
\end{itemize}

\item Real and complex number fields

\begin{itemize}
\item Double float
\item PARI bigfloat
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Polynomial factorization}
\begin{itemize}
\item Univariate factorization

\begin{itemize}
\item Over the rationals

Berlekamp-Zassenhaus

(classical; knapsack has not yet implemented)

\item Over algebraic number fields

Trager's algorithm + some improvement

\item Over finite fields

DDF + Cantor-Zassenhaus; FFT for large finite fields
\end{itemize}

\item Multivariate factorization

\begin{itemize}
\item Over the rationals

Classical EZ algorithm

\item Over small finite fields

Modified Bernardin's square free algorithm [BERN97],

possibly Hensel lifting over extension fields
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Groebner basis computation --- Buchberger algorithm}
\begin{itemize}
\item Polynomial rings
\begin{itemize}
\item Over finite fields

Any finite field is available as a ground field

\item Over the rationals

Guess of a groebner basis by detecting zero reduction by modular computation
+ check (trace lifting)

Homogenization+guess+dehomogenization+check
\end{itemize}

\item Weyl Algebra

\begin{itemize}
\item Groebner basis of a left ideal

Key : an efficient implementation of Leibniz rule
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{$F_4$ algorithm}
\begin{itemize}
\item Over small finite fields ($GF(p)$, $p < 2^{30}$)
\begin{itemize}
\item More efficient than our Buchberger algorithm implementation

but less efficient than FGb by Faug\`ere
\end{itemize}

\item Over the rationals

\begin{itemize}
\item Very naive implementation

Modular computation + CRT + Checking the result at each degree

\item Less efficient than Buchberger algorithm

except for one example (={\it McKay})
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Change of ordering for zero-dimensional ideals}

\begin{itemize}
\item Any ordering to lex ordering

\begin{itemize}
\item Modular change of ordering

Guess of the support by modular FGLM

+ solving linear systems by Hensel lifting

\end{itemize}

\item RUR (generalized shape lemma)

\begin{itemize}
\item Modular RUR (only implemented on the shape base case)

Almost the same as modular change of ordering
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Primary decomposition --- Shimoyama-Yokoyama algorithm}

\begin{itemize}
\item Only implemented over the rationals

Finite field version will soon be available

\item Pseudo primary ideal

An ideal whose radical is prime

\item Prime decomp. of the radical $\Rightarrow$ pseudo primary decomp.

\item Extraction of embedded components

\end{itemize}

\end{slide}

\begin{slide}{}
\fbox{Computation of $b$-function}

$D=K\langle x,\partial \rangle$ : Weyl algebra

$b(s)$ : a polynomial of the smallest degree s.t.
there exists $P(s) \in D[s]$, $P(s)f^{s+1}=b(s)f^s$

$b(s)$ : $b$-function of a polynomial $f$

$\Rightarrow$ $b(s)$ can be computed by Oaku's algorithm

On Risa/Asir : $b(s)$ is computed by

A groebner basis $\Rightarrow$ guess of $\deg(b(s))$ by modular
computation $\Rightarrow$ solving a linear system
\end{slide}

\begin{slide}{}
\fbox{Interface to PARI library}

\begin{itemize}
\item Data conversion

\begin{itemize}

\item Only primitive data can be passed to PARI

Rational number, bignum, bigfloat, polynomial,
vector, matrix

\item Results are converted to Risa objects

\end{itemize}

\item Evaluation of transcendental functions

\begin{itemize}
\item Most of univariate functions in PARI can be 
evaluated by {\tt eval()}
\end{itemize}

\item Calling PARI functions

\begin{itemize}
\item One can call PARI functions by {\tt pari({\it parifunction},{\it args})}

The knapsack factorization is available via {\tt pari(factor,{\it poly})}
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{OpenXM server interface in Risa/Asir}

\begin{itemize}
\item TCP/IP stream

\begin{itemize}
\item Launcher

A client executes a launcher on a host.

The launcher launches a server on the same host.

\item Server

Reads from the descriptor 3

Writes to the descriptor 4

\end{itemize}

\item Subroutine call

In Risa/Asir subroutine library {\tt libasir.a}:

OpenXM functionalities are implemented as function calls

pushing and popping data, executing stack commands etc.
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{OpenXM client interface in Risa/Asir}

\begin{itemize}
\item Primitive interface functions

Pushing and popping data, sending commands etc.

\item Convenient functions

Launching servers,

Calling remote functions,

Resetting remote executions etc.

\item Parallel distributed computation

Simple parallelization is practically important

Competitive computation is easily realized ($\Rightarrow$ demo)
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Executing functions on a server (I) --- {\tt SM\_executeFunction}}

\begin{enumerate}
\item (C $\rightarrow$ S) Arguments are sent in binary encoded form.
\item (C $\rightarrow$ S) The number of arguments is sent as {\sl Integer32}.
\item (C $\rightarrow$ S) A function name is sent as {\sl Cstring}.
\item (C $\rightarrow$ S) A command {\tt SM\_executeFunction} is sent.
\item The result is pushed to the stack.
\item (C $\rightarrow$ S) A command {\tt SM\_popCMO} is sent.
\item (S $\rightarrow$ C) The result is sent in binary encoded form.
\end{enumerate}

$\Rightarrow$ Communication is fast, but functions for binary data
conversion are necessary.
\end{slide}

\begin{slide}{}
\fbox{Executing functions on a server (II) --- {\tt SM\_executeString}}

\begin{enumerate}
\item (C $\rightarrow$ S) A character string representing a request in a server's
user language is sent as {\sl Cstring}.
\item (C $\rightarrow$ S) A command {\tt SM\_executeString} is sent.
\item The result is pushed to the stack.
\item (C $\rightarrow$ S) A command {\tt SM\_popString} is sent.
\item (S $\rightarrow$ C) The result is sent in readable form.
\end{enumerate}

$\Rightarrow$ Communication may be slow, but the client parser may be
enough to read the result.
\end{slide}

%\begin{slide}{}
%\fbox{History of development : ---1994}
%
%\begin{itemize}
%\item --1989
%
%Several subroutines were developed for a Prolog program.
%
%\item 1989--1992
%
%\begin{itemize}
%\item Reconfigured as Risa/Asir with a parser and Boehm's conservative GC
%
%\item Developed univariate and multivariate factorizers over the rationals.
%\end{itemize}
%
%\item 1992--1994
%
%\begin{itemize}
%\item Started implementation of Buchberger algorithm
%
%Written in user language $\Rightarrow$ rewritten in C (by Murao)
%
%$\Rightarrow$ trace lifting [TRAV88]
%
%\item Univariate factorization over algebraic number fields
%
%Intensive use of successive extension, non-squarefree norms
%\end{itemize}
%\end{itemize}
%
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 1994-1996}
%
%\begin{itemize}
%\item Free distribution of binary versions from Fujitsu
%
%\item Primary ideal decomposition
%
%\begin{itemize}
%\item Shimoyama-Yokoyama algorithm [SHYO96]
%\end{itemize}
%
%\item Improvement of Buchberger algorithm
%
%\begin{itemize}
%\item Trace lifting+homogenization
%
%\item Omitting check by compatible prime
%
%\item Modular change of ordering, Modular RUR
%
%These are joint works with Yokoyama [NOYO99]
%\end{itemize}
%\end{itemize}
%
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 1996-1998}
%
%\begin{itemize}
%\item Distributed computation
%
%\begin{itemize}
%\item A prototype of OpenXM
%\end{itemize}
%
%\item Improvement of Buchberger algorithm
%
%\begin{itemize}
%\item Content reduction during normal form computation
%
%\item Its parallelization by the above facility
%
%\item Computation of odd order replicable functions [NORO97]
%
%Risa/Asir : it took 5days to compute a DRL basis ({\it McKay})
%
%Faug\`ere FGb : computation of the DRL basis 53sec
%\end{itemize}
%
%
%\item Univariate factorization over large finite fields
%
%\begin{itemize}
%\item To implement Schoof-Elkies-Atkin algorithm 
%
%Counting rational points on elliptic curves
%
%--- not free But related functions are freely available
%\end{itemize}
%\end{itemize}
%
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 1998-2000}
%\begin{itemize}
%\item OpenXM
%
%\begin{itemize}
%\item OpenXM specification was written by Noro and Takayama
%
%Borrowed idea on encoding, phrase book from OpenMath
%
%\item Functions for distributed computation were rewritten
%\end{itemize}
%
%\item Risa/Asir on Windows
%
%\begin{itemize}
%\item Requirement from a company for which Noro worked
%
%Written in Visual C++
%\end{itemize}
%
%\item Test implementation of $F_4$
%
%\begin{itemize}
%\item Implemented according to [FAUG99]
%
%\item Over $GF(p)$ : pretty good
%
%\item Over the rationals : not so good except for {\it McKay}
%\end{itemize}
%\end{itemize}
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 2000-current}
%\begin{itemize}
%\item The source code is freely available
%
%\begin{itemize}
%\item Noro moved from Fujitsu to Kobe university
%
%Started Kobe branch
%\end{itemize}
%
%\item OpenXM
%
%\begin{itemize}
%\item Revising the specification : OX-RFC100, 101, (102)
%
%\item OX-RFC102 : communications between servers via MPI
%\end{itemize}
%
%\item Weyl algebra
%
%\begin{itemize}
%\item Buchberger algorithm [TAKA90]
%
%\item $b$-function computation [OAKU97]
%
%Minimal polynomial computation by modular method
%\end{itemize}
%\end{itemize}
%
%\end{slide}
\begin{slide}{}
\end{slide}

\begin{slide}{}
\end{slide}

\begin{slide}{}
\end{slide}

\begin{slide}{}
\end{slide}
\end{document}

