% $OpenXM: OpenXM/doc/Papers/dagb-noro.tex,v 1.4 2001/10/04 08:22:20 noro Exp $
\setlength{\parskip}{10pt}

\begin{slide}{}
\begin{center}
\fbox{\large Part I : OpenXM and Risa/Asir --- overview and history}
\end{center}
\end{slide}

\begin{slide}{}
\fbox{OpenXM (Open message eXchange protocol for Mathematics) }

\begin{itemize}
\item An environment for parallel distributed computation

Both for interactive, non-interactive environment

\item Client-server architecture

Client $\Leftarrow$ OX (OpenXM) message $\Rightarrow$ Server

OX (OpenXM) message : command and data

\item Data

Encoding : CMO (Common Mathematical Object format)

Serialized representation of mathematical object

--- Main idea was borrowed from OpenMath [OpenMath]
\item Command

stack machine command --- server is a stackmachine

+ server's own command sequences --- hybrid server
\end{itemize}
\end{slide}


\begin{slide}{}
\fbox{OpenXM and OpenMath}

\begin{itemize}
\item OpenMath

\begin{itemize}
\item A standard for representing mathematical objects

\item CD (Content Dictionary) : assigns semantics to symbols

\item Phrasebook : convesion between internal and OpenMath objects.

\item Encoding : format for actual data exchange
\end{itemize}

\item OpenXM

\begin{itemize}
\item Specification for encoding and exchanging messages

\item It also specifies behavior of servers and session management
\end{itemize}

\end{itemize}
\end{slide}
\begin{slide}{}
\fbox{A computer algebra system Risa/Asir}

\begin{itemize}
\item Old style software for polynomial computation

No domain specification, automatic expansion

\item User language with C-like syntax

C language without type declaration, with list processing

\item Builtin {\tt gdb}-like debugger for user programs

\item Open source

Whole source tree is available via CVS

\item OpenXM interface

\begin{itemize}
\item Risa/Asir is a main client in OpenXM package.
\item An OpenXM server {\tt ox\_asir}
\item An library with OpemXM library inteface {\tt libasir.a}
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Aim of developing Risa/Asir}

\begin{itemize}
\item Efficient implementation in specific area

Polynomial factorization, Groebner basis related computation

$\Rightarrow$ serves as an OpenXM server/library

\item Front-end of a general purpose math software

Risa/Asir contains PARI library [PARI] from the very beginning

It also acts as a main client of OpenXM package

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Capability for polynomial computation}

\begin{itemize}
\item Fundamental polynomial arithmetics

recursive representaion and distributed representation

\item Polynomial factorization

\begin{itemize}
\item Univariate : over {\bf Q}, algebraic number fields and finite fields

\item Multivariate : over {\bf Q}
\end{itemize}

\item Groebner basis computation

\begin{itemize}
\item Buchberger and $F_4$ [Faug\'ere] algorithm

\item Change of ordering/RUR [Rouillier] of 0-dimensional ideals

\item Primary ideal decomposition

\item Computation of $b$-function (in Weyl Algebra)
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{History of development : Polynomial factorization}

\begin{itemize}
\item 1989

Start of Risa/Asir with Boehm's conservative GC [Boehm]

\item 1989-1992

Univariate and multivariate factorizers over {\bf Q}

\item 1992-1994

Univariate factorization over algebraic number fields

Intensive use of successive extension, non-squarefree norms

\item 1996-1998

Univariate factorization over large finite fields

\item 2000-current 

Multivariate factorization over small finite fields (in progress)
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{History of development : Groebner basis}

\begin{itemize}
\item 1992-1994

User language $\Rightarrow$ C version; trace lifting [Traverso]

\item 1994-1996

Trace lifting with homogenization

Omitting GB check by compatible prime [NY]

Modular change of ordering/RUR [NY]

Primary ideal decompositon [SY]

\item 1996-1998

Effifcient content reduction during NF computation and its parallelization
[Noro] (Solved {\it McKay} system for the first time)

\item 1998-2000

Test implementation of $F_4$

\item 2000-current

Buchberger algorithm in Weyl algebra [Takayama]

Efficient $b$-function computation by a modular method
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Performance --- Factorizer}

\begin{itemize}
\item 4 years ago

Over {\bf Q} : fine compared with existing software
like REDUCE, Mathematica, maple

Univarate, over algebraic number fields :
fine because of some tricks for polynomials
derived from norms.

\item Current

Multivariate : not so bad

Univariate : completely obsolete by M. van Hoeij's new algorithm
[Hoeij]
\end{itemize}

\end{slide}

\begin{slide}{}
\fbox{Performance --- Groebner basis related computation}

\begin{itemize}
\item 7 years ago

Trace lifting : rather fine but coefficient swells often occur

Homogenization+trace lifting : robust and fast in the above cases

\item 4 years ago

Modular RUR was comparable with Rouillier's implementation.

DRL basis of {\it McKay}: 

5 days on Risa/Asir, 53 seconds on Faugere FGb
\item Current

$F_4$ in FGb : much more efficient than $F_4$ in Risa/Asir

Buchberger in Singular [Singular] : faster than Risa/Asir

$\Leftarrow$ efficient monomial and polynomial representation

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{How do we proceed?}

\begin{itemize}
\item Developing new OpenXM servers

{ox\_NTL} for univariate factorization, 

{ox\_FGb} for Groebner basis computation (is it possible?) etc.

$\Rightarrow$ Risa/Asir can be a front-end of efficient servers

\item Trying to improve our implementation

Computation of $b$-function : still faster than any other system
(Kan/sm1, Macaulay2) but not satisfactory

$\Rightarrow$ Groebner basis computation in Weyl
algebra should be improved
\end{itemize}

\begin{center}
\underline{In both cases, OpenXM interface is important}
\end{center}
\end{slide}

\begin{slide}{}
\fbox{OpenXM server interface in Risa/Asir}

\begin{itemize}
\item TCP/IP stream

\begin{itemize}
\item Launcher

A client executes a launcher on a host.

The launcher launches a server on the same host.

\item Server

Reads from the descriptor 3

Writes to the descriptor 4

\end{itemize}

\item Subroutine call

In Risa/Asir subroutine library {\tt libasir.a}:

OpenXM functionalities are implemented as functon calls

pushing and popping data, executing stack commands etc.
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{OpenXM client interface in Risa/Asir}

\begin{itemize}
\item Primitive interface functions

Pushing and popping data, sending commands etc.

\item Convenient functions

Launching servers,

Calling remote functions,

Resetting remote executions etc.

\item Parallel distributed computation

Simple parallelization is practically important

Competitive computation is easily realized ($\Rightarrow$ demo)
\end{itemize}
\end{slide}


%\begin{slide}{}
%\fbox{CMO = Serialized representation of mathematical object}
%
%\begin{itemize}
%\item primitive data
%\begin{eqnarray*}
%\mbox{Integer32} &:& ({\tt CMO\_INT32}, {\sl int32}\ \mbox{n}) \\
%\mbox{Cstring}&:& ({\tt CMO\_STRING},{\sl int32}\,  \mbox{ n}, {\sl string}\, \mbox{s}) \\
%\mbox{List} &:& ({\tt CMO\_LIST}, {\sl int32}\, len, ob[0], \ldots,ob[m-1])
%\end{eqnarray*}
%
%\item numbers and polynomials
%\begin{eqnarray*}
%\mbox{ZZ}         &:& ({\tt CMO\_ZZ},{\sl int32}\, {\rm f}, {\sl byte}\, \mbox{a[1]}, \ldots
%{\sl byte}\, \mbox{a[$|$f$|$]} ) \\
%\mbox{Monomial32}&:& ({\tt CMO\_MONOMIAL32}, n, \mbox{e[1]}, \ldots, \mbox{e[n]}, \mbox{Coef}) \\
%\mbox{Coef}&:& \mbox{ZZ} | \mbox{Integer32} \\
%\mbox{Dpolynomial}&:& ({\tt CMO\_DISTRIBUTED\_POLYNOMIAL},\\
%                  & & m, \mbox{DringDefinition}, \mbox{Monomial32}, \ldots)\\
%\mbox{DringDefinition}
%                  &:& \mbox{DMS of N variables} \\
%                  & & ({\tt CMO\_RING\_BY\_NAME}, name) \\
%                  & & ({\tt CMO\_DMS\_GENERIC}) \\
%\end{eqnarray*}
%\end{itemize}
%\end{slide}
%
%\begin{slide}{}
%\fbox{Stack based communication}
%
%\begin{itemize}
%\item Data arrived a client
%
%Pushed to the stack
%
%\item Result
%
%Pushd to the stack
%
%Written to the stream when requested by a command
%
%\item The reason why we use the stack
%
%\begin{itemize}
%\item Stack = I/O buffer for (possibly large) objects
%
%Multiple requests can be sent before their exection
%
%A server does not get stuck in sending results
%\end{itemize}
%\end{itemize}
%\end{slide}

\begin{slide}{}
\fbox{Example of distributed computation --- $F_4$ vs. $Buchberger$ }

\begin{verbatim}
/* competitive Gbase computation over GF(M) */
/* Cf. A.28 in SINGULAR Manual */
/* Process list is specified as an option : grvsf4(...|proc=P) */
def grvsf4(G,V,M,O)
{
  P = getopt(proc);
  if ( type(P) == -1 ) return dp_f4_mod_main(G,V,M,O);
  P0 = P[0]; P1 = P[1]; P = [P0,P1];
  map(ox_reset,P);
  ox_cmo_rpc(P0,"dp_f4_mod_main",G,V,M,O);
  ox_cmo_rpc(P1,"dp_gr_mod_main",G,V,0,M,O);
  map(ox_push_cmd,P,262); /* 262 = OX_popCMO */
  F = ox_select(P); R = ox_get(F[0]);
  if ( F[0] == P0 ) { Win = "F4"; Lose = P1;}
  else { Win = "Buchberger"; Lose = P0; }
  ox_reset(Lose); /* simply resets the loser */
  return [Win,R];
}
\end{verbatim}
\end{slide}

\begin{slide}{}
\fbox{References}

[Bernardin] L. Bernardin, On square-free factorization of 
multivariate polynomials over a finite field, Theoretical
Computer Science 187 (1997), 105-116.

[Boehm] {\tt http://www.hpl.hp.com/personal/Hans\_Boehm/gc}

[Faug\`ere] J.C. Faug\`ere,
A new efficient algorithm for computing Groebner bases  ($F_4$),
Journal of Pure and Applied Algebra (139) 1-3 (1999), 61-88.

[Hoeij] M. van Heoij, Factoring polynomials and the knapsack problem,
to appear in Journal of Number Theory (2000).

[Noro] M. Noro, J. McKay,
Computation of replicable functions on Risa/Asir.
Proc. of PASCO'97, ACM Press, 130-138 (1997).

[NY] M. Noro, K. Yokoyama, 
A Modular Method to Compute the Rational Univariate
Representation of Zero-Dimensional Ideals.
J. Symb. Comp. {\bf 28}/1 (1999), 243-263.
\end{slide}

\begin{slide}{}

[Oaku] T. Oaku, Algorithms for $b$-functions, restrictions and algebraic
local cohomology groups of $D$-modules.
Advancees in Applied Mathematics, 19 (1997), 61-105.

[OpenMath] {\tt http://www.openmath.org}

[OpenXM] {\tt http://www.openxm.org}

[PARI] {\tt http://www.parigp-home.de}

[Risa/Asir] {\tt http://www.math.kobe-u.ac.jp/Asir/asir.html}

[Rouillier] F. Rouillier,
R\'esolution des syst\`emes z\'ero-dimensionnels. 
Doctoral Thesis(1996), University of Rennes I, France.

[SY] T. Shimoyama, K. Yokoyama, Localization and Primary Decomposition of Polynomial Ideals.  J. Symb. Comp. {\bf 22} (1996), 247-277.

[Singular] {\tt http://www.singular.uni-kl.de}

[Traverso] C. Traverso, \gr trace algorithms. Proc. ISSAC '88 (LNCS 358), 125-138.

\end{slide}

\begin{slide}{}
\begin{center}
\fbox{\large Part II : Algorithms and implementations in Risa/Asir}
\end{center}
\end{slide}

\begin{slide}{}
\fbox{Ground fields}

\begin{itemize}
\item The rational number field
\item Algebraic number fields

represented by successive extensions
\item Finite fields
\begin{itemize}
\item $GF(p)$ ($p<2^{30}$); represented by a single word
\item $GF(p^n)$ ($p^n < 2^{20}$); represented by a primitive root
\item $GF(2^n)$; represented by a bit string
\item $GF(p)$ ($p$ : arbitrary prime)
\item $GF(p^n)$ ($p$ : arbitrary odd prime)
\end{itemize}

\item Real and complex number fields

\begin{itemize}
\item Double float
\item PARI bigfloat
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Polynomial factorization}
\begin{itemize}
\item Univariate factorization

\begin{itemize}
\item Over the rationals

Berlekamp-Zassenhaus

(classical; knapsack has not yet implemented)

\item Over algebraic number fields

Trager's algorithm + some improvement

\item Over finite fieds

DDF + Cantor-Zassenhaus; FFT for large finite fields
\end{itemize}

\item Multivariate factorization

\begin{itemize}
\item Over the rationals

Classical EZ algorithm

\item Over small finite fieds

Modified Bernardin's square free algorithm [Bernardin],

possibly Hensel lifting over extension fields
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Groebner basis computation --- Buchberger algorithm}
\begin{itemize}
\item Polynomial rings
\begin{itemize}
\item Over finite fields

Any finite field is available as a ground field

\item Over the rationals

Guess of a groebner basis by detecting zero reduction by modular computation
+ check (trace lifting)

Homogenization+guess+dehomogenization+check
\end{itemize}

\item Weyl Algebra

\begin{itemize}
\item Groebner basis of a left ideal

Key : an efficient implementation of Leibniz rule
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{$F_4$ algorithm}
\begin{itemize}
\item Over small finite fields ($GF(p)$, $p < 2^{30}$)
\begin{itemize}
\item More efficient than our Buchberger algorithm implementation

but less efficient than FGb by Faugere
\end{itemize}

\item Over the rationals

\begin{itemize}
\item Very naive implementation

Modular computation + CRT + Checking the result at each degree

\item Less efficient than Buchberger algorithm

except for one example (={\it McKay})
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Change of ordering for zero-dimensional ideals}

\begin{itemize}
\item Any ordering to lex ordering

\begin{itemize}
\item Modular change of ordering

Guess of the support by modular FGLM

+ solving linear systems by Hensel lifting

\end{itemize}

\item RUR (generalized shape lemma)

\begin{itemize}
\item Modular RUR (only implemented on the shape base case)

Almost the same as modular change of ordering
\end{itemize}

\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Primary decomposition --- Shimoyama-Yokoyama algorithm}

\begin{itemize}
\item Only implemented over the rationals

Finite field version will soon be available

\item Pseudo primary ideal

An ideal whose radical is prime

\item Prime decomp. of the radical $\Rightarrow$ pseudo primary decomp.

\item Extraction of embedded components

\end{itemize}

\end{slide}

\begin{slide}{}
\fbox{Computation of $b$-function}

$D=K\langle x,\partial \rangle$ : Weyl algebra

$b(s)$ : a polynomial of the smallest degree s.t.
there exists $P(s) \in D[s]$, $P(s)f^{s+1}=b(s)f^s$

$b(s)$ : $b$-function of a polynomial $f$

$\Rightarrow$ $b(s)$ can be computed by Oaku's algorithm

On Risa/Asir : $b(s)$ is computed by

A groebner basis $\Rightarrow$ guess of $\deg(b(s))$ by modular
computation $\Rightarrow$ solving a linear system
\end{slide}

\begin{slide}{}
\fbox{Interface to PARI library}

\begin{itemize}
\item Data conversion

\begin{itemize}

\item Only primitive data can be passed to PARI

Rational number, bignum, bigfloat, polynomial,
vector, matrix

\item Results are converted to Risa objects

\end{itemize}

\item Evaluation of transcendental functions

\begin{itemize}
\item Most of univariate functions in PARI can be 
evaluated by {\tt eval()}
\end{itemize}

\item Calling PARI functions

\begin{itemize}
\item One can call PARI functions by {\tt pari({\it parifunction},{\it args})}

The knapsack factorization is available via {\tt pari(factor,{\it poly})}
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{}
\fbox{Executing functions on a server (I) --- {\tt SM\_executeFunction}}

\begin{enumerate}
\item (C $\rightarrow$ S) Arguments are sent in binary encoded form.
\item (C $\rightarrow$ S) The number of aruments is sent as {\sl Integer32}.
\item (C $\rightarrow$ S) A function name is sent as {\sl Cstring}.
\item (C $\rightarrow$ S) A command {\tt SM\_executeFunction} is sent.
\item The result is pushed to the stack.
\item (C $\rightarrow$ S) A command {\tt SM\_popCMO} is sent.
\item (S $\rightarrow$ C) The result is sent in binary encoded form.
\end{enumerate}

$\Rightarrow$ Communication is fast, but functions for binary data
conversion are necessary.
\end{slide}

\begin{slide}{}
\fbox{Executing functions on a server (II) --- {\tt SM\_executeString}}

\begin{enumerate}
\item (C $\rightarrow$ S) A character string represeting a request in a server's
user language is sent as {\sl Cstring}.
\item (C $\rightarrow$ S) A command {\tt SM\_executeString} is sent.
\item The result is pushed to the stack.
\item (C $\rightarrow$ S) A command {\tt SM\_popString} is sent.
\item (S $\rightarrow$ C) The result is sent in readable form.
\end{enumerate}

$\Rightarrow$ Communication may be slow, but the client parser may be
enough to read the result.
\end{slide}

%\begin{slide}{}
%\fbox{History of development : ---1994}
%
%\begin{itemize}
%\item --1989
%
%Several subroutines were developed for a Prolog program.
%
%\item 1989--1992
%
%\begin{itemize}
%\item Reconfigured as Risa/Asir with a parser and Boehm's conservative GC [Boehm]
%
%\item Developed univariate and multivariate factorizers over the rationals.
%\end{itemize}
%
%\item 1992--1994
%
%\begin{itemize}
%\item Started implementation of Buchberger algorithm
%
%Written in user language $\Rightarrow$ rewritten in C (by Murao)
%
%$\Rightarrow$ trace lifting [Traverso]
%
%\item Univariate factorization over algebraic number fields
%
%Intensive use of successive extension, non-squarefree norms
%\end{itemize}
%\end{itemize}
%
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 1994-1996}
%
%\begin{itemize}
%\item Free distribution of binary versions from Fujitsu
%
%\item Primary ideal decomposition
%
%\begin{itemize}
%\item Shimoyama-Yokoyama algorithm [SY]
%\end{itemize}
%
%\item Improvement of Buchberger algorithm
%
%\begin{itemize}
%\item Trace lifting+homogenization
%
%\item Omitting check by compatible prime
%
%\item Modular change of ordering, Modular RUR
%
%These are joint works with Yokoyama [NY]
%\end{itemize}
%\end{itemize}
%
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 1996-1998}
%
%\begin{itemize}
%\item Distributed compuatation
%
%\begin{itemize}
%\item A prototype of OpenXM
%\end{itemize}
%
%\item Improvement of Buchberger algorithm
%
%\begin{itemize}
%\item Content reduction during nomal form computation
%
%\item Its parallelization by the above facility
%
%\item Computation of odd order replicable functions [Noro]
%
%Risa/Asir : it took 5days to compute a DRL basis ({\it McKay})
%
%Faug\`ere FGb : computation of the DRL basis 53sec
%\end{itemize}
%
%
%\item Univariate factorization over large finite fields
%
%\begin{itemize}
%\item To implement Schoof-Elkies-Atkin algorithm 
%
%Counting rational points on elliptic curves
%
%--- not free But related functions are freely available
%\end{itemize}
%\end{itemize}
%
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 1998-2000}
%\begin{itemize}
%\item OpenXM
%
%\begin{itemize}
%\item OpenXM specification was written by Noro and Takayama
%
%Borrowed idea on encoding, phrase book from OpenMath [OpenMath]
%
%\item Functions for distributed computation were rewritten
%\end{itemize}
%
%\item Risa/Asir on Windows
%
%\begin{itemize}
%\item Requirement from a company for which Noro worked
%
%Written in Visual C++
%\end{itemize}
%
%\item Test implementation of $F_4$
%
%\begin{itemize}
%\item Implemented according to [Faug\`ere]
%
%\item Over $GF(p)$ : pretty good
%
%\item Over the rationals : not so good except for {\it McKay}
%\end{itemize}
%\end{itemize}
%\end{slide}
%
%\begin{slide}{}
%\fbox{History of development : 2000-current}
%\begin{itemize}
%\item The source code is freely available
%
%\begin{itemize}
%\item Noro moved from Fujitsu to Kobe university
%
%Started Kobe branch [Risa/Asir]
%\end{itemize}
%
%\item OpenXM [OpenXM]
%
%\begin{itemize}
%\item Revising the specification : OX-RFC100, 101, (102)
%
%\item OX-RFC102 : communications between servers via MPI
%\end{itemize}
%
%\item Weyl algebra
%
%\begin{itemize}
%\item Buchberger algorithm [Takayama]
%
%\item $b$-function computation [Oaku]
%
%Minimal polynomial computation by modular method
%\end{itemize}
%\end{itemize}
%
%\end{slide}
\begin{slide}{}
\end{slide}

\begin{slide}{}
\end{slide}

\begin{slide}{}
\end{slide}

\begin{slide}{}
\end{slide}

