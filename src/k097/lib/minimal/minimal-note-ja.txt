$OpenXM: OpenXM/src/k097/lib/minimal/minimal-note-ja.txt,v 1.3 2000/06/08 08:37:53 takayama Exp $   

SpairAndReduction() :
   与えられた pair を reduction する.
   V-minimal に必要かどうかの判定もする.

SpairAndReduction2():
  tower2 = StowerOf(tower,level-1);
  SsetTower(tower2);  
  /** sm1(" show_ring ");   */

  与えられた pair を reduction するための schreyer order
  を設定する.  Resolution の深さに応じて, tower も深くする必要がある.


  if (IsConstant(t_syz[i])){

  Syzygy をみて, 定数成分がないか check.
  t_syz[i] が定数成分であれば, 一つ前の GB の構成要素である
  g_i が余分な GB である可能性がたかい.
  SpairAndReduction() ( LaScala-Stillman の方法) との整合性をとるため 
  g_i を tmp[0] に代入し ( reduction できなかったふりをする )
  g_i の V-degree をしらべる.


Sannfs2_laScala2()
Sannfs3_laScala2()  を作る.

二つのアルゴリズムの比較.
In(11)=sm1_pmat(a1[1]); の順番をかえる.
 [ 
   [    3*Dx^2*h , 0 , Dy , -Dz ] 
   [    6*x*Dy*Dz^2-9*y*Dx^2*h , -2*x*Dy*Dz^2+3*y*Dx^2*h , -2*x*Dx-3*y*Dy , 0]
   [    2*x*Dx+3*z*Dz-h^2 , y*Dy-z*Dz , 0 , 0 ] 
   [    2*x*Dy*Dz , 0 , z , -y ] 

   [    0 , 2*x*Dy^2*Dz-3*z*Dx^2*h , 0 , 2*x*Dx+3*z*Dz ] 
 ]
In(12)=sm1_pmat(a2[1]);
 [ 
   [    3*Dx^2*h , 0 , Dy , -Dz ] 
   [    6*x*Dy*Dz^2-9*y*Dx^2*h , -2*x*Dy*Dz^2+3*y*Dx^2*h , -2*x*Dx-3*y*Dy, 0 ] 
   [    2*x*Dx+3*z*Dz-h^2 , y*Dy-z*Dz , 0 , 0 ] 
   [    2*x*Dy*Dz , 0 , z , -y ] 

   [    9*z*Dx^2*h , 2*x*Dy^2*Dz-3*z*Dx^2*h , 3*z*Dy , 2*x*Dx ] 
   [    2*x*Dx*Dz^2+3*z*Dz^3+5*Dz^2*h^2 , y*Dy*Dz^2-z*Dz^3-2*Dz^2*h^2 , 0 , 0 ] 
 ]
In(13)=

----------------------
In(16)=sm1_pmat(a1[2]);
 [ 
   [    -2*x*Dx-3*y*Dy-3*z*Dz-6*h^2 , -Dy , -Dz , 3*Dx^2*h , 3*Dy^2 , 3*Dy*Dz , -2*x*Dy , 2*x*Dz , 0 ] 
   [    3*y*z , z , y , -2*x*Dy*Dz , -3*z*Dy , 2*x*Dx , 2*x*z , -2*x*y , 0 ] 
 ]
In(17)=sm1_pmat(a2[2]);
 [ 
   [    -y , 2*x*Dy*Dz , z , 0 , 2*x*Dx , 0 ] 
   [    -Dz , 3*Dx^2*h , Dy , -2*x*Dx-3*y*Dy-3*h^2 , -3*Dy*Dz , 0 ] 
 ]
In(18)=  

---------------------------

May 22, (Tue),  5:50 (Spain local time, 12:50 JST)

kan96xx/Kan/resol.c で,
   RemoveRedundantInSchreyerSkelton = 0
に変えて (この option もあたらしく加える), schreyer が正しく動くか
調べることにする.
( commit は kan96xx と k097 両方すべし.)

test8() で sm1 で書いた方の Schreyer を見ると,
   RemoveRedundantInSchreyerSkelton = 1
でも, 
kernel = image
となっているので以後この option は 1 のまま使うこととする.
要するに k0 のコードがどうやらおかしいらしい.
==>
6/8 のノートより.
syzygy を homogenization を介して計算するのは問題あり.
--> usage of isExact
要するに kernel = image のコードも変.  Homogenized のままやる必要あり.

-----------------------------------
June 8, 2000 (Thu), 9:10 (Spain local time)
hol.sm1 :  gb_h, syz_h, isSameIdeal, isSameIdeal_h
complex.sm1 :  isExact, isExact_h

syzygy を homogenization を介して計算するのは問題あり.
--> usage of isExact

[(Homogenize_vec) 0] system_variable : vector の homogenize をしない.
(grade) (module1v) switch_function : vector 変数は, total
       degree に数えない.
==> 無限ループに注意   ---> gb_h, syz_h  の usage.

minimal-test.k の ann(x^3-y^2*z^2) の laplace 変換の
betti 数が変, exact でない, を isExact_h で check 
しよう.

minimal-test.k
test10();
  LaScala-Stillman の方法でつくった, schreyer resol が exact か   
  調べる.
  例題は, ann(1/(x^3-y^2 z^2)) の Laplace 変換.
  ==> OK.  IsExact_h でしらべる.  (IsExact はだめよ)

June 8, 2000 (Thu), 19:35
load["minimal-test.k"];;
test11();
  LaScala-Stillman の方法でつくった, minimal resol が exact か   
  調べる.
  例題は, ann(1/(x^3-y^2 z^2)) の Laplace 変換.

SwhereInTower を使うときは,
SsetTower() で gbList を変更しないといけない.
もちろん使用したら, それを戻すこと.
SpairAndReduction, SpairAndReduction2 で,
  SsetTower(StowerOf(tower,level));
  pos = SwhereInTower(syzHead,tower[level]);

  SsetTower(StowerOf(tower,level-1));
  pos2 = SwhereInTower(tmp[0],tower[level-1]);
と, SwhereInTower の前に setTower をくわえた.
( 違うレベルでの比較のため.)

IsExact_h は, 0 ベクトルを含む場合, ただしく動作しないようだ.
test11().
test11a() で, 0 ベクトルを手で除いた行列の exactness をチェック. ==> OK.


---------------------------------
June 9, 6:20
SpairAndReduction
と
SpairAndReduction2
の違い.
SpairAndReduction  :  SlaScala  (LaScala-Stillman's algorithm で使う)
SpairAndReduction2 :  Sschreyer (schreyer  algorithm で使う, laScala はなし.)

0 を自動で除くコードを書こう.

SpruneZeroRow() を Sminimal() に加えた.
test11() も正しく動作するはず.
IsExact_h は schreyer を off して, ReParse してから,
呼び出すこと.


#ifdef TOTAL_STRATEGY
  return(StotalDegree(f)+Sdegree(tower[level-2,i],tower,level-1)); 
#endif
  /* Strategy must be compatible with ordering.  */
  /* Weight vector must be non-negative, too.  */
  /* See Sdegree, SgenerateTable, reductionTable. */
  wd = Sord_w(f,ww);
  return(wd+Sdegree(tower[level-2,i],tower,level-1));
TOTAL_STRATEGY を用いる必要があるのでは??
Example 1:  Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
          v=[[2*x*Dx + 3*y*Dy+6, 0],
             [3*x^2*Dy + 2*y*Dx, 0],
             [0,  x^2+y^2],
             [0,  x*y]];
         a=Sminimal(v);
strategy がおかしいといってとまる. 理由は?

a=test_ann3("x^3+y^3+z^3); は時間がかかりそう.
a=test_ann3("x^3+y^3"); OK.
a=test_ann3("x^2+y^2+z"); OK.


上の example 1 のエラー の見方:
Processing [    1 , 3 ]    Strategy = 2
     1 の 3 番目の spair の reduction を処理中.
     In(7)=reductionTable:
    [[ 1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
                                                   -- これ.
SpairAndReduction:
[    p and bases  , [    [    0 , 3 ]  , [    y*h , -x ]  ]  , [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ]  ] 
0 の 0 番目と 3 番目 の spair を計算して, 0 レベルの gb で reduction.
[ 1 , 1 , 1 , 2 , 2 , 3 ] にあるように, strategy 3 以外は計算ずみ.
( 計算してないものは %[null] となってる. )
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ]   ( 一番下なので, tower はなしよ. )
[    y*h , -es^3*x ] 
[gi, gj] = [    2*x*Dx+3*y*Dy+6*h^2 , 2*y*Dx*h+3*x^2*Dy ] 
1
Reduce the element 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy
by  [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ] 
result is [    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , 1 , [    0 , 0 , 0 , 0 , 0 , 0 ]  ] 
vdegree of the original = -1
vdegree of the remainder = -1
[    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , [    y*h , 0 , 0 , -x , 0 , 0 ]  , 3 , 5 , -1 , -1 ] 

In(11)=freeRes:
[    [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ]  , [    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ]  , [    %[null] ]  ] 
をみればわかるように, SlaScala で, freeRes にこの元が [0,5] に加え
られた.

次に SnextI が SlaScala より呼ばれてこのエラー.
        i = SnextI(reductionTable_tmp,strategy,redundantTable,
                   skel,level,freeRes);
In(22)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
なので, 最後 の 2 が処理されるはずだが,
In(25)=skel[2]:
[    [    [    0 , 2 ]  , [    1 , -y^2 ]  ]  ] 
のように, 0 番目と, 2 番目の spair.
しかし, 
In(26)=bases:
[    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ] 
のように, 0 番目は strategy 3 なので, まだもとまっていない.

reductionTable_tmp=[    2 ] 
See also reductionTable, strategy, level,i
ERROR(sm): error operator : SnextI: bases[i] or bases[j] is null for all combinations.
--- Engine error or interrupt : In function : Error of class PrimitiveObject

Type in Cleards() to exit the debug mode and Where() to see the stack trace.
In(7)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
In(8)=strategy:
2
In(9)=level:
2

   RemoveRedundantInSchreyerSkelton = 0
としても同じエラー.

-------------------------------------------------
test_ann3("x*y+y*z+z*x");    OK.

6/9 (Fri)
Sminimal の実装に相変わらず苦労してます.
Sevilla でいろいろと直した結果,
Sminimal はうまくうごけば正しい答えをだしてるみたいですが
(D<h> : homogenized Weyl で ker = im を check してる,
 V-adapted (strict) かどうかの check routing はまだ書いてない),
strategy がうまくうごかなくてとまる場合もあります
( strategy = 2 の sp を計算するのに, strategy 3 の 元を必要と
  したりする場合あり).


strategy は
def Sdegree(f,tower,level) {
  local i,ww, wd;
  /* extern WeightOfSweyl; */
  ww = WeightOfSweyl;
  f = Init(f);
  if (level <= 1) return(StotalDegree(f));
  i = Degree(f,es);
  return(StotalDegree(f)+Sdegree(tower[level-2,i],tower,level-1)); 
}
を用いて, 
      ans_at_each_floor[j] = Sdegree(tower[i,j],tower,i+1)-(i+1)
で計算してます.

いくつか出力をつけておきますので, 検討!!!

例 1:
load["minimal-test.k"];;
a=test_ann3("x^3-y^2*z^2"); 引数の annihilating ideal の laplace 変換の
                            homogenization の resolution.
      weight vector は (-1,-1,-1,1,1,1)

In(4)=sm1_pmat(a[1]);
 [ 
  [   0 次
    [    y*Dy-z*Dz ] 
    [    -2*x*Dx-3*z*Dz+h^2 ] 
    [    2*x*Dy*Dz^2-3*y*Dx^2*h ] 
    [    2*x*Dy^2*Dz-3*z*Dx^2*h ] 
  ]
  [   1 次
    [    3*Dx^2*h , 0 , Dy , -Dz ] 
    [    6*x*Dy*Dz^2-9*y*Dx^2*h , -2*x*Dy*Dz^2+3*y*Dx^2*h , -2*x*Dx-3*y*Dy , 0 ] 
    [    0 , 2*x*Dy^2*Dz-3*z*Dx^2*h , 0 , 2*x*Dx+3*z*Dz ] 
    [    2*x*Dx+3*z*Dz-h^2 , y*Dy-z*Dz , 0 , 0 ] 
    [    2*x*Dy*Dz , 0 , z , -y ] 
  ]
  [  2 次
    [    -2*x*Dx-3*y*Dy-3*z*Dz-6*h^2 , -Dy , -Dz , 3*Dx^2*h , 3*Dy*Dz ] 
    [    3*y*z , z , y , -2*x*Dy*Dz , 2*x*Dx ] 
  ]
 ]
In(5)=

例 2:
load["minimal-test.k"];;
a=test_ann3("x*y+y*z+z*x");
In(6)=sm1_pmat(a[1]);
 [ 
  [  0 次
    [    2*x*Dx+x*Dz-y*Dz+z*Dz+h^2 ] 
    [    -2*y*Dy+x*Dz-y*Dz-z*Dz-h^2 ] 
    [    -2*x*Dy+2*z*Dy+x*Dz-y*Dz+3*z*Dz+h^2 ] 
    [    -2*y*Dx+2*z*Dx-x*Dz+y*Dz+3*z*Dz+h^2 ] 
  ]
  [  1 次
    [    y-z , x-z , -y , x ] 
    [    2*Dy-2*Dz , 2*Dx-2*Dz , 2*Dx+2*Dz , -2*Dy-2*Dz ] 
    [    2*y*Dx-2*z*Dx+x*Dz-y*Dz-3*z*Dz-2*h^2 , 0 , 0 , 2*x*Dx+x*Dz-y*Dz+z*Dz+2*h^2 ] 
    [    2*y*Dy-2*z*Dy+y*Dz-z*Dz+h^2 , 2*x*Dz-y*Dz+2*z*Dz+h^2 , -x*Dz+z*Dz , 2*x*Dy+x*Dz ] 
    [    -2*y*Dy+2*z*Dy+y*Dz-z*Dz , y*Dz-4*z*Dz , -2*y*Dx+2*z*Dx-y*Dz+2*z*Dz , -2*z*Dy+y*Dz-3*z*Dz ] 
  ]
  [  2 次
    [    -2*y*Dx+2*z*Dx-y*Dz+2*z*Dz , x*y-x*z-y*z+z^2 , y-z , y , x+y-z ] 
    [    -6*Dx*Dz-2*Dz^2 , x*Dz+y*Dz-5*z*Dz-4*h^2 , -2*Dy+2*Dz , 2*Dx+2*Dz , 4*Dz ] 
  ]
 ]
In(7)=

例 3:  うまく行かない例:

Example 1:  Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
          v=[[2*x*Dx + 3*y*Dy+6, 0],
             [3*x^2*Dy + 2*y*Dx, 0],
             [0,  x^2+y^2],
             [0,  x*y]];
         a=Sminimal(v);
strategy がおかしいといってとまる. 理由は?
Negative weight vector を使わないときちんと動きます.


DEBUG 出力:
rf= [ 
  [ 
   [   Schreyer frame.
     [    0 , y^3 , 0 , 0 , -x^2 , 0 ] 
     [    0 , 0 , y^2 , 0 , -x , 0 ] 
     [    0 , y , -x , 0 , 0 , 0 ] 
     [    y*h , 0 , 0 , -x , 0 , 0 ] 
     [    0 , 0 , 0 , 3*y*Dy , 0 , -2*Dx ] 
   ]
   [ 
     [    1 , 0 , -y^2 , 0 , 0 ] 
   ]
    [   ] 
  ]
  [ 
    [    2*x*Dx , e_*x^2 , e_*x*y , 2*y*Dx*h , e_*y^3 , 3*y^2*Dy*h ] 
    [    es*y^3 , es^2*y^2 , es*y , y*h , 3*es^3*y*Dy ] 
    [    1 ] 
  ]
  [ 
    [   ] 
   [ 
    [ 
      [    1 , 4 ] 
      [    y^3 , -x^2 ] 
    ]
    [ 
      [    2 , 4 ] 
      [    y^2 , -x ] 
    ]
    [ 
      [    1 , 2 ] 
      [    y , -x ] 
    ]
    [ 
      [    0 , 3 ] 
      [    y*h , -x ] 
    ]
    [ 
      [    3 , 5 ] 
      [    3*y*Dy , -2*Dx ] 
    ]
   ]
   [ 
    [ 
      [    0 , 2 ] 
      [    1 , -y^2 ] 
    ]
   ]
    [   ] 
  ]
  [   resolution すべき 部分加群 e_ は ベクトル成分のマーク.
    [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ] 
  ]
 ]

略
Processing [    1 , 3 ]    Strategy = 2
     1 の 3 番目の spair の reduction を処理中.
     In(7)=reductionTable:
    [[ 1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
                                                   -- これ.
SpairAndReduction:
[    p and bases  , [    [    0 , 3 ]  , [    y*h , -x ]  ]  , [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ]  ] 
0 の 0 番目と 3 番目 の spair を計算して, 0 レベルの gb で reduction.
[ 1 , 1 , 1 , 2 , 2 , 3 ] にあるように, strategy 3 以外は計算ずみ.
( 計算してないものは %[null] となってる. )
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ]   ( 一番下なので, tower はなしよ. )
[    y*h , -es^3*x ] 
[gi, gj] = [    2*x*Dx+3*y*Dy+6*h^2 , 2*y*Dx*h+3*x^2*Dy ] 
1
Reduce the element 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy
by  [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ] 
result is [    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , 1 , [    0 , 0 , 0 , 0 , 0 , 0 ]  ] 
vdegree of the original = -1
vdegree of the remainder = -1
[    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , [    y*h , 0 , 0 , -x , 0 , 0 ]  , 3 , 5 , -1 , -1 ] 

In(11)=freeRes:
[    [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ]  , [    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ]  , [    %[null] ]  ] 
をみればわかるように, SlaScala で, freeRes にこの元が [0,5] に加え
られた.

次に SnextI が SlaScala より呼ばれてこのエラー.
        i = SnextI(reductionTable_tmp,strategy,redundantTable,
                   skel,level,freeRes);
In(22)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
なので, 最後 の 2 が処理されるはずだが,
In(25)=skel[2]:
[    [    [    0 , 2 ]  , [    1 , -y^2 ]  ]  ] 
のように, 0 番目と, 2 番目の spair.
しかし, 
In(26)=bases:
[    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ] 
のように, 0 番目は strategy 3 なので, まだもとまっていない.

reductionTable_tmp=[    2 ] 
See also reductionTable, strategy, level,i
ERROR(sm): error operator : SnextI: bases[i] or bases[j] is null for all combinations.
--- Engine error or interrupt : In function : Error of class PrimitiveObject

Type in Cleards() to exit the debug mode and Where() to see the stack trace.
In(7)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
In(8)=strategy:
2
In(9)=level:
2
この時点まででもとまった basis
 [ 
   [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ] 
   [    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ] 
   [    %[null] ] 
 ]

-------------------------------------

Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
a=Sminimal([x^2+y^2,x*y]);
これでも似たようなエラーをだせる.
この方が debug しやすい:
Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
a=Sminimal([x*y,x^2+y^2]);
ではエラーがでないのが不思議. 
pruneZero が動いてないのが変.

rf= [ 
  [ 
   [ 
     [    y^3 , 0 , -x^2 ] 
     [    0 , y^2 , -x ] 
     [    y , -x , 0 ] 
   ]
   [ 
     [    1 , 0 , -y^2 ] 
   ]
    [   ] 
  ]
  [ 
    [    x^2 , x*y , y^3 ] 
    [    y^3 , es*y^2 , y ] 
    [    1 ] 
  ]
  [ 
    [   ] 
   [ 
    [ 
      [    0 , 2 ] 
      [    y^3 , -x^2 ] 
    ]
    [ 
      [    1 , 2 ] 
      [    y^2 , -x ] 
    ]
    [ 
      [    0 , 1 ] 
      [    y , -x ] 
    ]
   ]
   [ 
    [ 
      [    0 , 2 ] 
      [    1 , -y^2 ] 
    ]
   ]
    [   ] 
  ]
  [ 
    [    x^2+y^2 , x*y , y^3 ] 
  ]
 ]
[    0 , 0 ] 
Processing [    0 , 0 ]    Strategy = 1
[    0 , 1 ] 
Processing [    0 , 1 ]    Strategy = 1
[    1 , 2 ] 
Processing [    1 , 2 ]    Strategy = 1
SpairAndReduction:
[    p and bases  , [    [    0 , 1 ]  , [    y , -x ]  ]  , [    x^2+y^2 , x*y , %[null] ]  ] 
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ] 
[    y , -es*x ] 
[gi, gj] = [    x^2+y^2 , x*y ] 
1
Reduce the element y^3
by  [    x^2+y^2 , x*y , %[null] ] 
result is [    y^3 , 1 , [    0 , 0 , 0 ]  ] 
vdegree of the original = -3
vdegree of the remainder = -3
[    y^3 , [    y , -x , 0 ]  , 2 , 2 , -3 , -3 ] 
[    0 , 2 ] 
Processing [    0 , 2 ]    Strategy = 2
[    1 , 1 ] 
Processing [    1 , 1 ]    Strategy = 2
SpairAndReduction:
[    p and bases  , [    [    1 , 2 ]  , [    y^2 , -x ]  ]  , [    x^2+y^2 , x*y , y^3 ]  ] 
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ] 
[    es*y^2 , -es^2*x ] 
[gi, gj] = [    x*y , y^3 ] 
1
Reduce the element 0
by  [    x^2+y^2 , x*y , y^3 ] 
result is [    0 , 1 , [    0 , 0 , 0 ]  ] 
vdegree of the original = -4
vdegree of the remainder = %[null]
[    0 , [    0 , y^2 , -x ]  , 1 , -1 , -4 , %[null] ] 
reductionTable_tmp=[    2 ] 
See also reductionTable, strategy, level,i
ERROR(sm): error operator : SnextI: bases[i] or bases[j] is null for all combinations.
--- Engine error or interrupt : In function : Error of class PrimitiveObject

Type in Cleards() to exit the debug mode and Where() to see the stack trace.
In(10)=reductionTable :
[    [    1 , 1 , 2 ]  , [    3 , 2 , 1 ]  , [    2 ]  ] 
In(11)=bases:
[    %[null] , [    0 , y^2 , -x ]  , [    -y , x , 1 ]  ] 
In(12)=  これは, [3, 2, 1]  の元のうち, 2,1 がもとまっている.
[ 2 ] の計算に 0 番目が必要でこれがまだない.




