$OpenXM: OpenXM/src/k097/lib/minimal/minimal-note-ja.txt,v 1.5 2000/06/14 07:44:04 takayama Exp $   

SpairAndReduction() :
   与えられた pair を reduction する.
   V-minimal に必要かどうかの判定もする.

SpairAndReduction2():
  tower2 = StowerOf(tower,level-1);
  SsetTower(tower2);  
  /** sm1(" show_ring ");   */

  与えられた pair を reduction するための schreyer order
  を設定する.  Resolution の深さに応じて, tower も深くする必要がある.


  if (IsConstant(t_syz[i])){

  Syzygy をみて, 定数成分がないか check.
  t_syz[i] が定数成分であれば, 一つ前の GB の構成要素である
  g_i が余分な GB である可能性がたかい.
  SpairAndReduction() ( LaScala-Stillman の方法) との整合性をとるため 
  g_i を tmp[0] に代入し ( reduction できなかったふりをする )
  g_i の V-degree をしらべる.


Sannfs2_laScala2()
Sannfs3_laScala2()  を作る.

二つのアルゴリズムの比較.
In(11)=sm1_pmat(a1[1]); の順番をかえる.
 [ 
   [    3*Dx^2*h , 0 , Dy , -Dz ] 
   [    6*x*Dy*Dz^2-9*y*Dx^2*h , -2*x*Dy*Dz^2+3*y*Dx^2*h , -2*x*Dx-3*y*Dy , 0]
   [    2*x*Dx+3*z*Dz-h^2 , y*Dy-z*Dz , 0 , 0 ] 
   [    2*x*Dy*Dz , 0 , z , -y ] 

   [    0 , 2*x*Dy^2*Dz-3*z*Dx^2*h , 0 , 2*x*Dx+3*z*Dz ] 
 ]
In(12)=sm1_pmat(a2[1]);
 [ 
   [    3*Dx^2*h , 0 , Dy , -Dz ] 
   [    6*x*Dy*Dz^2-9*y*Dx^2*h , -2*x*Dy*Dz^2+3*y*Dx^2*h , -2*x*Dx-3*y*Dy, 0 ] 
   [    2*x*Dx+3*z*Dz-h^2 , y*Dy-z*Dz , 0 , 0 ] 
   [    2*x*Dy*Dz , 0 , z , -y ] 

   [    9*z*Dx^2*h , 2*x*Dy^2*Dz-3*z*Dx^2*h , 3*z*Dy , 2*x*Dx ] 
   [    2*x*Dx*Dz^2+3*z*Dz^3+5*Dz^2*h^2 , y*Dy*Dz^2-z*Dz^3-2*Dz^2*h^2 , 0 , 0 ] 
 ]
In(13)=

----------------------
In(16)=sm1_pmat(a1[2]);
 [ 
   [    -2*x*Dx-3*y*Dy-3*z*Dz-6*h^2 , -Dy , -Dz , 3*Dx^2*h , 3*Dy^2 , 3*Dy*Dz , -2*x*Dy , 2*x*Dz , 0 ] 
   [    3*y*z , z , y , -2*x*Dy*Dz , -3*z*Dy , 2*x*Dx , 2*x*z , -2*x*y , 0 ] 
 ]
In(17)=sm1_pmat(a2[2]);
 [ 
   [    -y , 2*x*Dy*Dz , z , 0 , 2*x*Dx , 0 ] 
   [    -Dz , 3*Dx^2*h , Dy , -2*x*Dx-3*y*Dy-3*h^2 , -3*Dy*Dz , 0 ] 
 ]
In(18)=  

---------------------------

May 22, (Tue),  5:50 (Spain local time, 12:50 JST)

kan96xx/Kan/resol.c で,
   RemoveRedundantInSchreyerSkelton = 0
に変えて (この option もあたらしく加える), schreyer が正しく動くか
調べることにする.
( commit は kan96xx と k097 両方すべし.)

test8() で sm1 で書いた方の Schreyer を見ると,
   RemoveRedundantInSchreyerSkelton = 1
でも, 
kernel = image
となっているので以後この option は 1 のまま使うこととする.
要するに k0 のコードがどうやらおかしいらしい.
==>
6/8 のノートより.
syzygy を homogenization を介して計算するのは問題あり.
--> usage of isExact
要するに kernel = image のコードも変.  Homogenized のままやる必要あり.

-----------------------------------
June 8, 2000 (Thu), 9:10 (Spain local time)
hol.sm1 :  gb_h, syz_h, isSameIdeal, isSameIdeal_h
complex.sm1 :  isExact, isExact_h

syzygy を homogenization を介して計算するのは問題あり.
--> usage of isExact

[(Homogenize_vec) 0] system_variable : vector の homogenize をしない.
(grade) (module1v) switch_function : vector 変数は, total
       degree に数えない.
==> 無限ループに注意   ---> gb_h, syz_h  の usage.

minimal-test.k の ann(x^3-y^2*z^2) の laplace 変換の
betti 数が変, exact でない, を isExact_h で check 
しよう.

minimal-test.k
test10();
  LaScala-Stillman の方法でつくった, schreyer resol が exact か   
  調べる.
  例題は, ann(1/(x^3-y^2 z^2)) の Laplace 変換.
  ==> OK.  IsExact_h でしらべる.  (IsExact はだめよ)

June 8, 2000 (Thu), 19:35
load["minimal-test.k"];;
test11();
  LaScala-Stillman の方法でつくった, minimal resol が exact か   
  調べる.
  例題は, ann(1/(x^3-y^2 z^2)) の Laplace 変換.

SwhereInTower を使うときは,
SsetTower() で gbList を変更しないといけない.
もちろん使用したら, それを戻すこと.
SpairAndReduction, SpairAndReduction2 で,
  SsetTower(StowerOf(tower,level));
  pos = SwhereInTower(syzHead,tower[level]);

  SsetTower(StowerOf(tower,level-1));
  pos2 = SwhereInTower(tmp[0],tower[level-1]);
と, SwhereInTower の前に setTower をくわえた.
( 違うレベルでの比較のため.)

IsExact_h は, 0 ベクトルを含む場合, ただしく動作しないようだ.
test11().
test11a() で, 0 ベクトルを手で除いた行列の exactness をチェック. ==> OK.


---------------------------------
June 9, 6:20
SpairAndReduction
と
SpairAndReduction2
の違い.
SpairAndReduction  :  SlaScala  (LaScala-Stillman's algorithm で使う)
SpairAndReduction2 :  Sschreyer (schreyer  algorithm で使う, laScala はなし.)

0 を自動で除くコードを書こう.

SpruneZeroRow() を Sminimal() に加えた.
test11() も正しく動作するはず.
IsExact_h は schreyer を off して, ReParse してから,
呼び出すこと.


#ifdef TOTAL_STRATEGY
  return(StotalDegree(f)+Sdegree(tower[level-2,i],tower,level-1)); 
#endif
  /* Strategy must be compatible with ordering.  */
  /* Weight vector must be non-negative, too.  */
  /* See Sdegree, SgenerateTable, reductionTable. */
  wd = Sord_w(f,ww);
  return(wd+Sdegree(tower[level-2,i],tower,level-1));
TOTAL_STRATEGY を用いる必要があるのでは??
Example 1:  Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
          v=[[2*x*Dx + 3*y*Dy+6, 0],
             [3*x^2*Dy + 2*y*Dx, 0],
             [0,  x^2+y^2],
             [0,  x*y]];
         a=Sminimal(v);
strategy がおかしいといってとまる. 理由は?

a=test_ann3("x^3+y^3+z^3); は時間がかかりそう.
a=test_ann3("x^3+y^3"); OK.
a=test_ann3("x^2+y^2+z"); OK.


上の example 1 のエラー の見方:
Processing [    1 , 3 ]    Strategy = 2
     1 の 3 番目の spair の reduction を処理中.
     In(7)=reductionTable:
    [[ 1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
                                                   -- これ.
SpairAndReduction:
[    p and bases  , [    [    0 , 3 ]  , [    y*h , -x ]  ]  , [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ]  ] 
0 の 0 番目と 3 番目 の spair を計算して, 0 レベルの gb で reduction.
[ 1 , 1 , 1 , 2 , 2 , 3 ] にあるように, strategy 3 以外は計算ずみ.
( 計算してないものは %[null] となってる. )
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ]   ( 一番下なので, tower はなしよ. )
[    y*h , -es^3*x ] 
[gi, gj] = [    2*x*Dx+3*y*Dy+6*h^2 , 2*y*Dx*h+3*x^2*Dy ] 
1
Reduce the element 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy
by  [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ] 
result is [    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , 1 , [    0 , 0 , 0 , 0 , 0 , 0 ]  ] 
vdegree of the original = -1
vdegree of the remainder = -1
[    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , [    y*h , 0 , 0 , -x , 0 , 0 ]  , 3 , 5 , -1 , -1 ] 

In(11)=freeRes:
[    [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ]  , [    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ]  , [    %[null] ]  ] 
をみればわかるように, SlaScala で, freeRes にこの元が [0,5] に加え
られた.

次に SnextI が SlaScala より呼ばれてこのエラー.
        i = SnextI(reductionTable_tmp,strategy,redundantTable,
                   skel,level,freeRes);
In(22)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
なので, 最後 の 2 が処理されるはずだが,
In(25)=skel[2]:
[    [    [    0 , 2 ]  , [    1 , -y^2 ]  ]  ] 
のように, 0 番目と, 2 番目の spair.
しかし, 
In(26)=bases:
[    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ] 
のように, 0 番目は strategy 3 なので, まだもとまっていない.

reductionTable_tmp=[    2 ] 
See also reductionTable, strategy, level,i
ERROR(sm): error operator : SnextI: bases[i] or bases[j] is null for all combinations.
--- Engine error or interrupt : In function : Error of class PrimitiveObject

Type in Cleards() to exit the debug mode and Where() to see the stack trace.
In(7)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
In(8)=strategy:
2
In(9)=level:
2

   RemoveRedundantInSchreyerSkelton = 0
としても同じエラー.

-------------------------------------------------
test_ann3("x*y+y*z+z*x");    OK.

6/9 (Fri)
Sminimal の実装に相変わらず苦労してます.
Sevilla でいろいろと直した結果,
Sminimal はうまくうごけば正しい答えをだしてるみたいですが
(D<h> : homogenized Weyl で ker = im を check してる,
 V-adapted (strict) かどうかの check routing はまだ書いてない),
strategy がうまくうごかなくてとまる場合もあります
( strategy = 2 の sp を計算するのに, strategy 3 の 元を必要と
  したりする場合あり).


strategy は
def Sdegree(f,tower,level) {
  local i,ww, wd;
  /* extern WeightOfSweyl; */
  ww = WeightOfSweyl;
  f = Init(f);
  if (level <= 1) return(StotalDegree(f));
  i = Degree(f,es);
  return(StotalDegree(f)+Sdegree(tower[level-2,i],tower,level-1)); 
}
を用いて, 
      ans_at_each_floor[j] = Sdegree(tower[i,j],tower,i+1)-(i+1)
で計算してます.

いくつか出力をつけておきますので, 検討!!!

例 1:
load["minimal-test.k"];;
a=test_ann3("x^3-y^2*z^2"); 引数の annihilating ideal の laplace 変換の
                            homogenization の resolution.
      weight vector は (-1,-1,-1,1,1,1)

In(4)=sm1_pmat(a[1]);
 [ 
  [   0 次
    [    y*Dy-z*Dz ] 
    [    -2*x*Dx-3*z*Dz+h^2 ] 
    [    2*x*Dy*Dz^2-3*y*Dx^2*h ] 
    [    2*x*Dy^2*Dz-3*z*Dx^2*h ] 
  ]
  [   1 次
    [    3*Dx^2*h , 0 , Dy , -Dz ] 
    [    6*x*Dy*Dz^2-9*y*Dx^2*h , -2*x*Dy*Dz^2+3*y*Dx^2*h , -2*x*Dx-3*y*Dy , 0 ] 
    [    0 , 2*x*Dy^2*Dz-3*z*Dx^2*h , 0 , 2*x*Dx+3*z*Dz ] 
    [    2*x*Dx+3*z*Dz-h^2 , y*Dy-z*Dz , 0 , 0 ] 
    [    2*x*Dy*Dz , 0 , z , -y ] 
  ]
  [  2 次
    [    -2*x*Dx-3*y*Dy-3*z*Dz-6*h^2 , -Dy , -Dz , 3*Dx^2*h , 3*Dy*Dz ] 
    [    3*y*z , z , y , -2*x*Dy*Dz , 2*x*Dx ] 
  ]
 ]
In(5)=

例 2:
load["minimal-test.k"];;
a=test_ann3("x*y+y*z+z*x");
In(6)=sm1_pmat(a[1]);
 [ 
  [  0 次
    [    2*x*Dx+x*Dz-y*Dz+z*Dz+h^2 ] 
    [    -2*y*Dy+x*Dz-y*Dz-z*Dz-h^2 ] 
    [    -2*x*Dy+2*z*Dy+x*Dz-y*Dz+3*z*Dz+h^2 ] 
    [    -2*y*Dx+2*z*Dx-x*Dz+y*Dz+3*z*Dz+h^2 ] 
  ]
  [  1 次
    [    y-z , x-z , -y , x ] 
    [    2*Dy-2*Dz , 2*Dx-2*Dz , 2*Dx+2*Dz , -2*Dy-2*Dz ] 
    [    2*y*Dx-2*z*Dx+x*Dz-y*Dz-3*z*Dz-2*h^2 , 0 , 0 , 2*x*Dx+x*Dz-y*Dz+z*Dz+2*h^2 ] 
    [    2*y*Dy-2*z*Dy+y*Dz-z*Dz+h^2 , 2*x*Dz-y*Dz+2*z*Dz+h^2 , -x*Dz+z*Dz , 2*x*Dy+x*Dz ] 
    [    -2*y*Dy+2*z*Dy+y*Dz-z*Dz , y*Dz-4*z*Dz , -2*y*Dx+2*z*Dx-y*Dz+2*z*Dz , -2*z*Dy+y*Dz-3*z*Dz ] 
  ]
  [  2 次
    [    -2*y*Dx+2*z*Dx-y*Dz+2*z*Dz , x*y-x*z-y*z+z^2 , y-z , y , x+y-z ] 
    [    -6*Dx*Dz-2*Dz^2 , x*Dz+y*Dz-5*z*Dz-4*h^2 , -2*Dy+2*Dz , 2*Dx+2*Dz , 4*Dz ] 
  ]
 ]
In(7)=

例 3:  うまく行かない例:

Example 1:  Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
          v=[[2*x*Dx + 3*y*Dy+6, 0],
             [3*x^2*Dy + 2*y*Dx, 0],
             [0,  x^2+y^2],
             [0,  x*y]];
         a=Sminimal(v);
strategy がおかしいといってとまる. 理由は?
Negative weight vector を使わないときちんと動きます.


DEBUG 出力:
rf= [ 
  [ 
   [   Schreyer frame.
     [    0 , y^3 , 0 , 0 , -x^2 , 0 ] 
     [    0 , 0 , y^2 , 0 , -x , 0 ] 
     [    0 , y , -x , 0 , 0 , 0 ] 
     [    y*h , 0 , 0 , -x , 0 , 0 ] 
     [    0 , 0 , 0 , 3*y*Dy , 0 , -2*Dx ] 
   ]
   [ 
     [    1 , 0 , -y^2 , 0 , 0 ] 
   ]
    [   ] 
  ]
  [ 
    [    2*x*Dx , e_*x^2 , e_*x*y , 2*y*Dx*h , e_*y^3 , 3*y^2*Dy*h ] 
    [    es*y^3 , es^2*y^2 , es*y , y*h , 3*es^3*y*Dy ] 
    [    1 ] 
  ]
  [ 
    [   ] 
   [ 
    [ 
      [    1 , 4 ] 
      [    y^3 , -x^2 ] 
    ]
    [ 
      [    2 , 4 ] 
      [    y^2 , -x ] 
    ]
    [ 
      [    1 , 2 ] 
      [    y , -x ] 
    ]
    [ 
      [    0 , 3 ] 
      [    y*h , -x ] 
    ]
    [ 
      [    3 , 5 ] 
      [    3*y*Dy , -2*Dx ] 
    ]
   ]
   [ 
    [ 
      [    0 , 2 ] 
      [    1 , -y^2 ] 
    ]
   ]
    [   ] 
  ]
  [   resolution すべき 部分加群 e_ は ベクトル成分のマーク.
    [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ] 
  ]
 ]

略
Processing [    1 , 3 ]    Strategy = 2
     1 の 3 番目の spair の reduction を処理中.
     In(7)=reductionTable:
    [[ 1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
                                                   -- これ.
SpairAndReduction:
[    p and bases  , [    [    0 , 3 ]  , [    y*h , -x ]  ]  , [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ]  ] 
0 の 0 番目と 3 番目 の spair を計算して, 0 レベルの gb で reduction.
[ 1 , 1 , 1 , 2 , 2 , 3 ] にあるように, strategy 3 以外は計算ずみ.
( 計算してないものは %[null] となってる. )
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ]   ( 一番下なので, tower はなしよ. )
[    y*h , -es^3*x ] 
[gi, gj] = [    2*x*Dx+3*y*Dy+6*h^2 , 2*y*Dx*h+3*x^2*Dy ] 
1
Reduce the element 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy
by  [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , %[null] ] 
result is [    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , 1 , [    0 , 0 , 0 , 0 , 0 , 0 ]  ] 
vdegree of the original = -1
vdegree of the remainder = -1
[    3*y^2*Dy*h+6*y*h^3-3*x^3*Dy , [    y*h , 0 , 0 , -x , 0 , 0 ]  , 3 , 5 , -1 , -1 ] 

In(11)=freeRes:
[    [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ]  , [    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ]  , [    %[null] ]  ] 
をみればわかるように, SlaScala で, freeRes にこの元が [0,5] に加え
られた.

次に SnextI が SlaScala より呼ばれてこのエラー.
        i = SnextI(reductionTable_tmp,strategy,redundantTable,
                   skel,level,freeRes);
In(22)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
なので, 最後 の 2 が処理されるはずだが,
In(25)=skel[2]:
[    [    [    0 , 2 ]  , [    1 , -y^2 ]  ]  ] 
のように, 0 番目と, 2 番目の spair.
しかし, 
In(26)=bases:
[    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ] 
のように, 0 番目は strategy 3 なので, まだもとまっていない.

reductionTable_tmp=[    2 ] 
See also reductionTable, strategy, level,i
ERROR(sm): error operator : SnextI: bases[i] or bases[j] is null for all combinations.
--- Engine error or interrupt : In function : Error of class PrimitiveObject

Type in Cleards() to exit the debug mode and Where() to see the stack trace.
In(7)=reductionTable:
[    [    1 , 1 , 1 , 2 , 2 , 3 ]  , [    3 , 2 , 1 , 2 , 3 ]  , [    2 ]  ] 
In(8)=strategy:
2
In(9)=level:
2
この時点まででもとまった basis
 [ 
   [    2*x*Dx+3*y*Dy+6*h^2 , e_*x^2+e_*y^2 , e_*x*y , 2*y*Dx*h+3*x^2*Dy , e_*y^3 , 3*y^2*Dy*h+6*y*h^3-3*x^3*Dy ] 
   [    %[null] , [    0 , 0 , y^2 , 0 , -x , 0 ]  , [    0 , -y , x , 0 , 1 , 0 ]  , [    -y*h , 0 , 0 , x , 0 , 1 ]  , %[null] ] 
   [    %[null] ] 
 ]

-------------------------------------

Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
a=Sminimal([x^2+y^2,x*y]);
これでも似たようなエラーをだせる.
この方が debug しやすい:
Sweyl("x,y",[["x",-1,"y",-1,"Dx",1,"Dy",1]]);
a=Sminimal([x*y,x^2+y^2]);
ではエラーがでないのが不思議. 
pruneZero が動いてないのが変.

rf= [ 
  [ 
   [ 
     [    y^3 , 0 , -x^2 ] 
     [    0 , y^2 , -x ] 
     [    y , -x , 0 ] 
   ]
   [ 
     [    1 , 0 , -y^2 ] 
   ]
    [   ] 
  ]
  [ 
    [    x^2 , x*y , y^3 ] 
    [    y^3 , es*y^2 , y ] 
    [    1 ] 
  ]
  [ 
    [   ] 
   [ 
    [ 
      [    0 , 2 ] 
      [    y^3 , -x^2 ] 
    ]
    [ 
      [    1 , 2 ] 
      [    y^2 , -x ] 
    ]
    [ 
      [    0 , 1 ] 
      [    y , -x ] 
    ]
   ]
   [ 
    [ 
      [    0 , 2 ] 
      [    1 , -y^2 ] 
    ]
   ]
    [   ] 
  ]
  [ 
    [    x^2+y^2 , x*y , y^3 ] 
  ]
 ]
[    0 , 0 ] 
Processing [    0 , 0 ]    Strategy = 1
[    0 , 1 ] 
Processing [    0 , 1 ]    Strategy = 1
[    1 , 2 ] 
Processing [    1 , 2 ]    Strategy = 1
SpairAndReduction:
[    p and bases  , [    [    0 , 1 ]  , [    y , -x ]  ]  , [    x^2+y^2 , x*y , %[null] ]  ] 
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ] 
[    y , -es*x ] 
[gi, gj] = [    x^2+y^2 , x*y ] 
1
Reduce the element y^3
by  [    x^2+y^2 , x*y , %[null] ] 
result is [    y^3 , 1 , [    0 , 0 , 0 ]  ] 
vdegree of the original = -3
vdegree of the remainder = -3
[    y^3 , [    y , -x , 0 ]  , 2 , 2 , -3 , -3 ] 
[    0 , 2 ] 
Processing [    0 , 2 ]    Strategy = 2
[    1 , 1 ] 
Processing [    1 , 1 ]    Strategy = 2
SpairAndReduction:
[    p and bases  , [    [    1 , 2 ]  , [    y^2 , -x ]  ]  , [    x^2+y^2 , x*y , y^3 ]  ] 
[    level= , 1 ] 
[    tower2= , [    [   ]  ]  ] 
[    es*y^2 , -es^2*x ] 
[gi, gj] = [    x*y , y^3 ] 
1
Reduce the element 0
by  [    x^2+y^2 , x*y , y^3 ] 
result is [    0 , 1 , [    0 , 0 , 0 ]  ] 
vdegree of the original = -4
vdegree of the remainder = %[null]
[    0 , [    0 , y^2 , -x ]  , 1 , -1 , -4 , %[null] ] 
reductionTable_tmp=[    2 ] 
See also reductionTable, strategy, level,i
ERROR(sm): error operator : SnextI: bases[i] or bases[j] is null for all combinations.
--- Engine error or interrupt : In function : Error of class PrimitiveObject

Type in Cleards() to exit the debug mode and Where() to see the stack trace.
In(10)=reductionTable :
[    [    1 , 1 , 2 ]  , [    3 , 2 , 1 ]  , [    2 ]  ] 
In(11)=bases:
[    %[null] , [    0 , y^2 , -x ]  , [    -y , x , 1 ]  ] 
In(12)=  これは, [3, 2, 1]  の元のうち, 2,1 がもとまっている.
最後の [ 2 ] の計算に 0 番目が必要でこれがまだない.
要するに 1 番目と 3 番目を消す operator [1, 0, -y^2]
     [    y^3 , 0 , -x^2 ] 
     [    0 , y^2 , -x ] 
     [    y , -x , 0 ] 
の reduction が必要.

-----------------------------------------
June 11, 2000 (Tue),  20:05
V-strict かどうかをチェックする関数を書きたい.
安全に ring (schreyer order) を定義する関数が欲しい.
安全に parse する関数も欲しい.
ベクトルと es 表現の変換関数もいる.

AvoidTheSameRing == 1 なら, schreyer の gbList も変更できないように
すべきか？
関連変数:
needWarningForAvoidTheSameRing
isTheSameRing() :  ring が同じか check. pointer でなく中身までみる.
see poly4.c.  ここのコメントは参考になる.
3.If Schreyer = 1, then the system always generates a new ring.

define_ring に gbList も渡せるの?
==> set_up_ring@ を見る. grep set_up_ring ==>
primitive.c  KsetUpRing() grep KsetUpRing ==>
keyword gbListTower が使えるが, list で与えないといけない.
list に変換するのは, (list) dc.

tparse の必要なわけ?
?? おもいだせない.

ring_def で ring (schreyer order) を定義すると, 計算のときの
order も tower でやってくれるの?
多分 NO.
grep ppAdd *.c ==>
poly2.c  
  checkRing(f,g);

  while (f != POLYNULL && g != POLYNULL) {
    /*printf("%s + %s\n",POLYToString(f,'*',1),POLYToString(g,'*',1));*/
    checkRing2(f,g); /* for debug */
    gt = (*mmLarger)(f,g);

   mmLarger は変えてないように見える.  checkRing はマクロ.

mmLarger_tower は
  if (!(f->m->ringp->schreyer) || !(g->m->ringp->schreyer))
    return(mmLarger_matrix(f,g));
となってるので mmLarger_tower を default にしておけば心配ないように見える.

ring_def は正しく動く?

TODO:
関数の仕様:   ( new.sm1 または complex.sm1 においとく )
  mmLarger は tower に変えてしまう.
  変数名, weight vector, シフトベクトル m を与えると ring (with schreyer order)
  を作る.   ==> weyl<m>,  weyl
  parser はとくに作る必要がないように見えるが...(tparse) ==> name
  ベクトル <---> es 表現  cf. toVectors, [(toe_)  f] gbext ==> name
  適切な homogenization 関数 ==> homogenize<m>
  ord_w の schreyer 版       ==> ord_w<m> 
  init  の schreyer 版       ==> init<m>
  gb_h, syz_h の対応版       ==> [ ii vv ww m] syz_h
  resolution から shift vector を計算する関数.

  結果の check をする assert 関数も必要.  

上の シフトベクトル対応版の関数は当分 new.sm1 へ. そのあと complex.sm1 へ.

cohom.sm1 の interface 関数は cohom.k へ.
Help key word は (Cohom.deRham) みたいに, . でくぎって書く.

----------------------
エラーの原因がようやくわかる:  June 14, 19:00
Schreyer frame の段階で syz に 1 があると strategy が
はたらかない.

test13()  GKZ の minimal free resolution.  2 度実行すると変.
grade が変更されると, 変なことがおきるので,
ScheckIfSchreyer() 関数で, これを scheck することにした.
  sm1(" (report) (mmLarger) switch_function /ss set ");
はまだやめとく. matrix になってるので.

------------------------------------------
June 15, 2000
TODO:  
1.if (IdenfityIntegerAndUniversalNumber)  のとき --- default
  lt, gt, eq で integer と universalNumber の比較ができるようにする.
  rational との比較も可能にする.
  
2. sm1_push_int0 に対応することを, sm1 の側でやる.
     マクロ名  obj to_int --> Done.
     weight_vector の universalNumber ==> まだ. エラーをださないのがこわい.
     s_weight_vector
     weightv
     ord_w
     toVectors
     define_ring
     init
     gkz

-------------
Schreyer skelton がどうして 1 を要素にもつかしらべる.
