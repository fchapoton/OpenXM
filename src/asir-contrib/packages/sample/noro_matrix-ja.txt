/* noro_matrix.rr の利用例　
   以下入力行は tab から始まる.
*/

/*********************/

例1.   プログラムのロード

	load("noro_matrix.rr");

結果.

なし

結果の説明.

	以下の関数を用いる際に必要.

/*********************/

例2.   単位行列を生成する.

	E=linalg.unit_mat(3);   	   

結果.

	[ 1 0 0 0 0 ]
	[ 0 1 0 0 0 ]
	[ 0 0 1 0 0 ]
	[ 0 0 0 1 0 ]
	[ 0 0 0 0 1 ]

結果の説明.

	指定されたサイズの単位行列を返す.


/*********************/

例3.   行列をランダムに生成する.

	R=linalg.random_rmat(3,4,5);

結果.

	[ -4 -3 2 0 ]
	[ -4 -2 -3 0 ]
	[ -2 3 -3 3 ]

結果の説明.

	第一, 第二引数はサイズ, 各要素は絶対値が(第三引数-1)の整数である.

/*********************/

例4. 逆行列を計算する.

	A=linalg.random_mat(3,3,5);
	Inv=invmat(A);
	AI=Inv[0]/Inv[1];
	M=A*AI;

結果.

	A=	[ 2 0 0 0 ]
  		[ 3 5 1 0 ]
  		[ -9 -9 -1 0 ]
  		[ -5 0 0 1 ]

	Inv=[
		[ 4 0 0 0 ]
     	[ -6 -2 -2 0 ]
     	[ 18 18 10 0 ]
     	[ 20 0 0 8 ],8]


	AI=	[ 1/2 0 0 0 ]
   		[ -3/4 -1/4 -1/4 0 ]
   		[ 9/4 9/4 5/4 0 ]
   		[ 5/2 0 0 1 ]

	M=	[ 1 0 0 0 ]
  		[ 0 1 0 0 ]
  		[ 0 0 1 0 ]
  		[ 0 0 0 1 ]

結果の説明.

	結果は [Num,Den] の形のリストで, Num は整数行列, Den は整数である.
	Num/Den が逆行列を表す.

/*********************/

例5.  行列の最小多項式を計算する.

	A=linalg.random_rmat(3,3,5);
	M=linalg.minipoly_mat(A);

結果.

	A=	[ -4 3 3 ]
  		[ 1 2 3 ]
  		[ 0 4 -3 ]

	M=x^3+5*x^2-17*x-93

結果の説明.

	f(A)=0 となる最小次数の多項式 f(x) を返す. deg(f) が A のサイズ
	より小さいこともあり得る.

/*********************/

例6.   行列Aの核を計算する.

	A=linalg.random_rmat(3,5,5);
	Ker=linalg.compute_kernel(A);

結果.

	A=	[ 4 -3 -4 -4 -4 ]
  		[ 3 3 0 -1 3 ]
  		[ -3 -3 0 1 -3 ]

	Ker=[[[ 2 0 0 3 -1 ],0],[[ 0 16 0 3 -15 ],1],[[ 0 0 4 -3 -1 ],2]]

結果の説明.

	[[v1,p1],[v2,p2],...] の形のリストが返る. vi はサイズが A の列数と等し
	いベクトルで, [v1,v2,...] が Ker(A) の一組の基底である. pi は vi の要素
	を左からみて, 最初の 0 でない要素の位置を示す. 最も左を 0 とする.

/*********************/

例7.   行列の像を計算する.

	A=linalg.random_rmat(3,5,5);
	Im=linalg.compute_image(A);

結果.

	A=	[ 1 1 1 -1 4 ]
  		[ -3 3 2 -4 -3 ]
  		[ 3 3 0 1 4 ]

	Im=[[[ 1 -3 3 ],0,(1)*<<0>>],
    	[[ 0 6 0 ],1,(1)*<<1>>+(-1)*<<0>>],
    	[[ 0 0 -18 ],2,(6)*<<2>>+(-5)*<<1>>+(-1)*<<0>>]]

結果の説明.

	[[v1,p1,g1],[v2,p2,g2],...] の形のリストを返す. vi はベクトルで
	[v1,v2,...] が Im(A) の一組の基底である.  pi は vi の要素を左からみて, 
	最初の 0 でない要素の位置を示す. 最も左を 0 とする. gi は, vi が
	もとの行列の列からどのように生成されているかを示す分散多項式である.
	例えば上の例では, [0 6 0] は (第 1 列-第 0 列) に等しいことが分かる.

/*********************/

例8.   行列AのJordan 標準形を計算する.

	A=newmat(4,4,[[2,0,0,0],[3,5,1,0],[-9,-9,-1,0],[-5,0,0,1]]);
	B=linalg.jordan_canonical_form(A);
	P=B[0];
	L=invmat(P); PI=L[0]/L[1];
	S=PI*A*P;

結果.

	B=[
		[ 0 1 1 0 ]
		[ 3 0 0 0 ]
		[ -9 0 -3 0 ]
		[ 0 -5 -5 1 ],
		[[2,2,1],[2,1,1],[1,1,1]],[]]

	S=	[ 2 1 0 0 ]
  		[ 0 2 0 0 ]
  		[ 0 0 2 0 ]
  		[ 0 0 0 1 ]

結果の説明.

	結果は [P,[[e1,m1,j1],[e2,m2,j2],...],DefiningIdeal] の形のリストである.
	P は変換行列, すなわち P^(-1)AP が Jordan 標準形になる行列を表す.
	次の要素は Jordan 標準形を構成する Jordan ブロックのリストである.
	[ei,mi,ji] は, 固有値 ei, サイズ mi の Jordan ブロックが ji 個あること
	を示す. 得られた P により計算すると, 確かにそうなっていることが上の
	例で分かる. 一般には, 固有値は代数的数となる. この場合, 固有値を
	表す不定元が必要なだけ生成され, 一般固有ベクトル (P の列ベクトル)
	はそれらで表現される. DefiningIdeal はそれらの不定元を定義する
	イデアルである.
