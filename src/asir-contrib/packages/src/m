/*&jp \documentclass{jarticle}
\begin{document}
*/
/*$OpenXM: OpenXM/src/asir-contrib/packages/src/m,v 1.15 2002/10/24 08:25:45 takayama Exp $ */
/* Use oxweave to generate documents on this source code
   Use iso-2022 to write this file. No default use of GL and GR is allowed.
*/

M_proc = -1$
#define M_FIND_PROC(P)  P = getopt(proc);\
                          if (type(P) == -1) {\
                             P = m_find_proc();\
                          }

def m_find_proc() {
  extern M_proc;
  if (M_proc == -1) {
     A = ox_get_serverinfo();
     /* Look for ox_math. Not yet written */
     /* Start ox_math automatically if there is not ox_sm1 */
     M_proc = m_start();
  }
  return(M_proc);
}


/*&C-texi
@c DO NOT EDIT THIS FILE   oxmath.texi  It is automatically generated
@c from asir99/lib/contrib/packages/src/m
@node Mathematica Functions,,, Top
*/
/*&jp-texi
@chapter Mathematica 函数

この節では Mathematica の ox サーバ @code{ox_math}
とのインタフェース関数を解説する.
これらの関数はファイル  @file{m} で定義されているのでこのファイルを
@code{load("m")$} でこのファイルをロードしてから使用しないといけない.
@file{m} は @file{$(OpenXM_HOME)/lib/asir-contrib} にある.

注意: @code{ox_reset} は動かない.
*/
/*&eg-texi
@chapter Mathematica Functions

This chapter describes  interface functions for
Mathematica ox server @code{ox_math}.
These interface functions are defined in the file @file{m}.
You need to load the file before using the interface functions.
by the command @code{load("m")$}.
The file @file{m} is at @file{$(OpenXM_HOME)/lib/asir-contrib}.

Note: @code{ox_reset} does not work.
*/
/*&C-texi
@example
@include opening.texi
[258] load("m")$
m Version 19991113. m_start, m_tree_to_string, m_N_Eigenvalues
[259] m_start();
ox_math has started.
ox_math: Portions copyright 2000 Wolfram Research, Inc. 
See OpenXM/Copyright/Copyright.mathlink  for details.
0
[260] m_N_Eigenvalues([[1,2],[4,5]]);
[-0.464102,6.4641]
@end example
*/

/*&C-texi
@noindent
@code{Mathematica} is the trade mark of Wolfram Research Inc.
This package requires Mathmatica Version 3.0, so you need
Mathematica to make this package work.
See @code{http://www.wolfram.com}.
The copyright and license agreement of the mathlink is put at 
@code{OpenXM/Copyright/Copyright.mathlink}
Note that the licence prohibits to connect to a mathematica
kernel via the internet.

@noindent
Author of @code{ox_math}: Katsuyoshi Ohara,  
@code{ohara@@air.s.kanazawa-u.ac.jp}.
*/


load("xm")$
print("m Version 19991113. m_start, m_tree_to_string, m_N_Eigenvalues")$

#define LIST   4
#define VECTOR 5
#define MATRIX 6

/*&jp
  {\tt OpenXM\_HOME} の値を見て {\tt ox\_math} の場所を設定.
  {\tt OpenXM\_HOME} の値がない場合は {\tt /usr/local/OpenXM}
*/ 
/*&eg
  Look up the value of 
  {\tt OpenXM\_HOME} and  determine the place of {\tt ox\_math}.
  If this environmental variable is not set, use the default directory
  {\tt /usr/local/OpenXM}.
*/

Ox_math_lib = ox_getenv("OpenXM_HOME")$
if (Ox_math_lib == 0) {
  Ox_math_lib = "/usr/local/OpenXM/src/ox_math"$
} else {
  Ox_math_lib = Ox_math_lib+"/src/ox_math"$
}

/*&jp
  {\tt m\_start()} は {\tt ox\_math} を localhost で起動するための関数.
  {\tt Xm\_noX} の値が 1 だと, X 無しで起動する.
*/
/*&jp-texi
@section 函数一覧
*/ 
/*&eg-texi
@section Functions
*/ 
/*&jp-texi
@menu
* m_start::
@end menu
@node m_start,,, Mathematica Functions
@subsection @code{m_start}
@findex m_start
@table @t
@item m_start()
::  Localhost で @code{ox_math} を起動する.
@end table

@table @var
@item return
整数
@end table

@itemize @bullet
@item Localhost で @code{ox_math} を起動する.
    起動された @code{ox_math} の識別番号を戻す.
@item @code{Xm_noX =1} としておくと, @code{ox_math} 用の debug window が開かない.
@item 識別番号は @code{M_proc} に格納される.
@end itemize
*/
/*&eg-texi
@menu
* m_start::
@end menu
@node m_start,,, Mathematica Functions
@subsection @code{m_start}
@findex m_start
@table @t
@item m_start()
::  Start  @code{ox_math} on the localhost.
@end table

@table @var
@item return
Integer
@end table

@itemize @bullet
@item Start @code{ox_math} on the localhost.
    It returns the descriptor of @code{ox_math}.
@item Set @code{Xm_noX = 1} to start @code{ox_math} without a debug window.
@item The descriptor is stored in the variable @code{M_proc}.
@end itemize
*/
/*&C-texi
@example
P = m_start()
@end example
*/
/*&jp-texi
@table @t
@item 参照
@code{ox_launch}
@end table
*/
/*&eg-texi
@table @t
@item Reference
@code{ox_launch}
@end table
*/
def m_start_org() {
 extern Ox_math_lib;
 extern Xm_noX;
 extern M_proc;
 if (Xm_noX) {
   P = ox_launch_nox(0,Ox_math_lib+"/ox_math");
 }else{
   P = ox_launch(0,Ox_math_lib+"/ox_math");
 }
 /* ox_check_errors(P); */
 M_proc = P;
 print("ox_math has started.");
 print("ox_math: Portions copyright 2000 Wolfram Research, Inc. ");
 print("See OpenXM/Copyright/Copyright.mathlink for details.");
 return(P);
}

def m_start() {
  extern Xm_unix;
  print("Starting ox_math.");
  print("ox_math: Portions copyright 2000 Wolfram Research, Inc. ");
  print("See OpenXM/Copyright/Copyright.mathlink for details.");
  if (ox_ostype()[0] == "windows" && Xm_unix == 0) 
    return m_start_windows(0);
  else
    return m_start_unix();
}

def m_start_unix() {
 extern Ox_math_lib;
 extern Xm_noX;
 extern M_proc;
 if (Xm_noX) {
   P = ox_launch_nox(0,Ox_math_lib+"/ox_math");
 }else{
   P = ox_launch(0,Ox_math_lib+"/ox_math");
 }
 if (Xm_noX) {
   sm1(P," oxNoX ");
 }
 /* ox_check_errors(P); */
 M_proc = P;
 return(P);
}

def m_start_windows(U) {
  extern Ox_math_lib;
  extern Xm_noX;
  extern M_proc;
  extern Xm_use_timer_to_start_server;

  CPort = generate_port();
  SPort = generate_port();
 
  if (U) {  /* Test on unix. */
    Com = "ox -ox " + Ox_math_lib+"/ox_math " +
          " -data "+ rtostr(SPort) +" -control "+ rtostr(CPort);
    Com = "oxlog xterm -iconic -T ox_math -n ox_math -e "+ Com + "& ";
  }else{
    /* OpenXM_HOME_WIN="c:\\cygwin\\home\\nobuki\\OpenXM";
       OpenXM_HOME_WIN2="/home/nobuki/OpenXM";
       OpenXM_START_EXE = "c:/windows/command/start";
    */
    OpenXM_HOME_WIN = ox_getenv("OpenXM_HOME_WIN");
    OpenXM_START_EXE = ox_getenv("OpenXM_START_EXE");
    Ox_math_lib = OpenXM_HOME_WIN;
    Ox_sm1_forAsir = OpenXM_HOME_WIN+"\\bin\\ox_math.exe"; 
    F = open_file(Ox_sm1_forAsir);
    if (F < 0) {
      error("ox_math.exe is not existing.  Check your installation.");
      return(-1);
    }
    close_file(F);
    Com = OpenXM_HOME_WIN+"\\bin\\ox -ox " + 
          Ox_sm1_forAsir + " " +
          " -data "+ rtostr(SPort) +" -control "+ rtostr(CPort);
    Com = OpenXM_START_EXE+" /MIN "+Com ;
  }

  print(Com +"\n");
  shell(Com);
  if (Xm_use_timer_to_start_server) {
    print("Waiting for 3 seconds."); sleep(3000); 
  }else{
    purge_stdin(); print("Type in Return to connect to the server.");
    get_line();
  }
  print("Trying to connect to the server...",0)$
  CSocket = try_connect("localhost",CPort);
  SSocket = try_connect("localhost",SPort);
  P = register_server(CSocket,CPort,SSocket,SPort);
  print(" Done.");

 if (Xm_noX) {
   sm1(P," oxNoX ");
 }
 /* ox_check_errors(P); */
 M_proc = P;
 return(P);
}


/*&jp
  以下でMathematica を呼ぶための補助関数を定義する.
*/

/*&jp-texi
@menu
* m_tree_to_string::
@end menu
@node m_tree_to_string,,, Mathematica Functions
@subsection @code{m_tree_to_string}
@findex m_tree_to_string
@table @t
@item m_tree_to_string(@var{t})
::  ox_math の戻す Mathematica の木構造データ @var{t} を @code{asir} 形式に
なおす.
@end table

@table @var
@item return
文字列
@item t
リスト
@end table
@itemize @bullet
@item 
t は @code{ox_math} の戻す Mathematica の木構造データ.
@item 
ox_math の戻す Mathematica の木構造データ @var{t} を @code{asir} 形式に
なおす.
@item
   @var{t} をなるべく asir が理解できる形での, 前置または中置記法
   の文字列に変換する. 
   @var{t}の先頭要素の文字列がキーワードであるが, その文字が変換テーブルにない
   ときは, @code{m_} をキーワードの先頭につけて, 関数呼出形式の文字列へ
   かえる.
@end itemize
*/
/*&eg-texi
@menu
* m_tree_to_string::
@end menu
@node m_tree_to_string,,, Mathematica Functions
@subsection @code{m_tree_to_string}
@findex m_tree_to_string
@table @t
@item m_tree_to_string(@var{t})
::  translates Mathematica tree data  @var{t} into a string that can 
be understandable by @code{asir} as far as possible.
@end table

@table @var
@item return
String
@item t
List
@end table
@itemize @bullet
@item 
t is a Mathematica tree data which is generated by @code{ox_math}.
@item 
This function
 translates Mathematica tree data  @var{t} into a string that may 
be understandable by @code{asir}.
@item
   This function translates @var{t} into a prefix or infix expression that may be understantable by @code{asir}.
   The first element of the list @var{t}
  is a key word string of the Mathematica object.
  If this function recognizes the key word, it translates @code{t} into
  the form that can be understandable by @code{asir}.
  If it cannot recognizes the key word, it translates @code{t} into
  a function call with the function name
  @code{m_(the key word)}.
@end itemize
*/
/*&C-texi
@example
[267] m_start();
0
[268] ox_execute_string(0,"Expand[(x-1)^2]");
0
[269] A=ox_pop_cmo(0);  
[Plus,1,[Times,-2,x],[Power,x,2]]
[270] m_tree_to_string(A);
(1)+((-2)*(x))+((x)^(2))
[271] eval_str(@@);
x^2-2*x+1
@end example
*/
/*&C-texi
@example
[259] m_tree_to_string(["List",1,2]);
[1 , 2]
[260] m_tree_to_string(["Plus",2,3]);
(2)+(3)
[261] m_tree_to_string(["Complex",2.3,4.55]);
m_Complex(2.3 , 4.55)
[362] m_tree_to_string(["Plus",["Complex",1.2,3.5],1/2]);
(m_Complex(1.2 , 3.5))+(1/2)
[380] eval_str(@@);
(1.7+3.5*@i)
@end example
*/
/*&jp-texi
@table @t
@item 参照
@code{ox_pop_cmo}, @code{eval_str}, @code{m_rtostr}
@end table
*/
/*&eg-texi
@table @t
@item Reference
@code{ox_pop_cmo}, @code{eval_str}, @code{m_rtostr}
@end table
*/
/*&jp 
  {\tt m\_tree\_to\_string(L)} は, {\tt MathLink} の 木形式で与えれた
  オブジエェクトをなるべく asir が理解できる形での, 前置または中置記法
   の文字列に変換する. \\
   例: {\tt m\_tree\_to\_string(["Plus",1,2])} は文字列
       {\tt 1+2} を戻す. \\
   リストの先頭の文字列がキーワードであるが, その文字が変換テーブルにない
   ときは, {\tt m\_} をキーワードの先頭につけて, 関数呼出形式の文字列へ
   変える.
*/
def m_tree_to_string(L) {
  if (type(L) != LIST) {
     return(rtostr(L));
  }
  N = length(L);
  if (N == 0) return(" ");
  Infix = 0; Prefix = 0;
  if (L[0] == "Plus") {
    Infix = "+";
  }else if (L[0] == "Times") {
    Infix = "*";
  }else if (L[0] == "Power") {
    Infix = "^";
  }else if (L[0] == "Rational") {
    Infix = "/";
  }else if (L[0] == "List") {
    Prefix = "List";
  }else if (L[0] == "Square") {
    Prefix = "sqrt";
  }else if (L[0] == "Sin") {
    Prefix = "sin";
  }else if (L[0] == "Cos") {
    Prefix = "cos";
  }
  if (type(Infix) != 0) {
    Ans = "("+m_tree_to_string(L[1])+")";
    for (I=2; I<N; I++) {
      Ans = Ans+Infix+"("+m_tree_to_string(L[I])+")";
    }
    return(Ans);
  }else if (type(Prefix) != 0) {
    if (Prefix == "List") {
      Ans = "[";
    }else{
      Ans = Prefix + "(";
    }
    for (I=1; I<N; I++) {
      if (I == 1) {
        Ans = Ans +m_tree_to_string(L[I]);
      }else{
        Ans = Ans +" , "+m_tree_to_string(L[I]);
      }
    }
    if (Prefix == "List") {
      return(Ans+"]");
    }else{
      return(Ans+")");
    }
  }else{
    Ans = "m_"+rtostr(L[0])+"(";
    for (I=1; I<N; I++) {
      if (I == 1) {
         Ans = Ans +m_tree_to_string(L[I]);
      }else{
         Ans = Ans +" , "+m_tree_to_string(L[I]);
      }
    }
    return(Ans+")");
  }
}



/* Use eval_str() (= ToExpression[] in Mathematica.) to
   translate a string to an object in asir. */
def foo() {
  print(m_tree_to_string(["Plus",1,x,["Times",2,x]]));
  print(m_tree_to_string(["Plus",["Sin",2],x,["Times",2,x]]));
  print(m_tree_to_string(ox_execute_string(0,"Factor[x^10-1]")));
}

/*&jp-texi
@menu
* m_rtostr::
@end menu
@node m_rtostr,,, Mathematica Functions
@subsection @code{m_rtostr}
@findex m_rtostr
@table @t
@item m_rtostr(@var{t})
::  @var{t} をなるべく Mathematica の理解可能な文字列に変える.
@end table

@table @var
@item return
文字列
@item t
オブジェクト
@end table
@itemize @bullet
@item
   @var{t} をなるべく Mathematica が理解できる形の文字列に変換する. 
   たとえば, @code{asir} ではリストを @code{[}, @code{]} で囲むが,
   Mathematica では @code{@{}, @code{@}} で囲む.
   この関数はこの変換をおこなう.
@end itemize
*/
/*&eg-texi
@menu
* m_rtostr::
@end menu
@node m_rtostr,,, Mathematica Functions
@subsection @code{m_rtostr}
@findex m_rtostr
@table @t
@item m_rtostr(@var{t})
::  translate the object @var{t} into a string that can be understandable
by Mathematica as far as possible.
@end table

@table @var
@item return
String
@item t
Object
@end table
@itemize @bullet
@item
 It  translates the object @var{t} into a string that can be understandable
by Mathematica as far as possible.
For example, @code{asir} uses  @code{[}, @code{]} to express a list,
but @code{Mathematica} uses @code{@{}, @code{@}}.
This function makes this sort of translations.
@end itemize
*/
/*&C-texi
@example
[259] m_rtostr([1,2,3]);
{1,2,3}
[260] m_rtostr([[1,x,x^2],[1,y,y^2]]);
@{@{1,x,x^2@},@{1,y,y^2@}@}
@end example
*/
/*&jp-texi
もう一つ例をあげよう.
次の関数 @code{m_Inverse(M)} は @code{ox_math}
をよんで行列 @code{M} の逆行列を計算する関数である.
@code{m_Inverse(M)} は次のように @code{r_tostr(M)} を用いて
asir の行列を Mathematica 形式に変換してから 
@code{ox_execute_string} で Mathematica に逆行列を計算
させている.
*/
/*&eg-texi
Let us see one more example.
The following function @code{m_Inverse(M)} outputs
the inverse matrix of the matrix @code{M} by calling @code{ox_math}.
It translates @code{asir} matrix @code{M} into a Mathematica expression
by @code{r_tostr(M)}
and makes Mathematica compute the inverse matrix of @code{M} by
@code{ox_execute_string}.
*/
/*&C-texi
@example
def m_Inverse(M) @{
  P = 0;
  A = m_rtostr(M);
  ox_execute_string(P,"Inverse["+A+"]");
  B = ox_pop_cmo(B);
  C = m_tree_to_string(B);
  return(eval_str(C));
@}

[269] M=[[1,x,x^2],[1,y,y^2],[1,z,z^2]];
[[1,x,x^2],[1,y,y^2],[1,z,z^2]]
[270] A=m_Inverse(M)$
[271] red(A[0][0]);
(z*y)/(x^2+(-y-z)*x+z*y)
@end example
*/
/*&jp-texi
@table @t
@item 参照
@code{ox_execute_string}, @code{ToExpression}(Mathematica),
@code{m_tree_to_string}
@end table
*/
/*&eg-texi
@table @t
@item Reference
@code{ox_execute_string}, @code{ToExpression}(Mathematica),
@code{m_tree_to_string}
@end table
*/
/*&jp
  関数 \verb+ m_rtostr(L) + は asir 形式のオブジェクト L をなるべく
  Mathematica が理解できる形の文字列に変換する.
  たとえば, リスト, ベクトル, 行列 は asir では {\tt [}, {\tt ]}
  で囲むが, Mathematica では, {\tt \{ }, {\tt \}} で囲む.
  現在のところこの関数はこの変換のみ行なっている. \\
  例:
  {\footnotesize
  \begin{verbatim}
   [262] m_rtostr([1,2,3]);
   {1,2,3}
   [375] A = newvect(3,[x+2,"Hello",[1/2,3]]);
   [ x+2 Hello [1/2,3] ]
   [376] m_rtostr(A);
   {x+2,Hello,{1/2,3}}
  \end{verbatim}
  }
*/
def m_rtostr(L) {
  if (type(L) != LIST && type(L) != VECTOR && type(L) != MATRIX) {
    return(rtostr(L));
  }
  if (type(L) == VECTOR) {
    N = size(L)[0];
  }else if (type(L) == MATRIX) {
    N = size(L)[0];
  }else{
    N = length(L);
  }
  Ans ="{";
  for (I=0; I<N; I++) {
    if (I==0) {
      Ans = Ans + m_rtostr(L[I]);
    }else{
      Ans = Ans +","+m_rtostr(L[I]);
    }
  }
  Ans = Ans + "}";
  return(Ans);
}

def m_Complex(A,B) {
  return(A+B*@i);
}

/*&jp
  \verb m_N_Eigenvalues(M) + は行列 {\tt M} の固有値の数値近似を Mathematica
  を利用して求める関数です.
*/
/*&eg
  The function \verb m_N_Eigenvalues(M) + returns numerical approximations
  of the eigenvalues of the matrix  {\tt M} by calling Mathematica.
*/
/*&C
  \begin{verbatim}
   [360] m_N_Eigenvalues([[1,2],[3,5]]);
   [-0.162278,6.16228]
   [466]  m_N_Eigenvalues([[0,1],[-1,0]]);
   [(-1*@i),(1*@i)]
  \end{verbatim}
*/
def m_N_Eigenvalues(M) {
  extern M_proc;
  M_FIND_PROC(P)  ;

  A = m_rtostr(M);
  ox_execute_string(P,"N[Eigenvalues["+A+"]]");
  B = ox_pop_cmo(B);
  C = m_tree_to_string(B);
  return(eval_str(C));
}

/*&jp
  \verb m_Inverse(M) + は行列 {\tt M} の逆行列を Mathematica
  を利用して求める関数です.
*/
/*&eg
  The function \verb m_Inverse(M) + returns the inverse matrix of
  {\tt M} by calling Mathematica.
*/
/*&C
  \begin{verbatim}
  [682]  m_Inverse([[x,y],[x+2,x-1]]);
  [[(x-1)/(x^2+(-y-1)*x-2*y),(-y)/(x^2+(-y-1)*x-2*y)],
   [(-x-2)/(x^2+(-y-1)*x-2*y),(x)/(x^2+(-y-1)*x-2*y)]]
  [683] m_Inverse([[1,2],[3,4]]);
  [[-2,1],[3/2,-1/2]]
  \end{verbatim}
*/
def m_Inverse(M) {
  extern M_proc;
  M_FIND_PROC(P)  ;

  A = m_rtostr(M);
  ox_execute_string(P,"Inverse["+A+"]");
  B = ox_pop_cmo(B);
  C = m_tree_to_string(B);
  return(eval_str(C));
}

/*&jp
  次の関数は, random に N X N 実対称行列を S 個乱数を用いて生成して ($M = M^T$), 
  各々の固有値をMathematica で計算します.
  最後に最大固有値の分布状況を答えます.
  (たとえば, [-10,-9] の間に 3 個, [-9,-8] の間に 14 個, ....,
   [9,10] の間に 4 個 など)
  GNUPLOT で分布のヒストグラムも書きます.
  この問題を random matrix の固有値分布の問題といい,
  Selberg 積分, 直交多項式, (Painleve 関数?)などの問題と関連しています.
*/

/* まだ書いてない. */


def m_TeXForm(M) {
  extern M_proc;
  M_FIND_PROC(P)  ;

  A = m_rtostr(M);
  ox_execute_string(P,"ToString[TeXForm["+A+"]]");
  B = ox_pop_cmo(P);
  C = m_tree_to_string(B);
  return C;
}
/* example:
   m_TeXForm("2/x");
   example:
   m_TeXForm((x^2-1)/x);
*/

end$

/*&jp \end{document} */