/* $OpenXM$ */

/*------------------------------------*/
/* Package for differential equations */
/*------------------------------------*/

#define _DEBUG_Diff_ 0
#define _OPTIMIZE_Diff_ 1

/* [[[F,V] DF],...] */
/* DF: vector with vector elements */
/*     [ [F Dv1(F) ... Dv1^N(F)]
         [Dv0(F) Dv1Dv0(F) ... Dv1^(N-1)Dv0(F)]
         ...
         [Dv0^N(F)] ] */

Diff_ActList2 = [ newvect(2,[[x,[x,y]],newvect(1,[newvect(1,[x])])]) ]$

/*---------*/
/* Utility */
/*---------*/
def diff_is_int(N) {
  if (type(N) <= 1) {
    if (dn(N) == 1) {
      return 1;
    }
  }
  return 0;
}

def diff_is_neg_int(N) {
  if (diff_is_int(N) && N < 0) {
    return 1;
  }
  return 0;
}

def diff_is_neg0_int(N) {
  if (diff_is_int(N) && N <= 0) {
    return 1;
  }
  return 0;
}

/*-------------------------------*/
/* In the case of many variables */
/*-------------------------------*/
def diff2_act(L, F, V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  extern Diff_ActList2;
  /* search list. */
  for (I = 0; I < length(Diff_ActList2); I++) {
    if (Diff_ActList2[I][0] == [F, V]) {
      break;
    }
  }
  N = I;
  if (N == length(Diff_ActList2)) {
    /* make Diff_ActList2[N]. */
    Diff_ActList2 = append(Diff_ActList2,
			   [ newvect(2,[[F, V],newvect(1,[newvect(1,[F])])]) ]);
  }
  Table = Diff_ActList2[N];  /* a vetor of size 2 */
  /* calculate order of L. */
  MaxOrd = 0;
  for (I = 0; I < length(L); I++) {
    if (MaxOrd < L[I][1][0] + L[I][1][1]) {
      MaxOrd = L[I][1][0] + L[I][1][1];
    }
  }
  /* if MaxOrd >= length(Diff_ActList2[N][1][0]), extend Diff_ActList2[N][1]. */
  if (MaxOrd >= size(Table[1])[0]) {
    NewTable = newvect(MaxOrd+1);
    for (I = 0; I <= MaxOrd; I++) {
      if (I < size(Table[1])[0]) {
	NewTable[I] = newvect(MaxOrd + 1 - I, vtol(Table[1][I]));
	for (J = size(Table[1][I])[0]; J <= MaxOrd - I; J++) {
	  NewTable[I][J] = red(diff(NewTable[I][J-1], V[1]));
	}
      }
      else {
	NewTable[I] = newvect(MaxOrd + 1 - I, [red(diff(NewTable[I-1][0], V[0]))]);
	for (J = 1; J <= MaxOrd - I; J++) {
	  NewTable[I][J] = red(diff(NewTable[I][J-1], V[1]));
	}
      }
    }
    Table[1] = NewTable;
  }
  /* action L. */
  Lf = 0;
  for (I = length(L) - 1; I >= 0; I--) {
    Df = Table[1][L[I][1][0]][L[I][1][1]];
    Lf += L[I][0]*Df;
    Lf = red(Lf);
  }
  return Lf;
}

/* D: list, [a1,...,an] */
/* F: rational expr */
/* V: list, [x1,...,xn] */
def diff_act_mono(D, F, V) {
  Var = [];
  for (I = 0; I < length(V); I++) {
    for (J = 0; J < D[I]; J++) {
      Var = append(Var, [V[I]]);
    }
  }
  return diff(F, Var);
}

/* L: [ [fa(V),[a1,...,an]],... ] */
/* F: rational expr */
/* V: list, [x1,...,xn] */
/* the return value of this function is reduced by using 'red()'. */
def diff_act(L, F, V) {
#if _OPTIMIZE_Diff_
  if (length(V) == 2) {
    return diff2_act(L, F, V);
  }
#endif

  Lf = 0;
  for (I = 0; I < length(L); I++) {
    Lf += L[I][0]*diff_act_mono(L[I][1], F, V);
  }
  return red(Lf);
}

def diff_acts(L_list, F, V) {
  Lf_list = [];
  for (I = 0; I < length(L_list); I++) {
    Lf_list = append(Lf_list, [diff_act(L_list[I], F, V)]);
  }
  return Lf_list;
}

/* Dim: a number of variables */
/* Deg: degree */
def diff_make_basis(Dim, Deg) {
  if(Dim <= 0 || Deg < 0) {
    error("parameter range error.");
  }

  if (Dim == 1) {
    Basis = [];
    for (I = 0; I <= Deg; I++) {
      Basis = append(Basis, [[[I]]]);
    }
    return Basis;
  }

  if (Dim > 1) {
    Basis = [];
    B = diff_make_basis(Dim - 1,Deg);
    for (I = 0; I <= Deg; I++) {
      HBasis = [];
      for (J = 0; J <= I; J++) {
	for (K = 0; K < length(B[J]); K++) {
	  HBasis = append(HBasis, [append(B[J][K], [I - J])]);
	}
      }
      Basis = append(Basis, [HBasis]);
    }
    return Basis;
  }
}

def diff_get_homog(Poly, Deg, V) {
  Basis = diff_make_basis(length(V), Deg);
  HPoly = 0;
  for (I = 0; I < length(Basis[Deg]); I++) {
    Coef = Poly;
    PP = 1;
    for (J = 0; J < length(Basis[Deg][I]); J++) {
      Coef = coef(Coef, Basis[Deg][I][J], V[J]);
      PP *= V[J]^Basis[Deg][I][J];
    }
    HPoly += Coef*PP;
  }
  return HPoly;
}

/* Sol: list, [U, UC] */
/* Value: rat or list */
def diff_assign_uc(Sol,Value) {
  if (type(Value) >= 0 && type(Value) <= 3) {
    U = Sol[0];
    for (I = 0; I < length(Sol[1]); I++) {
      U = subst(U, Sol[1][I], Value);
    }
    return U;
  }
  if (type(Value) == 4) {
    U = Sol[0];
    for (I = 0; I < length(Sol[1]); I++) {
      U = subst(U, Sol[1][I], Value[I]);
    }
    return U;
  }
  error("parameter type error");
}

def diff_rat_solve(L_list, Dn, N, V) {
  /* OK: calculate the degree of U */
  Deg_U = N;
#if _DEBUG_Diff_
  print("Deg_U: ", 0); print(Deg_U);
#endif

  /* OK: make a basis of U */
  Basis_U = diff_make_basis(length(V), Deg_U);
#if _DEBUG_Diff_
  print("Basis_U: ", 0); print(Basis_U);
#endif

  /* OK: make coefficients of U */
  Coef_U = [];
  for (I = 0; I <= Deg_U; I++) {
    HCoef_U = [];
    for (J = 0; J < length(Basis_U[I]); J++) {
      HCoef_U = append(HCoef_U, [uc()]);
    }
    Coef_U = append(Coef_U, [HCoef_U]);
  }
#if _DEBUG_Diff_
  print("Coef_U: ", 0); print(Coef_U);
#endif

  /* OK: make power series U */
  U = 0;
  for (I = 0; I <= Deg_U; I++) {
    for (J = 0; J < length(Basis_U[I]); J++) {
      U += Coef_U[I][J]*dp_dtop(dp_vtoe(mat_ltov(Basis_U[I][J])), V);
    }
  }
#if _DEBUG_Diff_
  print("U: ", 0); print(U);
#endif

  /* OK: calculate Lu_list */
  List = diff_acts(L_list, U/Dn, V);
  Lu_list = [];
  for (I = 0; I < length(List); I++) {
    Lu_list = append(Lu_list, [nm(List[I])]);
  }
#if _DEBUG_Diff_
  print("Lu_list: ", 0); print(Lu_list);
#endif

  /* OK: new version */
  Coef_Lu_list = [];
  for (I = 0; I < length(Lu_list); I++) {
    if ((Dp_Lu = dp_ptod(Lu_list[I], V)) != 0) {
      while (Dp_Lu != 0) {
	Coef_Lu_list = append(Coef_Lu_list, [dp_hc(Dp_Lu)]);
	Dp_Lu -= dp_hm(Dp_Lu);
      }
    }
  }
  if (Coef_Lu_list == []) {
    Coef_Lu_list = [0];
  }
#if _DEBUG_Diff_
  print("Coef_Lu_list: ", 0); print(Coef_Lu_list);
#endif

  /* OK: calculate the size of matrix A and vector X */
  Size_Row = length(Coef_Lu_list);
  Size_Col = fac(length(V) + Deg_U)/(fac(length(V))*fac(Deg_U));
#if _DEBUG_Diff_
  print("Size of A: [", 0);
  print(Size_Row, 0); print(",", 0); print(Size_Col, 0);
  print("]");
#endif

  /* OK: make a vector X */
  X = newvect(Size_Col);
  K = 0;
  for (I = 0; I <= Deg_U; I++) {
    for (J = 0; J < length(Coef_U[I]); J++) {
      X[K] = Coef_U[I][J];
      K++;
    }
  }
#if _DEBUG_Diff_
  print("X: ", 0); print(X);
#endif

  /* OK: make a matrix A */
  A = newmat(Size_Row, Size_Col);
  for (Row = 0; Row < Size_Row; Row++) {
    Coef_Nm = nm(Coef_Lu_list[Row]);
    Coef_Dn = dn(Coef_Lu_list[Row]);
    for (Col = 0; Col < Size_Col; Col++) {
      A[Row][Col] = coef(Coef_Nm, 1, X[Col])/Coef_Dn;
    }
  }
#if _DEBUG_Diff_
  print("A: ", 0); print(A);
#endif

  /* OK: solve A*X = 0 */
  Sol = mat_solve(A, X, newvect(Size_Row));
#if _DEBUG_Diff_
  print("Sol: ", 0); print(Sol);
#endif

  /* OK: assign Sol to U */
  Size_Basis = fac(length(V)+N)/(fac(length(V))*fac(N));
  for (I = 0; I < Size_Col; I++) {
    if (I < Size_Basis) {
      U = subst(U, Sol[I][0], Sol[I][1]);
    }
    else {
      U = subst(U, Sol[I][0], 0);
    }
  }
#if _DEBUG_Diff_
  print("U: ", 0); print(U);
#endif

  /* unknown coefficient */
  Vars_U = vars(U);
  UC = [];
  for (I = 0; I < length(Vars_U); I++) {
    if (vtype(Vars_U[I]) == 1) {
      UC = append(UC, [Vars_U[I]]);
    }
  }
#if _DEBUG_Diff_
  print("UC: ", 0); print(UC);
#endif

  return [red(U/Dn), UC];
}

def diff_poly_solve(L_list, N, V) {
  return diff_rat_solve(L_list, 1, N, V);
}

def diff_pochhammer(A, K) {
  A_K = 1;
  for (I = 0; I < K; I++) {
    A_K *= (A+I);
  }
  return A_K;
}

/*--------------------------*/
/* the case of one variable */
/*--------------------------*/
def diff_op_hg1(A,B,C,V) {
  if (length(V) != 1) {
    error("a length of list V is too long.");
  }
  return [ [ [V[0]*(1-V[0]),[2]],
	     [C-(A+B+1)*V[0],[1]],
	     [-A*B,[0]] ] ];
}

def diff_act_hg1(A,B,C,F,V) {
  return diff_acts(diff_op_hg1(A,B,C,V),F,V);
}

def diff_poly_solve_hg1(A,B,C,N,V) {
  return diff_poly_solve(diff_op_hg1(A,B,C,V),N,V);
}

def diff_poly_solve_hg1s(R_A,R_B,R_C,N,V) {
  Sols = [];
  for (I = R_C[0]; I <= R_C[1]; I += R_C[2]) {
    for (J = R_A[0]; J <= R_A[1]; J += R_A[2]) {
      for (K = R_B[0]; K <= R_B[1]; K += R_B[2]) {
	Sols = append(Sols, [[J,K,I,diff_poly_solve_hg1(J,K,I,N,V)]]);
      }
    }
  }
  return Sols;
}

def diff_poly_solve_hg1_check(Sol,A,B,C,V) {
  L_list = diff_op_hg1(A,B,C,V);
  if (diff_act(L_list[0],Sol[0],V) != 0) {
    return 0;
  }
  return 1;
}

/*---------------------------*/
/* the case of two variables */
/*---------------------------*/
/* appell1 */
def diff_op_appell1(A,B1,B2,C,V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  return [ [ [V[0]*(1-V[0]),[2,0]],
	     [(1-V[0])*V[1],[1,1]],
	     [C-(A+B1+1)*V[0],[1,0]],
	     [-B1*V[1],[0,1]],
	     [-A*B1,[0,0]] ],
	   [ [V[1]*(1-V[1]),[0,2]],
	     [(1-V[1])*V[0],[1,1]],
	     [C-(A+B2+1)*V[1],[0,1]],
	     [-B2*V[0],[1,0]],
	     [-A*B2,[0,0]] ],
	   [ [V[0]-V[1],[1,1]],
	     [-B2,[1,0]],
	     [B1,[0,1]] ] ];
}

def diff_act_appell1(A,B1,B2,C,F,V) {
  return diff_acts(diff_op_appell1(A,B1,B2,C,V),F,V);
}

def diff_poly_solve_appell1(A,B1,B2,C,N,V) {
  return diff_poly_solve(diff_op_appell1(A,B1,B2,C,V),N,V);
}

def diff_poly_solve_appell1_check(Sol,A,B1,B2,C,V) {
  Lf_list = diff_act_appell1(A,B1,B2,C,Sol[0],V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

def diff_poly_solve_appell1s(R_A,R_B1,R_B2,R_C,N,V) {
  Sols = [];
  for (C = R_C[0]; C <= R_C[1]; C += R_C[2]) {
    for (A = R_A[0]; A <= R_A[1]; A += R_A[2]) {
      for (B1 = R_B1[0]; B1 <= R_B1[1]; B1 += R_B1[2]) {
	for (B2 = R_B2[0]; B2 <= R_B2[1]; B2 += R_B2[2]) {
	  Sols = append(Sols, [[A,B1,B2,C,diff_poly_solve_appell1(A,B1,B2,C,N,V)]]);
	}
      }
    }
  }
  return Sols;
}

/* appell2 */
def diff_op_appell2(A,B1,B2,C1,C2,V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  return [ [ [V[0]*(1-V[0]),[2,0]],
	     [-V[0]*V[1],[1,1]],
	     [C1-(A+B1+1)*V[0],[1,0]],
	     [-B1*V[1],[0,1]],
	     [-A*B1,[0,0]] ],
	   [ [V[1]*(1-V[1]),[0,2]],
	     [-V[0]*V[1],[1,1]],
	     [C2-(A+B2+1)*V[1],[0,1]],
	     [-B2*V[0],[1,0]],
	     [-A*B2,[0,0]] ],
	   [ [V[0]*V[1],[2,1]],
	     [-V[0]*V[1],[1,2]],
	     [B2*V[0],[2,0]],
	     [-B1*V[1],[0,2]],
	     [C1*V[1]-C2*V[0],[1,1]],
	     [B2*C1,[1,0]],
	     [-B1*C2,[0,1]] ] ];
}

def diff_act_appell2(A,B1,B2,C1,C2,F,V) {
  return diff_acts(diff_op_appell2(A,B1,B2,C1,C2,V),F,V);
}

def diff_poly_solve_appell2(A,B1,B2,C1,C2,N,V) {
  return diff_poly_solve(diff_op_appell2(A,B1,B2,C1,C2,V),N,V);
}

def diff_poly_solve_appell2_check(Sol,A,B1,B2,C1,C2,V) {
  Lf_list = diff_act_appell2(A,B1,B2,C1,C2,Sol[0],V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

/* appell3 */
def diff_op_appell3(A1,A2,B1,B2,C,V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  return [ [ [V[0]*(1-V[0]),[2,0]],
             [V[1],[1,1]],
             [C-(A1+B1+1)*V[0],[1,0]],
             [-A1*B1,[0,0]] ],
           [ [V[1]*(1-V[1]),[0,2]],
             [V[0],[1,1]],
             [C-(A2+B2+1)*V[1],[0,1]],
             [-A2*B2,[0,0]] ] ];
}

def diff_act_appell3(A1,A2,B1,B2,C,F,V) {
  return diff_acts(diff_op_appell3(A1,A2,B1,B2,C,V),F,V);
}

def diff_poly_solve_appell3(A1,A2,B1,B2,C,N,V) {
  return diff_poly_solve(diff_op_appell3(A1,A2,B1,B2,C,V),N,V);
}

def diff_poly_solve_appell3_check(Sol,A1,A2,B1,B2,C,V) {
  Lf_list = diff_act_appell3(A1,A2,B1,B2,C,Sol[0],V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

/* appell4 */
def diff_pseries_appell4(A,B,C1,C2,N,V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  Basis = diff_make_basis(2, N);
  Pseries = 0;
  for (I = 0; I < length(Basis); I++) {
    for (J = 0; J < length(Basis[I]); J++) {
      A_K = diff_pochhammer(A, Basis[I][J][0] + Basis[I][J][1]);
      B_K = diff_pochhammer(B, Basis[I][J][0] + Basis[I][J][1]);
      C1_M = diff_pochhammer(C1, Basis[I][J][0]);
      C2_N = diff_pochhammer(C2, Basis[I][J][1]);
      Coef = A_K*B_K/(C1_M*C2_N*fac(Basis[I][J][0])*fac(Basis[I][J][1]));
      Pseries += red(Coef)*dp_dtop(dp_vtoe(mat_ltov(Basis[I][J])), V);
    }
  }
  return Pseries;
}

def diff_op_appell4(A,B,C1,C2,V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  return [ [ [V[0]*(1-V[0]),[2,0]],
	     [-2*V[0]*V[1],[1,1]],
	     [-V[1]^2,[0,2]],
	     [(C1-(A+B+1)*V[0]),[1,0]],
	     [-(A+B+1)*V[1],[0,1]],
	     [-A*B,[0,0]] ],
	   [ [V[1]*(1-V[1]),[0,2]],
	     [-2*V[0]*V[1],[1,1]],
	     [-V[0]^2,[2,0]],
	     [(C2-(A+B+1)*V[1]),[0,1]],
	     [-(A+B+1)*V[0],[1,0]],
	     [-A*B,[0,0]] ] ];
}

def diff_act_appell4(A,B,C1,C2,F,V) {
  return diff_acts(diff_op_appell4(A,B,C1,C2,V),F,V);
}

def diff_poly_solve_appell4(A,B,C1,C2,N,V) {
  return diff_poly_solve(diff_op_appell4(A,B,C1,C2,V),N,V);
}

def diff_poly_solve_appell4_check(Sol,A,B,C1,C2,V) {
  Lf_list = diff_act_appell4(A,B,C1,C2,Sol[0],V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

def diff_rat_solve_appell4(A,B,C1,C2,Dn,N,V) {
  return diff_rat_solve(diff_op_appell4(A,B,C1,C2,V),Dn,N,V);
}

/* selberg2 */
def diff_op_selberg2(A,B,C,S,V) {
  if (length(V) != 2) {
    error("a length of list V is wrong.");
  }
  return [ [ [V[0]*(1-V[0])*(V[0]-V[1]),[2,0]],
	     [(C-1/S-(A+B+1-1/S)*V[0])*(V[0]-V[1])+1/S*V[0]*(1-V[0]),[1,0]],
	     [-1/S*V[1]*(1-V[1]),[0,1]],
	     [-A*B*(V[0]-V[1]),[0,0]] ],
	   [ [V[1]*(1-V[1])*(V[1]-V[0]),[0,2]],
	     [(C-1/S-(A+B+1-1/S)*V[1])*(V[1]-V[0])+1/S*V[1]*(1-V[1]),[0,1]],
	     [-1/S*V[0]*(1-V[0]),[1,0]],
	     [-A*B*(V[1]-V[0]),[0,0]] ] ];
}

def diff_act_selberg2(A,B,C,S,F,V) {
  return diff_acts(diff_op_selberg2(A,B,C,S,V),F,V);
}

def diff_poly_solve_selberg2(A,B,C,S,N,V) {
  return diff_poly_solve(diff_op_selberg2(A,B,C,S,V),N,V);
}

def diff_poly_solve_selberg2_check(Sol,A,B,C,S,V) {
  Lf_list = diff_act_selberg2(A,B,C,S,Sol[0],V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

def diff_poly_solve_selberg2s(R_A,R_B,R_C,R_S,N,V) {
  Sols = [];
  for (S = R_S[0]; S <= R_S[1]; S += R_S[2]) {
    if (S != 0) {
      for (C = R_C[0]; C <= R_C[1]; C += R_C[2]) {
	for (A = R_A[0]; A <= R_A[1]; A += R_A[2]) {
	  for (B = R_B[0]; B <= R_B[1]; B += R_B[2]) {
	    Sols = append(Sols, [[A,B,C,S,diff_poly_solve_selberg2(A,B,C,S,N,V)]]);
	  }
	}
      }
    }
  }
  return Sols;
}

def diff_op_selberg2_1(A,B,K1,K2,V) {
  if (A+B+K1+K2+1 == 0) {
    error("A+B+K1+K2+1 == 0");
  }
  return diff_op_selberg2(A,B,A+B+K2+1,1/(A+B+K1+K2+1),V);
}

def diff_act_selberg2_1(A,B,K1,K2,F,V) {
  return diff_acts(diff_op_selberg2_1(A,B,K1,K2,V),F,V);
}

def diff_poly_solve_selberg2_1 (A,B,K1,K2,N,V) {
  return diff_poly_solve(diff_op_selberg2_1(A,B,K1,K2,V),N,V);
}

def diff_poly_solve_selberg2_1_check(Sol,A,B,K1,K2,V) {
  Lf_list = diff_act_selberg2_1(A,B,K1,K2,Sol[0],V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

def diff_poly_solve_selberg2s_1 (R_A,R_B,R_K1,R_K2,N,V) {
  Sols = [];
  for (K1 = R_K1[0]; K1 <= R_K1[1]; K1 += R_K1[2]) {
    for (K2 = R_K2[0]; K2 <= R_K2[1]; K2 += R_K2[2]) {
      for (A = R_A[0]; A <= R_A[1]; A += R_A[2]) {
	for (B = R_B[0]; B <= R_B[1]; B += R_B[2]) {
	  if (A+B+K1+K2+1 != 0) {
	    Sol = diff_poly_solve_selberg2_1(A,B,K1,K2,N,V);
	    if (diff_poly_solve_selberg2_1_check(Sol,A,B,K1,K2,V) == 1) {
	      Sols = append(Sols,[[A,B,K1,K2,Sol]]);
	    }
	  }
	}
      }
    }
  }
  return Sols;
}

def diff_poly_solve_selberg2s_1_half (R_AB,R_K1,R_K2,N,V) {
  Sols = [];
  for (K1 = R_K1[0]; K1 <= R_K1[1]; K1 += R_K1[2]) {
    for (K2 = R_K2[0]; K2 <= R_K2[1]; K2 += R_K2[2]) {
      for (A = R_AB[0]; A <= R_AB[1]; A += R_AB[2]) {
	for (B = R_AB[0]; B <= R_AB[1]; B += R_AB[2]) {
	  if (A <= B && A+B+K1+K2+1 != 0) {
	    Sol = diff_poly_solve_selberg2_1(A,B,K1,K2,N,V);
	    if (diff_poly_solve_selberg2_1_check(Sol,A,B,K1,K2,V) == 1) {
	      Sols = append(Sols,[[A,B,K1,K2,Sol]]);
	    }
	  }
	}
      }
    }
  }
  return Sols;
}

def diff_lookup(X, List) {
  if (type(List) != 4) {
    error("parameter type error.");
  }
  for (I = 0; I < length(List); I++) {
    if (X == List[I]) {
      return 1;
    }
  }
  return 0;
}

/*---------------------------*/
/* GKZ hypergeometric system */
/*---------------------------*/
/* return generators of toric ideal I_{A} */
/* [[u1,v1],[u2,v2],...] <- { x^u1-x^v1, x^u2-x^v2,...} */
def diff_toric_ideal(A) {
  if (type(A) == 6) {
    A = mat_mtol(A);
  }
  if (type(A) != 4) {
    error("parameter type error.");
  }

  A = mat_mtol(mat_trans(A));

  Vx = [];
  for (I = 0; I < length(A); I++) {
    Vx = append(Vx, [strtov("x"+rtostr(I+1))]);
  }
  Vt = [];
  for (I = 0; I < length(A[0]); I++) {
    Vt = append(Vt, [strtov("t"+rtostr(I+1))]);
  }
  Vt0 = [t0];
  V = append(Vt0, Vt);
  V = append(V, Vx);

  Ap = newmat(length(A), length(A[0]));
  Am = newmat(length(A), length(A[0]));
  for (I = 0; I < length(A); I++) {
    for (J = 0; J < length(A[0]); J++) {
      if (A[I][J] > 0) {
	Ap[I][J] = A[I][J];
      }
      else {
	Am[I][J] = -A[I][J];
      }
    }
  }

  FF = [];
  for (I = 0; I < length(Vx); I++) {
    F = Vx[I]*dp_dtop(dp_vtoe(Am[I]), Vt) - dp_dtop(dp_vtoe(Ap[I]), Vt);
    FF = append(FF, [F]);
  }
  F = Vt0[0];
  for (I = 0; I < length(Vt); I++) {
    F *= Vt[I];
  }
  F -= 1;
  FF = append(FF, [F]);
#if _DEBUG_Diff_
  print("FF: ", 0); print(FF);
#endif

  GG = gr(FF, V, 2);
#if _DEBUG_Diff_
  print("V: ", 0); print(V);
  print("GG: ", 0); print(GG);
#endif

  Vt_all = append(Vt0, Vt);
  Toric = [];
  for (I = 0; I < length(GG); I++) {
    Vars = vars(GG[I]);
    Flag = 1;
    for (J = 0; J < length(Vt_all); J++) {
      if (diff_lookup(Vt_all[J], Vars)) {
	Flag = 0;
	break;
      }
    }
    if (Flag == 1) {
      Toric = append(Toric, [GG[I]]);
    }
  }
#if _DEBUG_Diff_
  print("toric ideal: ", 0); print(Toric);
#endif

  Toric_exp = [];
  for (I = 0; I < length(Toric); I++) {
      Dpoly = dp_ptod(Toric[I], Vx);
      if (dp_hc(Dpoly) > 0) {
	Dpoly_p = dp_hm(Dpoly);
	Dpoly_m = Dpoly_p - Dpoly;
      }
      else {
	Dpoly_m = dp_hm(Dpoly);
	Dpoly_p = Dpoly_m - Dpoly;
      }
      Toric_exp = append(Toric_exp, [ [vtol(dp_etov(Dpoly_p)),vtol(dp_etov(Dpoly_m))] ]);
  }

  return Toric_exp;
}

/* A: matrix or list, Elements must be integer. */
/* B: vetor or list */
def diff_op_gkz(A, B, V) {
  if (type(A) == 6) {
    A = mat_mtol(A);
  }
  if (type(B) == 5) {
    B = vtol(B);
  }
  if (type(A) != 4 || type(B) != 4 || type(V) != 4) {
    error("parameter type error.");
  }
  if ( length(A[0]) != length(V) || length(A) != length(B)) {
    error("a length is wrong.");
  }

  L_list = [];
  for (I = 0; I < length(A); I++) {
    L = [];
    for (J = 0; J < length(A[I]); J++) {
      if (A[I][J] != 0) {
	L = append(L, [[A[I][J]*V[J], vtol(dp_etov(dp_ptod(V[J],V)))]]);
      }
    }
    L = append(L, [[-B[I], vtol(dp_etov(dp_ptod(1,V)))]]);
    L_list = append(L_list, [L]);
  }
  /* toric */
  Toric = diff_toric_ideal(A);
  for (I = 0; I < length(Toric); I++) {
    L = [[1,Toric[I][0]],[-1,Toric[I][1]]];
    L_list = append(L_list, [L]);
  }
  return L_list;
}

def diff_act_gkz(A, B, F, V) {
  return diff_acts(diff_op_gkz(A, B, V), F, V);
}

def diff_poly_solve_gkz(A, B, N, V) {
  return diff_poly_solve(diff_op_gkz(A, B, V), N, V);
}

def diff_poly_solve_gkz_check(Sol, A, B, V) {
  Lf_list = diff_act_gkz(A, B, Sol[0], V);
  for (I = 0; I < length(Lf_list); I++) {
    if (Lf_list[I] != 0) {
      return 0;
    }
  }
  return 1;
}

end$
