/* $OpenXM: OpenXM/src/asir-contrib/packages/src/phc,v 1.10 2002/08/11 08:39:49 takayama Exp $ */

Phc_proc = -1$
#define PHC_FIND_PROC(P)  P = getopt(proc);\
                          if (type(P) == -1) {\
                             P = phc_find_proc();\
                          }

def phc_find_proc() {
  extern Phc_proc;
  if (Phc_proc == -1) {
     A = ox_get_serverinfo();
     /* Look for ox_sm1_for_phc. Not yet written */
     /* Start sm1 automatically if there is not ox_sm1 */
     Phc_proc = phc_start();
  }
  return(Phc_proc);
}


/*&C-texi
@c DO NOT EDIT THIS FILE   oxphc.texi
@node PHC Functions,,, Top

*/
/*&jp-texi
@chapter PHC 函数

この節では PHC pack の ox サーバ @code{ox_sm1_phc}
とのインタフェース関数を解説する.
これらの関数はファイル  @file{phc} で定義されている.
@code{phc} は @file{$(OpenXM_HOME)/lib/asir-contrib} にある.
*/
/*&eg-texi
@chapter PHC Functions

This chapter describes  interface functions for
PHC pack ox server @code{ox_sm1_phc}.
These interface functions are defined in the file @file{phc}.
The file @code{phc} is @*
at @file{$(OpenXM_HOME)/lib/asir-contrib}.
*/
/*&C-texi
@example
@include opening.texi
[255] phc_start();
0
[257] phc([x^2+y^2-4,x*y-1]);
The detailed output is in the file tmp.output.*
The answer is in the variable Phc.
0
[260] Phc ;
[[[-0.517638,0],[-1.93185,0]],
[[1.93185,0],[0.517638,0]],
[[-1.93185,0],[-0.517638,0]],
[[0.517638,0],[1.93185,0]]]
[261] 
@end example
*/
/*&C-texi
Author of @code{PHC pack}: Jan Verschelde. @*
*/
/*&jp-texi
参考書 1: Jan Verschelde,
PHCpack: A general-purpose solver for polynomial systems by
homotopy continuation".  ACM Transaction on Mathematical Softwares, 25(2): 
251-276, 1999. @*
参考書 2: Cox, D., O'Shea, Little, J.,  Using Algebraic Geometry,
Springer. Mixed volumes についての章を見よ.
*/
/*&eg-texi
Reference 1: Jan Verschelde,
PHCpack: A general-purpose solver for polynomial systems by
homotopy continuation".  ACM Transaction on Mathematical Softwares, 25(2): 
251-276, 1999. @*
Reference 2: Cox, D., O'Shea, Little, J.,  Using Algebraic Geometry,
Springer. See the chapter on mixed volumes.
*/

/*&C-texi
@menu
* phc_start::
* phc::
@end menu

*/
/*&jp-texi
@section 函数一覧
*/ 
/*&eg-texi
@section Functions
*/ 
/*&jp-texi
@node phc_start,,, PHC Functions
@subsection @code{phc_start}
@findex phc_start
@table @t
@item phc_start()
::  Localhost で @code{ox_sm1_phc} を起動する.
@end table

@table @var
@item return
整数
@end table

@itemize @bullet
@item Localhost で @code{ox_sm1_phc} を起動する.
    起動された @code{ox_sm1_phc} の識別番号を戻す.
@item @code{Xm_noX =1} としておくと, @code{ox_sm1_phc} 用の debug window が開かない.
@item 識別番号は @code{Phc_proc} に格納される.
@end itemize
*/
/*&eg-texi
@node phc_start,,, PHC Functions
@subsection @code{phc_start}
@findex phc_start
@table @t
@item phc_start()
::  Start  @code{ox_sm1_phc} on the localhost.
@end table

@table @var
@item return
Integer
@end table

@itemize @bullet
@item Start @code{ox_sm1_phc} on the localhost.
    It returns the descriptor of @code{ox_sm1_phc}.
@item Set @code{Xm_noX = 1} to start @code{ox_sm1_phc} without a debug window.
@item The descriptor is stored in @code{Phc_proc}.
@end itemize
*/
/*&C-texi
@example
P = phc_start()
@end example
*/
/*&jp-texi
@table @t
@item 参照
@code{ox_launch}, @code{phc}
@end table
*/
/*&eg-texi
@table @t
@item Reference
@code{ox_launch}, @code{phc}
@end table
*/
/* phc */
def phc_start() {
  extern Xm_unix;
  if (ox_ostype()[0] == "windows" && Xm_unix == 0)
    return phc_start_windows(0);
  else
    return phc_start_unix();
}

def phc_start_unix() {
  extern Xm_noX;
  extern Phc_proc;
  extern Sm1_lib;
  if (Xm_noX) {
    P = ox_launch_nox(0,Sm1_lib+"/bin/ox_sm1_phc");
  }else{
    P = ox_launch(0,Sm1_lib+"/bin/ox_sm1_phc"); 
  }
  ox_check_errors(P);
  Phc_proc = P;
  return(P);
}

def phc_start_windows(U) {
  extern Sm1_lib;
  extern Xm_noX;
  extern Phc_proc;
  extern Xm_use_timer_to_start_server;
  extern Xm_debug_on_win_1;

  if (!Xm_debug_on_win_1) {
    error("The component phc has not yet been implemented on Windows(native).");
  }

  CPort = generate_port();
  SPort = generate_port();
 
  if (U) {  /* Test on unix. */
    Com = "ox -ox " + Sm1_lib+"/bin/ox_sm1_phc " +
          " -data "+ rtostr(SPort) +" -control "+ rtostr(CPort);
    Com = "oxlog xterm -iconic -T ox_sm1 -n ox_sm1 -e "+ Com + "& ";
  }else{
    OpenXM_HOME_WIN = ox_getenv("OpenXM_HOME_WIN");
    OpenXM_START_EXE = ox_getenv("OpenXM_START_EXE");
    Sm1_lib = OpenXM_HOME_WIN+"/lib/sm1"; 
    Ox_sm1_forAsir = OpenXM_HOME_WIN+"\\lib\\sm1\\bin\\ox_sm1_phc.exe"; 
    F = open_file(Ox_sm1_forAsir);
    if (F < 0) {
      error("ox_sm1_phc.exe is not existing.  Check your installation.");
      return(-1);
    }
    close_file(F);
    Com = OpenXM_HOME_WIN+"\\bin\\ox -ox " + 
          Ox_sm1_forAsir + " " +
          " -data "+ rtostr(SPort) +" -control "+ rtostr(CPort);
    Com = OpenXM_START_EXE+" /MIN "+Com ;
  }

  print(Com +"\n");
  shell(Com);
  if (Xm_use_timer_to_start_server) {
    print("Waiting for 3 seconds."); sleep(3000); 
  }else{
    purge_stdin(); print("Type in Return to connect to the server.");
    get_line();
  }
  print("Trying to connect to the server...",0)$
  CSocket = try_connect("localhost",CPort);
  SSocket = try_connect("localhost",SPort);
  P = register_server(CSocket,CPort,SSocket,SPort);
  print(" Done.");

 if (Xm_noX) {
   sm1(P," oxNoX ");
 }
 ox_check_errors(P);
 Phc_proc = P;
 return(P);
}


/*&jp-texi
@node phc,,, PHC Functions
@subsection @code{phc}
@findex phc
@table @t
@item phc(@var{s}|proc=@var{p})
::  PHC pack に代数方程式系 @var{s} の解をすべてもとめてくれるように頼む.
@end table

@table @var
@item return
なし
@item p
数
@item s
リスト
@end table

@itemize @bullet
@item
   代数方程式系 @var{S} をホモトピー法で解くために PHC pack を呼ぶ.
    PHC pack を開発したのは Jan Verschelde である.
    オリジナルの配布元は
    @code{www.mth.msu.edu/~jan} である.
    PHC pack は代数方程式系を解くためにいろいろな戦略をえらぶことができるが,
    このインタフェース関数では, black-box solver しか用いていない.
    black-box solver は一般的な戦略ではあるが, 能率的ではない.
    この関数で代数方程式を解くのに失敗したら, オリジナルの PHC pack を用い,
    ほかの戦略を試してみるとよい.
@item
PHC は作業ファイル @code{tmp.phc.out.pid}, @code{tmp.input.*}, 
@code{tmp.output.*} を生成する.
ここで @code{pid} は @code{ox_sm1_phc} のプロセス番号である.
ファイル @code{tmp.output.*} には PHC pack がどのように方程式系を解いたのかの
詳しい情報がはいっている.
@item
変数の数と方程式の数 @code{length(@var{s})} は等しくないといけない.
@end itemize
*/
/*&eg-texi
@node phc,,, PHC Functions
@subsection @code{phc}
@findex phc
@table @t
@item phc(@var{s}|proc=@var{p})
::  Ask PHC pack to find all the roots in the complex torus of the given systems of polynomials @var{s}
@end table

@table @var
@item return
Void
@item p
Number
@item s
List
@end table

@itemize @bullet
@item
 The server calls PHC pack to solve a system of algebraic equations S
    by homotopy methods.
    PHC pack has been developed by Jan Verschelde. See
    @code{www.mth.msu.edu/~jan} for the original distribution.
    The original PHC pack can choose several strategies to solve,
    but our phc interface uses only black-box solver, which is general
    and automatic but is not efficient. So, if you fails by our interface,
    try the other strategies via the original user interface.
@item
phc generates working files  tmp.phc.out.pid, tmp.input.*, tmp.output.*.
    Here, pid the process number of the server.
    The file @code{tmp.output.*} contains details informations on how PCH pack
    solves the system.
@item
The number of variables and the number of equations 
@code{length(@var{s})} must agree.
@end itemize
*/
/*&C-texi

@noindent
Algorithm: 
Jan Verschelde,
PHCpack: A general-purpose solver for polynomial systems by
homotopy continuation".  ACM Transaction on Mathematical Softwares, 25(2): 
251-276, 1999.

@example
[232] P = phc_start();
0
[233] phc([x^2+y^2-4,x*y-1]|proc=P);
The detailed output is in the file tmp.output.*
The answer is in the variable Phc.
0
[234] Phc;
[[[-1.93185,0],[-0.517638,0]],
 [[0.517638,0],[1.93185,0]],
 [[-0.517638,0],[-1.93185,0]],
 [[1.93185,0],[0.517638,0]]]

 [[x=[real, imaginary], y=[real,imaginary]],  the first solution
  [x=[real, imaginary], y=[real,imaginary]],  the second solution
  ...
@end example
*/
/*&jp-texi
@table @t
@item 参照
@code{ox_launch}, @code{phc_start}, @file{$(OpenXM_HOME)/bin/lin_phcv2}(original PHC pack binary for linux)
@end table
*/
/*&eg-texi
@table @t
@item Reference
@code{ox_launch}, @code{phc_start}, @file{$(OpenXM_HOME)/bin/lin_phcv2}(original PHC pack binary for linux)
@end table
*/

def phc(A) {
  PHC_FIND_PROC(P);
  sm1(P," [(getpid)] extension (universalNumber) dc ");
  Pid = ox_pop_cmo(P);
  Fname = "tmp.phc.out."+rtostr(Pid);
  ox_push_cmo(P,Fname);  sm1(P," /tmp.phc.out set ");

  B = map(rtostr,A);
  sm1_push(P,B);
  sm1(P," phc ");
  C = sm1_pop(P);
  /* print(C); */
  load("./"+Fname);
  /* return(Phc); It does not work.*/
  print("The detailed output is in the file tmp.output.*")$
  print("The answer is in the variable Phc.")$
  return(0);
}

def phc_demo1() {
  N = 256;
  /* From Jan's paper p.7, but it does not have solutions. ??*/
  /*
  A = [[x1,0,random()%N,random()%N],
       [x2,0,random()%N,random()%N],
       [0,x3,random()%N,random()%N],
       [0,x4,random()%N,random()%N]];
  B = [[x1,0,random()%N,random()%N],
       [x2,0,random()%N,random()%N],
       [0,x3,random()%N,random()%N],
       [0,x4,random()%N,random()%N]];
  C = [[x1,0,random()%N,random()%N],
       [x2,0,random()%N,random()%N],
       [0,x3,random()%N,random()%N],
       [0,x4,random()%N,random()%N]];
  D = [[x1,0,random()%N,random()%N],
       [x2,0,random()%N,random()%N],
       [0,x3,random()%N,random()%N],
       [0,x4,random()%N,random()%N]];

  G=[-20948*x3*x1+ 34900*x3*x2+ 24828*x4*x1-22860*x4*x2,
     24786*x3*x1+ 30282*x3*x2+ 5255*x4*x1-24101*x4*x2,
     27682*x3*x1-26248*x3*x2-8928*x4*x1+ 9000*x4*x2,
     -14585*x3*x1-3666*x3*x2+ 37796*x4*x1-16341*x4*x2];

  */
  A = [[1,0,random()%N,random()%N],
       [0,1,random()%N,random()%N],
       [x1,x3,random()%N,random()%N],
       [x2,x4,random()%N,random()%N]];
  B = [[1,0,random()%N,random()%N],
       [0,1,random()%N,random()%N],
       [x1,x3,random()%N,random()%N],
       [x2,x4,random()%N,random()%N]];
  C = [[1,0,random()%N,random()%N],
       [0,1,random()%N,random()%N],
       [x1,x3,random()%N,random()%N],
       [x2,x4,random()%N,random()%N]];
  D = [[1,0,random()%N,random()%N],
       [0,1,random()%N,random()%N],
       [x1,x3,random()%N,random()%N],
       [x2,x4,random()%N,random()%N]];
  E = [det(newmat(4,4,A)),det(newmat(4,4,B)),
       det(newmat(4,4,C)),det(newmat(4,4,D))];
  print(E);
  phc(E);
}

end$

