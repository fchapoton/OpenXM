/* $OpenXM: OpenXM/src/asir-contrib/packages/src/quote.rr,v 1.4 2001/08/22 05:24:18 takayama Exp $ */
#define NUMBER 1
#define RPOLYNOMIAL 2
#define RATIONAL 3
#define LIST 4
#define VECTOR 5
#define MATRIX 6
#define STRING 7
#define STRUCT 8
#define DPOLYNOMIAL   9
#define QUOTE 17

/* Functions for asir quote object. */

def quote_to_quote(S) {
  if (type(S) == QUOTE) return S;
  else {
    return eval_str("quote("+rtostr(S)+")");
  }
}


/* Tentative */
def quote_factor(S) {
  A = poly_factor(S);
  return quote_factored_form_to_quote(A);
}
/* Tentative code */
def quote_factored_form_to_quote(S) {
  if (type(S) == QUOTE) return S;
  if (type(S) == STRUCT)  {
    /* And we need to check it is struct poly_factored_... */
    if (S->Tag == "poly_factored_polynomial") {
       return quote_factored_list_to_quote(S->F);
    }else if (S->Tag == "poly_factored_rational") {
       return quote_factored_form_to_quote(S->Numerator)/
              quote_factored_form_to_quote(S->Denominator);
    }else{
      return quote_to_quote(S);
    }
  }
  return quote_to_quote(S);
}

/* S is assumed to be the return value of fctr */
def quote_factored_list_to_quote(S) {
  Ans = 0;
  N = length(S);
  if (N == 1 && S[0][0] == 1 && S[0][1] == 1) {
    return quote(1);
  }
  for (I=0; I<N; I++) {
    A = "quote(";
    T = S[I];
    if (T[1] == 1) {
      if (T[0] != 1) {
        A += "("+rtostr(T[0])+")";
      }
    }else{
      A += "("+rtostr(T[0])+")^"+rtostr(T[1]);
    }
    A += ")";
    /* print (A); */
    if (T[1] == 1 && T[0] == 1) {
    }else{
      if (type(Ans) == 0) {
         Ans = eval_str(A);
      }else{
         Ans = Ans * eval_str(A);
      }
    }
  }
  return Ans;
}

/*
   V : list of variables.
   W : weight vector or order number.
*/
def quote_sort_polynomial(F,V,W) {
  if (type(F) != RPOLYNOMIAL) return quote_to_quote(F);
  dp_ord(taka_poly_weight_vector(W,V));
  F = dp_ptod(F,V);
  if (F != 0) {
    Ans="";
  }else{
    Ans=quote(0); return Ans;
  }
  C = 0;
  while (F != 0) {
     G = dp_hm(F);
     F = dp_rest(F);

     HC = "("+rtostr(dp_hc(G))+")"; 
     HT = rtostr(dp_dtop(dp_ht(G),V));
     if (HT != 1) {
       HC = quote_to_quote(HC+"*"+HT);
     }else{
       HC = quote_to_quote(HC);
     }
     if (C == 0) {
         Ans = HC;
     }else{
        Ans = Ans + HC;
     }
     if (C == 0) C = 1;
  }
  return Ans;
}


def quote_input_form(S) {
  if (type(S) != QUOTE) return rtostr(S);
  S = quotetolist(S);
  return ("quote("+quote_input_form_quote_list(S)+")");  
}

def quote_input_form_quote_list(S) {
  A = "";
  if (S[0] == "u_op") {
     return quote_input_form_quote_list_u_op(cdr(S));
  }else if (S[0] == "b_op") {
     return quote_input_form_quote_list_b_op(cdr(S));
  }else if (S[0] == "t_op") {
     return quote_input_form_quote_list_t_op(cdr(S));
  }else if (S[0] == "list") {
     return quote_input_form_quote_list_list(cdr(S));
  }else if (S[0] == "exponent_vector") {
     return quote_input_form_quote_list_exponent_vector(cdr(S));
  }else if (S[0] == "internal") {
     return quote_input_form_quote_list_internal(cdr(S));
  }else if (S[0] == "function") {
     return quote_input_form_quote_list_function(cdr(S));
  }else {
     error("Unknown quote format.");
  }
}

def quote_input_form_quote_list_u_op(S) {
  if (S[0] == "()") {
    A += "(";
    A += quote_input_form_quote_list(S[1]);
    A += ") ";
  }else{
    A += S[0];
    A += quote_input_form_quote_list(S[1]);
  }
  return A;
}

def quote_is_internal_zero(S) {
  if (type(S) != LIST) return 0;
  if (length(S) != 2) return 0;
  if (S[0] == "internal" && S[1] == 0) return 1;
  else return 0;
}
def quote_input_form_quote_list_b_op(S) {
  if (S[0] == "-") {
    T = cdr(S);
    N = length(T);
    for (I=0; I<N; I++) {
      if (I == 0 && quote_is_internal_zero(T[I])) {
         /* Do not print 0. */
      } else {
         A += quote_input_form_quote_list(T[I]);
      }
      if (I != N-1) A += S[0];
    }
  }else {
     T = cdr(S);
     N = length(T);
     for (I=0; I<N; I++) {
       A += quote_input_form_quote_list(T[I]);
       if (I != N-1) A += S[0];
     }
  }
  return A;
}

def quote_input_form_list_t_op(S) {
  NOT_YET ;
}

def quote_input_form_quote_list_exponent_vector(S) {
    T = S;
    A = " [ ";
    N = length(T);
    for (I=0; I<N; I++) {
      A += quote_input_form_quote_list(T[I]);
      if (I != N-1) {
        A += ", ";
      }
    }
    A += "]";
    return A;
}

def quote_input_form_quote_list_list(S) {
    T = S;
    A = " [ ";
    N = length(T);
    for (I=0; I<N; I++) {
      A += quote_input_form_quote_list(T[I]);
      if (I != N-1) {
        A += ", ";
      }
    }
    A += "]";
    return A;
}


def quote_input_form_quote_list_function(S) {
    A += S[0];
    A += "(";
    T = cdr(S);
    N = length(T);
    for (I=0; I<N; I++) {
      A += quote_input_form_quote_list(T[I]);
      if (I != N-1) {
        A += ", ";
      }
    }
    A += ")";
    return(A);
}

def quote_input_form_quote_list_internal(S) {
  return rtostr(car(S));
}

/*  test data
   quote_input_form(quote(1+2));
   quote_input_form(quote(-1));
   quote_input_form(quote(x+1/2*y));
   quote_input_form(quote_to_quote(-(x-1/3*y)^3));
   quote_input_form(quote( (sin(x)+y)/(x-y) ));
   quote_input_form(quote([[1,2],[x-10,1/y]]));
   quote_input_form(quote(newmat(2,2,[[1,2],[1/x,exp(x)]])));
*/



end$
