/* $OpenXM$ */
module oh_number;
localf rats_prec;
localf rats;
localf to_continued_fraction;
localf continued_fraction_to_rat;
localf sign, abs;
localf deval;

def sign(X) {
    return (X==0)? 0: (X<0)? -1: 1;
}

def abs(A) {
    return A>=0? A: -A;
}

def deval(A) {
    return eval(A*exp(0));
}

def rats_prec(X,K) {
    O = cons(["rev",no],getopt());
    L = to_continued_fraction(X,K|option_list=O);
    return continued_fraction_to_rat(L|option_list=O);
}

def to_continued_fraction(X,K) {
    R=getopt(round);
    Round=0;
    if (R==floor) { 
        Round=-1;
    }else if (R==ceil) {
        Round=1;
    }
    Sign = 1;
    if (X==0) {
        return 0;
    }else if (X<0) {
        Sign = -1; X = -X; 
    }
/* continued fraction (X ~= reverse(L)) */
    Flag = 1;
    Bound = 2^62;
    L = [];
    if (ntype(X)==1) {
        X = deval(X);
    }
    for(I=0; I<K; I++,X=1/X) {
        Q = number_floor(X);
        L = cons(Q,L);
        X = X - Q;
        if (Bound*X < 1) { /* underflow for ieee754 double prec. */
            Flag = 0;
            break;
        }
    }
    Q = 0;
    if (Round) {
        Round = (2*irem(I,2)-1)*Sign*Round;
        if( Round > 0 ) {
            Q = number_floor(X);
        }else {
            Q = number_ceiling(X);
        }
    }else if (Flag) {
/*      Q = number_round(X);  number_round is not implemented. */
        Q = rint(::deval(X));
    }
    if (Q!=0 || L==[]) {
        L = cons(Q,L); 
    }
    if(getopt(rev)!=no) {
        L = reverse(L);
    }
    return [Sign,L];
}

/* continued fraction to rational number */
def continued_fraction_to_rat(L) {
    Sign = 1;
    if (type(L[1])==4) { /* if L ~= [Sign, List] */
        Sign = L[0];
        L = L[1];
    }
    if(getopt(rev)!=no) {
        L = reverse(L);
    }
    for(R=car(L),L=cdr(L); L!=[]; L=cdr(L)) {
        R = car(L) + 1/R;
    }
    return Sign*R;
}

def rats(X) {
   P=getopt(prec);
   if (type(P) == 1 || P == 0) return rats_prec(X,P|option_list=getopt());
   else return rats_prec(X,14|option_list=getopt());
}

endmodule;
end$
/*
ctrl("bigfloat",1);
setprec(100);
ctrl("real_digit",32);

printf("\n")$
Z=deval(@pi);
R=rats(Z);
printf("Error=%a\n",number_abs(Z-R));

printf("\n")$
Z=0.7595;
R=rats(Z);
printf("Error=%a\n",number_abs(Z-R));

printf("\n")$
Z=deval(2^(1/2));
R=rats(Z);
printf("Error=%a\n",number_abs(Z-R));

printf("\n")$
Z=deval(3^(1/2));
R=rats(Z);
printf("Error=%a\n",number_abs(Z-R));

end;
*/
