/* -*- mode: C -*- */
/* $OpenXM: OpenXM/src/asir-contrib/packages/src/yang.rr,v 1.7 2004/07/09 07:13:42 ohara Exp $ */

/* 
   1. At first you must define a ring structure.
      [1175] load("yang.rr");
      [1522] yang.define_ring(["euler",[x],"difference",[[p,-1]]]);
   2. Computation.
      [1523] OP1 = yang.operator(x);
      (1)*<<1,0>>
      [1524] OP2 = yang.operator(p);
      (1)*<<0,1>>
      [1525] L1 = (x^2-p)*yang.multiL([OP1,OP1-1,OP2]);
      (x^2-p)*<<2,1>>+(-x^2+p)*<<1,1>>
      [1526] yang.multi(OP2,L1);
      (x^2-p+1)*<<2,2>>+(-x^2+p-1)*<<1,2>>
      [1527] yang.multi(OP1,L1);
      (x^2-p)*<<3,1>>+(x^2+p)*<<2,1>>+(-2*x^2)*<<1,1>>
 */

/*
Naming rule of functions of this module.
<prefix>
  act_     multiplication of operators.
  action_  actions of operators to functions.

<postfix>
  _DE      accepts euler and (q-)differende operators.
  _D       accepts only euler operators.
*/

#include <defs.h>

load("noro_matrix.rr") $ /* for linalg.{binomial_coef,compute_kernel}() */

#define EULER        0
#define DIFFERENCE   1
#define Q_DIFFERENCE 2

#define isList(A)    (islist(A)||isvect(A))
#define NM(A)        (isList(A)? ((A)[0]): (A))
#define DN(A)        (isList(A)? ((A)[1]): (1))

module yang;

localf push_ring, pop_ring, define_ring, parse_ringdef, print_ring, ring_size;
localf op_type, op_diff, op_var, op_match, op_nomatch;
localf constant, operator_id, operator;
localf modulo, modulo_list, left, right;
localf verbose, quiet, message;
localf spair_lcm, spair_compare, spair_sugar;
localf euler_diff, euler_diff_list, euler_diff_dp_list, euler_diff_dp;
localf act_theta_D, act_theta_DE, act_difference;
localf multi, multi_D, multi_DE, multiL;
localf dp_coef_gcd, red1, red2, reducible, division, division_D, division_DE;
localf nf, reduction, add, spolynomial, spolynomial_D, spolynomial_DE;
localf criterionF, criterionM, dp_revcmp, gr2rgr, gr, buchberger, in, stdmon;
localf dp_ltom, pfaffian, check_pfaffian;
localf check_frac_expansion_before, check_frac_expansion_after;
localf frac_expansion, sing_point, residue;
localf extract_denom, extract_denom_poly, mtriple, mpair;
localf listlist_merge, matrix_to_list, matrices_to_list, matrix_to_coef_matrix;
localf pfaffian_to_coef_matrices;
localf ispoly_of_vars, matrix_column_nth, matrix_row_nth;
localf gkz_ring, define_gkz_ring, gkz, gkz_D, gkz_E;
localf compute_toric_kernel, gkz_toric_partial, gkz_toric;
localf gkz_toric_partial_sm1, gkz_toric_sm1;
localf initial_term_weight, gkz_distraction;
localf action_monomial_DE, action_DE, action;
localf dp_dtol;
localf partial_to_euler_i, partial_to_euler_term_i;
localf partial_to_euler, partial_to_euler_term;
localf a2k, sigma, gen_gamma, pochhammer, eval_gamma, gamma1, gamma2;
localf vector_to_rat;
localf series, series_algorithm1, series_algorithm3, series1, series2;
localf pattern, pattern_full, pattern_weight, all_integers;
localf 'std_+', 'std_*', 'std_=';
localf list_incr, list_sum, list_second, list_add_prefix;
localf vector_unit, vector_sum, vector_inner_product, vector_shorten;
localf vector_const, vector_split;

function gamma(x);

static Verbose, Ring, Vars, VarF, VarDiff, RingStack;
if (RingStack == 0) {
    RingStack = [];
}else {
}

/* --------------------------------
   If RingDef is given by
      ["euler",[x,y],"difference",[[a,1],[a,-1]], "q-difference", [[z,q]]],
   then parameters is set as follows:
      Vars == [x,y,a,a,z],
      VarF == [0,0,1,1,2],
      VarDiff == [0,0,1,-1,q]
   Vars: a list of variables
   VarF: a list of operator types
   VarF: a list of differences
   -------------------------------- */

/* Example:
   yang.define_ring([x,y,z]);
   yang.define_ring(["euler",[x,y],"difference",[p,q],"euler",[z]]);
*/
def define_ring(RingDef) {
    Vars = []; VarF = []; VarDiff = []; Ring = RingDef;
    if (islist(RingDef)) {
        if (!isstr(RingDef[0])) {
            RingDef = ["euler", RingDef]; /* all operators are euler */
        }
        while(RingDef!=[]) {
            RingDef = parse_ringdef(RingDef);
        }
    }
    return print_ring();
}

/*
   Examples of RingDef:
     ["euler", [x,y]]
     ["difference", [a,b]]
     ["difference", [[a,1],[b,1]]]
     ["q-difference", [[a,q]]]
*/
def parse_ringdef(RingDef) {
    S    = RingDef[0];
    VSet = RingDef[1];
    N    = length(VSet);
    F    = vtol(newvect(N));
    if(S=="difference") {
        D = map(right, VSet, 1);
        F = map('std_=', F, DIFFERENCE);
    }else if(S=="q-difference") {
        D = map(right, VSet, q);
        F = map('std_=', F, Q_DIFFERENCE);
    }else if(S=="euler" || S=="differential"){
        D = vtol(newvect(N));
    }else {
        error("yang.define_ring(): invalid ring definition.");
    }
    Vars = append(Vars, map(left, VSet));
    VarF = append(VarF, F);
    VarDiff = append(VarDiff, D);
    return cdr(cdr(RingDef));
}

def print_ring()
"Print the inner structure of the ring."
{
    return [Vars, VarF, VarDiff];
}

def ring_size()
"Get a number of operators of the ring."
{
    return length(Vars);
}

def push_ring()
"Push the current ring definition to the stack."
{
    CurrentRing = [Ring, Vars, VarF, VarDiff];
    RingStack = cons(CurrentRing, RingStack);
    return map('car', RingStack);
}

def pop_ring()
"Pop a ring definition from the stack."
{
    if ((C = car(RingStack)) != [] && islist(C) && length(C) == 4) {
        Ring = C[0]; Vars = C[1]; VarF = C[2]; VarDiff = C[3];
        RingStack = cdr(RingStack);
        return C[0];
    }
    return C;
}

def op_type(I)  {
    return VarF[I];
}

def op_diff(I)  {
    return VarDiff[I];
}

def op_var(I)  {
    return Vars[I];
}

/* ある Type の作用素のみを取り出す */
def op_match(P,Type) {
    if (isdpoly(P)) {
        H = dp_etov(dp_ht(P));
        N = length(H);
        for(I=0; I<N; I++) {
            if (op_type(I) != Type) {
                H[I]=0;
            }
        }
        return dp_vtoe(H);
    }
    return 0;
}

/* ある Type でない作用素のみを取り出す.
   Example: VarF == [0,0,1,2] のとき、
   yang.op_nomatch(<<2,1,1,4>>,EULER) == <<0,0,1,4>>
*/
def op_nomatch(P,Type) {
    if (isdpoly(P)) {
        H = dp_etov(dp_ht(P));
        N = length(H);
        for(I=0; I<N; I++) {
            if (op_type(I)==Type) {
                H[I]=0;
            }
        }
        return dp_vtoe(H);
    }
    return 0;
}

def operator_id(OP) {
    N = ring_size();
    if (isList(OP)) {
        for(I=0; I<N && [op_var(I),op_diff(I)] != OP ; I++) {
        }
    }else {
        for(I=0; I<N && op_var(I) != OP; I++) {
        }
    }
    return (I<N)? I: -1;
}

def operator(OP) {
    N = ring_size();
    I = operator_id(OP);
    return dp_vtoe(vector_unit(N,I));
}

/* 下位互換性のため */
def constant(A) {
    return A*dp_vtoe(newvect(ring_size()));
}

def modulo(OP1, OP2) {
    return multi(operator(OP1),operator(OP2)) - 1 ;
}

def modulo_list() {
    N = ring_size();
    EF = newvect(N);
    L = [];
    for(I=0; I<N; I++) {
        for(J=I+1; J<N; J++) {
            if (op_var(I)==op_var(J) && op_type(I)==op_type(J) &&
                ((op_type(I)==DIFFERENCE && op_diff(I)+op_diff(J)==0)
                 || (op_type(I)==Q_DIFFERENCE && op_diff(I)*op_diff(J)==1))) {
                    EF[I]=EF[J]=1;
                    L = cons(dp_vtoe(EF)-1, L);
                    EF[I]=EF[J]=0;
            }
        }
    }
    return L;
}

def left(A) {
    return (isList(A))? A[0]: A;
}

def right(A,B) {
    return (isList(A))? A[1]: B;
}

def verbose() {
    Verbose=1;
}

def quiet() {
    Verbose=0;
}

def message(A) {
    if (Verbose) {
        print(A,2);
    }
}

/* head term of S-polynomial pair */
def spair_lcm(SP) {
    P = SP[0];
    Q = SP[1];
    P=NM(P); Q=NM(Q);
    return dp_lcm(P,Q);
}

/* comparison of S-pair. (昇順) */
def spair_compare(P, Q) {
    if (P[2]!=Q[2]) {
        return (P[2]<Q[2])? -1: 1;
    }
    TP = spair_lcm(P);
    TQ = spair_lcm(Q);
    if (TP != TQ) {
        return (TP<TQ)? -1: 1;
    }
    return 0;
}

/* sugar of S-pair. */
def spair_sugar(P,Q) {
    P=NM(P);
    Q=NM(Q);
    S1 = dp_sugar(P)*dp_td(Q);
    S2 = dp_sugar(Q)*dp_td(P);
    return (S1>S2)? S1: S2;
}

/** 有理式係数分散表現多項式: [Dpoly, Poly] **/

/* 再帰表現多項式を N回 オイラー微分する*/
def euler_diff(P, V, N) {
    if (israt(P)) {
        for (I=0; I<N; I++) {
            P = V*diff(P, V);
        }

    }else {
        for (I=0; I<N; I++) {
            P = ediff(P, V);
        }
    }
    return P;
}

/* 再帰表現多項式を 0...N 回 オイラー微分したものの配列(長さN+1)を返す */
def euler_diff_list(P, V, N) {
    L = newvect(N+1);
    L[0] = P;
    for (I=0; I<N; I++) {
        L[I+1] = ediff(L[I], V);
    }
    return L;
}

/* 分散表現多項式の係数を 0...N 回 オイラー微分したものの配列(長さN+1)を返す */
def euler_diff_dp_list(P, V, N) {
    if (isdpoly(P)) {
        Q = newvect(N+1);
        while(P!=0) {
            Q += dp_ht(P)*euler_diff_list(dp_hc(P),V,N);
            P  = dp_rest(P);
        }
    }else {
        Q=euler_diff_list(P, V, N);
    }
    return Q;
}

/* 分散表現多項式の係数を N回 オイラー微分する*/
def euler_diff_dp(P, V, N) {
    if (isdpoly(P)) {
        Q=0;
        while(P!=0) {
            Q+=euler_diff(dp_hc(P),V,N)*dp_ht(P);
            P=dp_rest(P);
        }
    }else {
        Q=euler_diff(P, V, N);
    }
    return Q;
}

/* 微分作用素(単項式) E と微分作用素 Q の積 */
def act_theta_D(E,Q) {
    E = dp_etov(E);
    N = length(E);
    T = newvect(N);
    for (I=0; I<N; I++) {
        F=0;
        LC = euler_diff_dp_list(Q,op_var(I),E[I]);
        for (K=0; K<=E[I]; K++) {
            T[I]=K;
            F += linalg.binomial_coef(E[I],K)*LC[E[I]-K]*dp_vtoe(T);
        }
        T[I]=0;
        Q=F;
    }
    return Q;
}

/* 微分/差分作用素(単項式) E と微分/差分作用素 Q の積 */
def act_theta_DE(E,Q) {
    E = dp_etov(E);
    N = length(E);
    T = newvect(N);
    for (I=0; I<N; I++) {
        if (op_type(I)==EULER) { /* 微分 */
            F=0;
            LC = euler_diff_dp_list(Q,op_var(I),E[I]);
            for (K=0; K<=E[I]; K++) {
                T[I]=K;
                F += linalg.binomial_coef(E[I],K)*LC[E[I]-K]*dp_vtoe(T);
            }
            Q=F;
        }else if (op_type(I)==DIFFERENCE) { /* 差分 */
            T[I]=E[I];
            V = op_var(I); D = op_diff(I);
            Q=base_replace(Q,[[V,V+D*E[I]]])*dp_vtoe(T);
        }else if (op_type(I)==Q_DIFFERENCE) { /* q-差分 */
            T[I]=E[I];
            V = op_var(I); D = op_diff(I);
            Q=base_replace(Q,[[V,V*D^E[I]]])*dp_vtoe(T);
        }
        T[I]=0;
    }
    return Q;
}

/* DE の頭項の差分作用素のみを P に作用させる。*/
def act_difference(DE,P) {
    DE = op_nomatch(DE,EULER);
    return dp_hc(act_theta_DE(DE, P));
}

/* Leibnitz rule: P,Q: 分散表現多項式 */
def multi(P,Q) {
    return multi_DE(P,Q);
}

def multi_D(P,Q) {
    if (isdpoly(P)) {
        R=0;
        while(P!=0) {
            R += dp_hc(P)*act_theta_D(dp_ht(P),Q);
            P = dp_rest(P);
        }
    }else {
        R=P*Q;
    }
    return R;
}

/* 微分/差分 */
def multi_DE(P,Q) {
    if (isdpoly(P)) {
        R=0;
        while(P!=0) {
            R += dp_hc(P)*act_theta_DE(dp_ht(P),Q);
            P = dp_rest(P);
        }
    }else {
        R=P*Q;
    }
    return R;
}

/*
L: a list of distributed polynomials
result: the product L[0]*L[1]*...*L[N-1]
*/
def multiL(L) 
"[L0,L1,L2,...] => the product L0*L1*L2*..."
{
    R = 0;
    N = length(L);
    if (N>0) {
        R = L[0];
        for(I=1; I<N; I++) {
            R = multi(R, L[I]);
        }
    }
    return R;
}

/* 分散表現多項式の係数たちの gcd */
def dp_coef_gcd(P) {
    C = dp_hc(P);
    for(P = dp_rest(P); P != 0; P = dp_rest(P)) {
        C = gcd(C, dp_hc(P));
    }
    return C;
}

/* 有理係数分散表現多項式を約分する */
def red1(LP) {
    if(isList(LP)) {
        D = LP[1];
        LP= LP[0];
    }else {
        return [red2(LP),1];
    }

    if(LP==0) {
        return [0,1];
    }
    for(C = D, P = LP; P != 0; P = dp_rest(P)) {
        C = gcd(C, dp_hc(P));
    }
    /* C == gcd(D, coefs(P)) */
    for(Q = 0, P = LP; P != 0; P = dp_rest(P)) {
        Q += sdiv(dp_hc(P),C)*dp_ht(P);
    }
    return [Q, sdiv(D,C)];
}

/* 分散表現多項式の係数から共通因子をくくりだす */
def red2(DP) {
    if(DP==0) {
        return 0;
    }
    C = dp_coef_gcd(DP);
    for(Q = 0; DP != 0; DP = dp_rest(DP)) {
        Q += sdiv(dp_hc(DP),C)*dp_ht(DP);
    }
    return Q;
}

/* LP が LQ で簡約可能ならば 1 を返す */
def reducible(LP,LQ) {
    LP=NM(LP);
    LQ=NM(LQ);
    return dp_redble(LP,LQ);
}

/* P mod Q を求める */
def division(P,Q) {
    return division_DE(P,Q);
}

def division_D(P,Q) {
    D = DN(P); P = NM(P);
    Q = NM(Q);
    if (dp_redble(P,Q)) {
        DQ = dp_subd(P,Q);
        PP = red(dp_hc(P)/(dp_hc(Q)));
        F  = nm(PP); G = dn(PP);
        R  = [G*P - F*multi(DQ,Q),D*G];
        R  = red1(R);
    }
    return R;
}

def division_DE(P,Q) {
    D = DN(P); P = NM(P);
    Q = NM(Q);
    if (dp_redble(P,Q)) {
        DQ = dp_subd(P,Q);
        PP = red(dp_hc(P)/act_difference(DQ,dp_hc(Q)));
        F  = nm(PP); G = dn(PP);
        R  = [G*P - F*multi(DQ,Q),D*G];
        R  = red1(R);
    }
    return R;
}

/* 正規形を求める(別名) */
def nf(F,Gr) {
    return reduction(F,Gr);
}

/* 分散表現多項式 F を 集合 G で簡約する */
def reduction(F,G)
{
    if (!isList(F)) F=[F,1];

    Rem = [0,1];
    while (F[0] != 0) {
/*      message("."); */
        for (U = 0, L = G; L != []; L = cdr(L)) {
            Red = car(L);
            if (reducible(F,Red)) {
/*              message("("+rtostr(dp_mag(F[0]))+")");
                if(dp_mag(F[0])>300000) {
                    F = red1(F);
                }
*/
                F = division(F,Red);
                if (F[0] == 0) {
                    return Rem;
                }
                U = 1;
                break;
            }
        }
        if (U == 0) {
            H   = [dp_hm(F[0]),   F[1]];
            F   = [dp_rest(F[0]), F[1]];
            Rem = add(Rem,H);
        }
    }
    return Rem;
}

def add(F,G) {
    if (!isList(F)) F=[F,1];
    if (!isList(G)) G=[G,1];
    H = gcd(F[1],G[1]);
    GG = sdiv(G[1],H);
    FF = sdiv(F[1],H);
    L =  GG*F[1]; /* LCM */
    return [GG*F[0]+FF*G[0], L];
}

def spolynomial(P,Q) {
    return spolynomial_DE(P,Q);
}

def spolynomial_D(P,Q)
"Get S-porinomial of P and Q."
{
    P=NM(P);
    Q=NM(Q);

    LCM= dp_lcm(P,Q);
    DP = dp_subd(LCM,dp_ht(P));
    DQ = dp_subd(LCM,dp_ht(Q));
    CP = dp_hc(P);
    CQ = dp_hc(Q);
    GCD= gcd(CP,CQ);

    SP = sdiv(CQ,GCD)*multi(DP,P)
        -sdiv(CP,GCD)*multi(DQ,Q);
    return red2(SP);
}

/* 有理関数係数の微分/差分作用素の S 多項式を求める。
   Remark:  P=(f/p)D^m, Q=(g/q)E^n のとき、S 多項式を
   Sp(P,Q) := (g E^n p) P - ((E^n . f) D^m q) Q
            = (g E^n f D^m ) - ((E^n . f) D^m g E^n )
            = ((E^n . f ) g D^m E^n ) - ((E^n . f) D^m g E^n )
   と定める。
*/

def spolynomial_DE(P,Q) {
    P=NM(P);
    Q=NM(Q);

    LCM= dp_lcm(P,Q);
    DP = dp_subd(LCM,dp_ht(P));
    DQ = dp_subd(LCM,dp_ht(Q));
    CP = act_difference(DP,dp_hc(P));
    CQ = act_difference(DQ,dp_hc(Q));
    GCD= gcd(CP,CQ);

    SP = sdiv(CQ,GCD)*multi_DE(DP,P)
        -sdiv(CP,GCD)*multi_DE(DQ,Q);
    return red2(SP);
}

/* Gebauer-Moeller's Criterion F */
def criterionF(I,J,G) {
    if (I>=J) {
        return 1;
    }
    GJ = G[J]; GJ=NM(GJ);
    GI = G[I]; GI=NM(GI);
    TIJ = dp_lcm(GI,GJ);
    for(K=0;K<I;K++) {
        GK = G[K]; GK=NM(GK);
        TKJ = dp_lcm(GK,GJ);
        if (TIJ == TKJ) {
            return 1;
        }
    }
    return 0;
}

/* Gebauer-Moeller's Criterion M */
def criterionM(I,J,G) {
    if (I>=J) {
        return 1;
    }
    GJ = G[J]; GJ=NM(GJ);
    GI = G[I]; GI=NM(GI);
    TIJ = dp_lcm(GI,GJ);
    for(K=0;K<J;K++) {
        GK = G[K]; GK=NM(GK);
        TKJ = dp_lcm(GK,GJ);
        if (dp_redble(TIJ,TKJ) && TIJ != TKJ) {
            return 1;
        }
    }
    return 0;
}

/* 降順で並べる */
def dp_revcmp(P,Q) {
    P=NM(P);
    Q=NM(Q);
    return (P==Q)? 0: ((P<Q)? 1: -1);
}

/*
Input: (Groebner basis, Variables)
Output: reduced Groebner basis
*/
def gr2rgr(G) {
    G = qsort(G, dp_revcmp);
    RedGr = [];
    while(G != []) {
        H = car(G); G = cdr(G);
        H = reduction(H,G);
        if (H[0] != 0) {
            H = [H[0], dp_hc(H[0])]; /* hc(H) == 1 */
            RedGr = cons(H, RedGr);
        }
    }
    return map(red1,RedGr); /* 昇順 */
}

/*
Options:
sm1=1     (sm1を用いてヒルベルト多項式を表示する)
hilbert=H (ヒルベルト多項式がHに到達したら計算を打ち切る)
weight=[W1,W2,...] (ウエイトベクトル, 未実装)
*/
/* from Asir-Book */
def buchberger(F) {
    UseSM1 = 0;
    if (!isvoid(O=getopt(sm1))) {
        UseSM1 = 1;
        Hilbert = 0;
    }
    if (!isvoid(O=getopt(hilbert))) {
        UseSM1 = 1;
        Hilbert = OPTS;
    }
    MaxSugar=0;
    N = length(F);
    G = F;
    Pairs = [];
    for(J=N-1; J>=0; J--) {
        for(I=J-1; I>=0; I--) {
            if (!criterionM(I,J,G) && !criterionF(I,J,G)) {
                Pairs = cons([G[I],G[J],spair_sugar(G[I],G[J])],Pairs);
            }
        }
    }
    Pairs = qsort(Pairs, spair_compare); /* sort by sugar */
    while(Pairs != []) {
/*      message(length(G)); */
        K = car(Pairs);
        Pairs = cdr(Pairs);
        if(MaxSugar < K[2]) {
            MaxSugar=K[2];
            message(" "+rtostr(MaxSugar)+" ");
        }
        if (UseSM1) {
            IN = map(dp_dtop,in(G),Vars);
            Sm1_hilbert = sm1.hilbert([IN,Vars]);
            message("<"+rtostr(Sm1_hilbert)+">");
            if (Sm1_hilbert == Hilbert) {
                break;
            }
        }
        SP = spolynomial(K[0],K[1]);
        Rem = reduction(SP,G);
        if (Rem[0] != 0) {
            message(".");
            G = append(G, [Rem]);
            L = [];
            for(I=0; I<N; I++) {
                if (!criterionM(I,N,G) && !criterionF(I,N,G)) {
                    L = cons([G[I],G[N],spair_sugar(G[I],G[N])],L);
                }
            }
            Pairs = qsort(append(Pairs, L), spair_compare); /* sort by sugar */
            N++;
        }else {
            message("o");
        }
    }
    message("\n");
    return gr2rgr(G); /* Reducing G a Groebner basis. */
}

def gr(F) {
    OPTS=getopt();
    return buchberger(F|option_list=OPTS);
}

/* it returns in(G) */
def in(Gr) {
    L = [];
    N = length(Gr);
    for(I=0; I<N; I++) {
        P = Gr[I];
        P = NM(P);
        if (isdpoly(P)) {
            L = cons(dp_ht(P),L) ;
        }
    }
    return L;
}

def stdmon(Gr)
"Get standard monomial of a Groebner base."
{
    return dp_mbase(in(Gr));
}

/* --------------------------------
   Following functions for computing of pfaffian forms

/*  分散多項式のリストLPを行列に変換する。LMはベース。
    Example:
    [12] LP=[<<1,0>>+a*<<0,0>>,<<0,1>>,<<0,0>>];
    [(1)*<<1,0>>+(a)*<<0,0>>,(1)*<<0,1>>,(1)*<<0,0>>]
    [13] LM=[<<1,0>>,<<0,1>>,<<0,0>>];
    [(1)*<<1,0>>,(1)*<<0,1>>,(1)*<<0,0>>]
    [14] dp_ltom(LP,LM);
    [ 1 0 a ]
    [ 0 1 0 ]
    [ 0 0 1 ]
*/

def dp_ltom(LP, LM) {
    N = length(LP);
    M = length(LM);
    Mat = newmat(N,M);
    for(I=0; I<N; I++) {
        if(isList(LP[I])) {
            D = LP[I][1];
            P = LP[I][0];
        }else {
            D = 1;
            P = LP[I];
        }
        for(J=0; J<M; J++) {
            for(Q = P; Q != 0; Q = dp_rest(Q)) {
                if (dp_ht(Q) == LM[J]) {
                    Mat[I][J] = red(dp_hc(Q)/D);
                    break;
                }
            }
        }
    }
    return Mat;
}

/* Let Gr be a reduced Groebner basis and Base a set of monomials.
   Then the return value L gives a Pfaffian system
   {d - (L[0]*dVSet[0] + ... + L[M-1]*dVSet[M-1])} U = 0,
   where L[J] are N*N-matrices. */
/* Base: Pfaffian を計算したいモノミアル(空のとき標準モノミアルを使う)
   Gr: グレブナ基底 */
def pfaffian(Base,Gr) {
    StdMon = stdmon(Gr);
    if (Base==[]) {
        Base = StdMon;
    }
    S = matrix_inverse(dp_ltom(map(nf,Base,Gr),StdMon));
    M = ring_size();
    L = newvect(M);
    for(J=0; J<M; J++) {
        P = dp_vtoe(vector_unit(M, J));
        P = map(nf,map('std_*',Base,P),Gr);
        L[J] = map(red,((op_type(J)==EULER)? (1/op_var(J)): 1)*dp_ltom(P, StdMon)*S);
    }
    return L;
}

/* length(Pf) == length(VSet) */
/* Check dP - P*P = 0 */
def check_pfaffian(Pf,VSet) {
    L = [];
    N = length(Pf);
    for(I=0; I<N; I++) {
        for(J=0; J<I; J++) {
            A = map(diff,Pf[I],VSet[J]) - map(diff,Pf[J],VSet[I])
                + (Pf[I]*Pf[J] - Pf[J]*Pf[I]);
            L = cons(map(red, A), L);
        }
    }
    return L;
}

/* 有理式 F が一次分数展開出来そうならば 1 を返す。
   この関数では、一次分数展開するためには、
   「分母が変数 V の(無平方な)一次式に分解できる」
   が成り立たなければならない。'
*/

def check_frac_expansion_before(F, V) {
    if (!ispoly(V) || !israt(F)) {
        return 0;
    }
    for(L=cdr(fctr(dn(F))); (G=car(L))!= []; L = cdr(L)) {
        Deg = deg(G[0],V);
        if (Deg>0 && (Deg>1 || G[1]>1)) {
            return 0;
        }
    }
    return 1;
}

def check_frac_expansion_after(F, Q) {
    G = 0;
    for(G=0; (A = car(Q)) != []; Q = cdr(Q)) {
        G = G + A[0]/A[1];
    }
    return (F-G)==0;
}

/*  有理式 F を一次分数展開する。成功すればリストを返す。
    Example:
    [100] F = ((-a-b1)*x^2+((a+b1-b2)*y+c)*x+(-c+b2)*y) / (x*(x-1)*(x-y));
    [101] frac_expansion(F,x);
    [[-b2,x-y],[-a+c-b1,x-1],[-c+b2,x]]
*/

def frac_expansion(F, V) {
    if (check_frac_expansion_before(F, V) == 0) {
        return F;
    }
    Q = [];
    Coef = 1;
    for(L=cdr(fctr(dn(F))); (G=car(L))!= []; L = cdr(L)) {
        H = G[0];
        Deg = deg(H,V);
        if (Deg>0) {
            RR = residue(F, H, V);
            Q = cons(RR, Q);
        }
    }
    if (check_frac_expansion_after(F, Q)) {
        return Q;
    }
    return F;
}

/* F: linear form, V: a variable
   example:
   [1095] sing_point(x-y+1,x);
   y-1
*/
def sing_point(F, V) {
    return base_replace(-F/coef(F,1,V),[[V,0]]);
}

/* H==0 上で高々1位の極をもつときに留数を求める
   example:
   [1135] residue(F,x-1,x);
   [(1)/(y),x-1]
 */

def residue(F, H, V) {
    Point = sing_point(H,V);
    R = base_replace(red(F*H), [[V, Point]]);
    return [R,H];
}

/* by Noro */
def extract_denom(M) {
    S = size(M);
    Row = S[0]; Col = S[1];
    LCM = 1;
    R = newmat(Row,Col);
    for ( I = 0; I < Row; I++ )
        for ( J = 0; J < Col; J++ )
            LCM = dn(M[I][J]) * sdiv(LCM,gcd(dn(M[I][J]),LCM));
    for ( I = 0; I < Row; I++ )
        for ( J = 0; J < Col; J++ )
            R[I][J] = nm(M[I][J])*sdiv(LCM,dn(M[I][J]));
    return [R,LCM];
}

/* 多項式の係数を整数化する */
def extract_denom_poly(P) {
    V=vars(P);
    DP=dp_ptod(P,V);
    for(LCM = dn(dp_hc(DP)), DP = dp_rest(DP); DP != 0; DP = dp_rest(DP)) {
        LCM = ilcm(LCM, dn(dp_hc(DP)));
    }
    return [LCM*P,LCM];
}

def mtriple(P,S,Q) {
    return P*S+S*matrix_transpose(Q);
}

def mpair(P,S,Rule) {
    return P*S+S*matrix_transpose(base_replace(P,Rule));
}

/* [[a,b],[c,d]] -> [a,b,c,d] */
def listlist_merge(LL) {
    for(L=[]; LL != []; LL=cdr(LL)) {
        L = append(L, car(LL));
    }
    return L;
}

def matrix_to_list(M) {
    LL = matrix_matrix_to_list(M);
    return listlist_merge(LL);
}

/* ML: a list */
def matrices_to_list(ML) {
    L = map(matrix_matrix_to_list, ML)$
    return listlist_merge(listlist_merge(L));
}

/* 行列 M の各成分は VSet の変数の斉次一次式  */
def matrix_to_coef_matrix(M,VSet) {
    L = extract_denom(M);
    N = length(VSet);
    LL = [];
    for (I=0; I<N; I++) {
        LL = append(LL,[matrix_to_list(map(coef,L[0],1,VSet[I]))]);
    }
    LL = (1/L[1])*matrix_transpose(matrix_list_to_matrix(LL));
    LL = map(red, LL);
    return LL;
}

def pfaffian_to_coef_matrices(Pfaffian, S, Rule) {
    LL = map(mpair,Pfaffian,S,Rule);
    VS = matrix_to_list(S);
    return map(matrix_to_coef_matrix,LL,VS);
}

/* 多項式 P がリスト V の不定元を含めば 1, それ以外で 0. */
def ispoly_of_vars(P, V)
{
    C = dp_ptod(P,V);
    return C != 0 && vector_sum(dp_etov(dp_ht(C))) != 0;
}

def matrix_column_nth(A,N) {
    if (islist(A) && islist(A[0])) {
        Row = length(A); Col = length(A[0]);
        A=newmat(Row,Col,A);
    }else if (ismat(A)) {
        Size = size(A); Row = Size[0]; Col = Size[1];
    }
    V = newvect(Row);
    for(I=0; I<Row; I++) {
        V[I] = A[I][N];
    }
    return V;
}

def matrix_row_nth(A,N) {
    V=A[N];
    return (islist(V))? ltov(V): V;
}

/* --------------------------------
   Following functions for A-Hypergeometric Differntial-Difference systems
   -------------------------------- */

def gkz_ring(GKZ) {
    DX = list_add_prefix("x", list_incr(1, length(GKZ[0][0])+1));
    DB = assoc(GKZ[1],[-1]);
    return ["euler",DX,"difference",DB];
}

def define_gkz_ring(GKZ) {
    return define_ring(gkz_ring(GKZ));
}

/* A 超幾何微分差分方程式系 */
/* Example:
A = [[1,1,1],[0,1,2]] $
B = [b1,b2] $
yang.define_gkz_ring([A,B]);
yang.gkz([A,B]);
*/
def gkz(GKZ) {
    return [append(gkz_D(GKZ), gkz_E(GKZ)), gkz_ring(GKZ)[1]];
}

/* A 超幾何系からトーリック項を除いたもの(微分系) */
def gkz_D(GKZ) {
    A = GKZ[0]; B = GKZ[1];
    Col = length(A); Row = length(A[0]);
    N = ring_size();
    L = newvect(Col);
    for(I=0; I<Col; I++) {
        L[I]=0;
        for(J=0; J<Row; J++) {
            L[I] += A[I][J]*dp_vtoe(vector_unit(N,J));
        }
        L[I] -= B[I];
    }
    return vtol(L);
}

/* A 超幾何系に付随する差分系 */
def gkz_E(GKZ) {
    A   = GKZ[0]; B = GKZ[1];
    Col = length(A); Row = length(A[0]);
    L = newvect(Row);
    Size = ring_size();
    for(J=0; J<Row; J++) {
        E = newvect(Size);
        for(I=0; I<Col; I++) {
            E[operator_id(B[I])] = A[I][J];
        }
        L[J] = dp_vtoe(vector_unit(Size,J))-op_var(J)*dp_vtoe(E);
    }
    return vtol(L);
}

/* B. Sturmfels, "Groebner Bases and Convex Ploytopes", AMS, 1995.
   p.32, Algorithm 4.5 */
def compute_toric_kernel(GKZ)
"Example: GKZ=[ [[2,5,8]], [b1] ];\
compute_toric_kernel(GKZ) => [[-_x0^4+_x2,_x2*_x0-_x1^2],[_x0,_x1,_x2,_t1]]"
{
    A=GKZ[0];
    D=length(A); N=length(A[0]);
    X = list_add_prefix("_x", list_incr(0,N));
    T = list_add_prefix("_t", list_incr(0,D+1));
    for (P = 1, F = T; F != []; F = cdr(F)) {
        P *= car(F);
    }
    L = [P-1];
    for(I = 0; I < N; I++) {
        VL = vector_split(matrix_column_nth(A,I));
        A_pos = VL[0]; A_neg = VL[1];
        for(Pos = X[I], Neg = 1, J = 0; J < D; J++) {
            Pos *= T[J]^(A_pos[J]);
            Neg *= T[J]^(-A_neg[J]);
        }
        L = cons(Pos-Neg, L);
    }
    V = append(T,X);
    O = [ listlist_merge(assoc(T,[100])), listlist_merge(assoc(X,[1])) ];
    Gr = dp_gr_main(L | v=V,order=O);

    for(L = []; Gr != []; Gr = cdr(Gr)) {
        C = car(Gr);
        if ( !ispoly_of_vars(C,T) ) {
            L = cons(C, L);
        }
    }
    return [L,append(X,cdr(T))];
}

/* A 超幾何微分方程式のトーリック項を偏微分作用素で書いたもの */
def gkz_toric_partial(GKZ)
"gkz_toric([A,B]) computes toric forms of A-hg system defined by [A,B]."
{
    LL = compute_toric_kernel(GKZ);
    return map(dp_ptod, LL[0], LL[1]); /* gkz_ring() の返す構造を仮定 */
}

/* A 超幾何微分方程式のトーリック項をオイラー作用素で書いたもの */
def gkz_toric(GKZ)
"gkz_toric([A,B]) computes toric forms of A-hg system defined by [A,B]."
{
    T = map(partial_to_euler, gkz_toric_partial(GKZ));
    return map('car', T);
}

def gkz_toric_partial_sm1(GKZ)
"Using sm1 engine, gkz_toric([A,B]) computes toric forms of A-hg system defined by [A,B]."
{
    N = length(GKZ[0]);
    Toric = sm1.gkz(GKZ)[0];
    for (I=0; I<N; I++) {
        Toric = cdr(Toric);
    }
    N = length(GKZ[0][0]) + length(GKZ[1]);
    return map(dp_ptod, Toric, list_add_prefix("dx", list_incr(1,N+1)));
}

def gkz_toric_sm1(GKZ)
"Using sm1 engine, gkz_toric([A,B]) computes toric forms of A-hg system defined by [A,B]."
{
    T = map(partial_to_euler, gkz_toric_partial_sm1(GKZ));
    return map('car', T);
}

/* リスト F の定めるイデアルの(順序 O に関する)グレブナ基底の initail terms */
def initial_term_weight(F,O) {
    F = dp_gr_main(F | order=[O]);
    return dp_initial_term(F | order=[O]);
}

def gkz_distraction(GKZ)
"gkz_distraction(GKZ|weight=Vector)"
{
    A=GKZ[0];
    N=length(A[0]);
    D=length(A);
    V  = list_add_prefix("x", list_incr(0,N+D));
    if(isvoid(W=getopt(weight))) {
        W = vtol(vector_const(N,1));
    }
    IN_P  = initial_term_weight(gkz_toric_partial(GKZ), W);
    IN_E  = map('car', map(partial_to_euler, IN_P));
    GKZ_D = gkz_D(GKZ);
    Eq    = map(dp_dtop, append(IN_E, GKZ_D), V);
    V     = vtol(vector_shorten(N,V));
    Pri   = primadec(Eq, V);

    if (0) {
    /* outputs for debugging */
        print("in(I_A)(partial) = " +rtostr(IN_P) );
        print("in(I_A)(euler)   = " +rtostr(IN_E) );
        print("GKZ_D(euler)     = " +rtostr(GKZ_D));
        print("Distraction      = " +rtostr(Eq)   );
        print("Primadec         = " +rtostr(Pri)  );
    }

    for (Sol = []; Pri != []; Pri = cdr(Pri)) {
        C = car(Pri)[1];
        C = poly_solve_linear(C, V);
        C = map(list_second, C);
        Sol = cons(C,Sol);
    }
    return Sol;
}

/* Example:
[air:~/gm]asir
This is Risa/Asir, Version 20030402 (Kobe Distribution).
Loading ~/.asirrc
[913] load("gm.rr")$
[922] P=(x^2+y)*<<1,1>>-x*<<0,2>> $
[923] Q=y*<<0,2>> $
[924] yang.define_ring([x,y]) $
[925] yang.multi(P,Q);
(y*x^2+y^2)*<<1,3>>+(-y*x)*<<0,4>>+(y*x^2+y^2)*<<1,2>>+(-2*y*x)*<<0,3>>+(-y*x)*<<0,2>>
*/

/* 微分/差分作用素(単項式) E を多項式 P に作用させる */
def action_monomial_DE(E, P) {
    E = dp_etov(E);
    N = length(E);
    for (I=0; I<N; I++) {
        if (op_type(I)==EULER) { /* 微分 */
            P = euler_diff(P,op_var(I),E[I]);
        }else if (op_type(I)==DIFFERENCE) { /* 差分 */
            P = base_replace(P,[[ op_var(I), op_var(I)+op_diff(I)*E[I] ]]);
        }else if (op_type(I)==Q_DIFFERENCE) { /* q-差分 */
            P = base_replace(P,[[ op_var(I), op_var(I)*op_diff(I)^E[I] ]]);
        }
    }
    return P;
}

/* 微分/差分作用素 P を多項式 F に作用させる */
def action_DE(P, F) {
    for(Q = 0; P != 0; P = dp_rest(P)) {
        Q += dp_hc(P)*action_monomial_DE(dp_ht(P),F);
    }
    return Q;
}

def action(P,F) {
    return action_DE(P,F);
}

/* 分散多項式を associated list に変換 */
def dp_dtol(P) {
    for(L = []; P != 0; P = dp_rest(P)) {
        L = cons([dp_hc(P),dp_ht(P)], L);
    }
    return reverse(L);
}

/* --------------------------------
   偏微分作用素をオイラー作用素に変換する
   -------------------------------- */

/* I 番目の作用素を変換.  F: 分散多項式 */
def partial_to_euler_i(F,I)
"Example: if [op_var(0),op_type(0)] == [x,EULER], then \n \
yang.partial_to_euler_i(<<2,0>>+<<0,2>>,0) ==> \
[<<2,0>>-<<1,0>>+(x^2)*<<0,2>>,x^2]"
{
    R = 0;
    for( ; F != 0; F = dp_rest(F)) {
        H = partial_to_euler_term_i(dp_hm(F),I);
        R = add(R,H);
    }
    return R;
}

def partial_to_euler_term_i(T,I)
{
    E = dp_etov(T);
    N = E[I];
    if (op_type(I) != EULER || N == 0) {
        return [T,1];
    }
    R = red(dp_hc(T)/(op_var(I)^N));
    M = dp_vtoe(vector_unit(length(E),I));
    for(S=1, J=0; J<N; J++) {
        S = multi(S, M-J);
    }
    E[I]=0;
    return [nm(R)*S*dp_vtoe(E), dn(R)];
}

/* 全ての作用素を変換.  F: 分散多項式 */
def partial_to_euler(F) {
    R = 0;
    for( ; F != 0; F = dp_rest(F)) {
        H = partial_to_euler_term(dp_hm(F));
        R = add(R,H);
    }
    return R;
}

def partial_to_euler_term(T) {
    B = op_nomatch(T,EULER);
    E = dp_etov(op_match(T,EULER));
    Len = length(E);
    C = dp_hc(T);
    S = dp_vtoe(newvect(Len));
    D = 1;
    for(I=0; I<Len; I++) {
        N = E[I];
        if (N != 0) {
            M = dp_vtoe(vector_unit(Len,I));
            for(J=0; J<N; J++) {
                S = multi(S, M-J);
            }
            D *= op_var(I)^N;
        }
    }
    C = red(C/D);
    return [nm(C)*S*B, dn(C)];
}

/* --------------------------------
   Following functions for Hypergeometric series.
   -------------------------------- */

/*
length(Index) <= length(AT)==length(car(A))
Example:
A = [[1,1,1],[0,1,2]]; AT = [b1,0,b2]; Index=[1];
yang.a2k(A,AT,Index) => [ [1/2*_k0,-_k0,1/2*_k0], [_k0] ]
*/

def a2k(A, AT, Index) {
    K  = list_add_prefix("_k", list_incr(0,length(Index)));
    U  = list_add_prefix("__", list_incr(0,length(AT)));
    Eq = vtol(matrix_list_to_matrix(A)*ltov(U));
    for(KK=K; KK != []; KK=cdr(KK),Index=cdr(Index)) {
        I  = car(Index);
        /* E  = U[I]-AT[I]+car(KK); */
        E  = U[I]-AT[I]-car(KK);
        Eq = cons(E, Eq);
    }
    return [map(list_second, poly_solve_linear(Eq, U)), K];
}

/* 入力: 多項式のリスト AT,  変数のリスト B
   出力: AT のインデックス I のリスト s.t. AT[I] は B を含まない.
*/
def sigma(AT, B) {
    for(L = [], I = 0; AT != []; AT = cdr(AT), I++) {
        if ( !ispoly_of_vars(car(AT),B) ) {
            L = cons(I, L);
        }
    }
    return reverse(L);
}

def gen_gamma(AV,KV)
"gen_gamma([a1,a2,a3],[n1,n2,n3]) ==> [[a1,n1,-1],[a2,n2,-1],[a3,n3,-1]]"
{
    if (isvect(AV)) AV = vtol(AV);
    if (isvect(KV)) KV = vtol(KV);
    return map(append, assoc(AV,KV), [-1]);
}

/* N >= 0 */
def pochhammer(A,N) {
    P=1;
    for(I=0; I<N; I++) {
        P *= (A+I);
    }
    return P;
}

/* Arguments N and E are integers.
if A is an integer, then the return value is $\Gamma(A+N)^E$.
if A is not, then the value is $(\Gamma(A+N)/\Gamma(A))^E$.
*/
def eval_gamma(A,N,E)
"Evaluate Gamma factors using Pochhammer symbols.\n\
eval_gamma(A,N,E) ==> $\Gamma(A+N)^E$ or $\Pochhammer(A+N)^E$."
{
    if (!isnum_int(N) || !isnum_int(E)) {
        error("invlid arguments.");
    }
    if (!isnum_int(A)) {
        return (N<0)? pochhammer(A+N,-N)^(-E): pochhammer(A,N)^E;
    }else {
        A+=N;
        if (A<=0) {
            return (E<0)? 0: error("invalid argument. (pole)");
        }
        return fac(A-1)^E;
    }
}

def gamma1(L)
"[u, [a1,n1,e1],[a2,n2,e2]] => u*eval_gamma1(a1,n1,e1)*eval_gamma1(a2,n2,e2)"
{
    for(G=1 ; L != []; L=cdr(L)) {
        LL = car(L);
        G *= (islist(LL))? call(eval_gamma,LL): LL;
    }
    return G;
}

def gamma2(L)
"[u, [a1,n1,e1],[a2,n2,e2]] => u*(gamma(a1+n1)^e1)*(gamma(a2+n2)^e2)"
{
    for(G=1 ; L != []; L=cdr(L)) {
        LL = car(L);
        G *= (islist(LL))? gamma(LL[0]+LL[1])^LL[2]: LL;
    }
    return G;
}

/* GKZ = [A,B] */

def series(MaxDeg, GKZ, W, AT) {
    return series_algorithm3(MaxDeg, GKZ, W, AT);
}

/* gm/series.tex: Algorithm 1 */
def series_algorithm1(MaxDeg, GKZ, W, AT) {
    LenAT = length(AT);
    Index = sigma(AT, GKZ[1]);
    LenIndex = length(Index);
    U = a2k(GKZ[0], AT, Index);
    K = U[1]; U = U[0];
    F = [];
    for(Ks = pattern_full(MaxDeg, LenIndex); Ks != []; Ks = cdr(Ks)) {
        K0 = car(Ks);
        U0 = ltov(base_replace(U, assoc(K, K0)));
        IP = vector_inner_product(U0, W);
        if(IP >= 0 && all_integers(U0)) {
            C = gen_gamma(AT,U0);
            F = cons([C, U0], F);
        }
    }
    return reverse(F); /* HG Series == (1/Gamma(AT))*x^AT * ( F + ... ) */
}

def series_algorithm3(MaxDeg, GKZ, W, AT) {
    LenAT = length(AT);
    Index = sigma(AT, GKZ[1]);
    LenIndex = length(Index);
    U = a2k(GKZ[0], AT, Index);
    K = U[1]; U = U[0];
    F = [];
    for(Ks = pattern_full(MaxDeg, LenIndex); Ks != []; Ks = cdr(Ks)) {
        K0 = car(Ks);
        U0 = ltov(base_replace(U, assoc(K, K0)));
        IP = vector_inner_product(U0, W);
        if(IP >= 0 && all_integers(U0)) {
            C = gen_gamma(AT,U0);
            F = cons([list_sum(K0), IP, C, U0], F);
        }
    }
    F = map('cdr', map('cdr', qsort(F)));
    return F; /* HG Series == (1/Gamma(AT))*x^AT * ( F + ... ) */
}

def vector_to_rat(E,V,N) {
    for(P = 1, I = 0; I < N; I++) {
        P *= V[I]^E[I];
    }
    return P;
}

/* Series: series() の出力 */
def series1(Series) {
    N = length(car(Series)[1]);
    V = list_add_prefix("x", list_incr(0,N));
    for(L = []; Series != []; Series = cdr(Series)) {
        C = car(Series);
        G = red(gamma1(C[0])); E = C[1];
        if (G != 0) {
            L = cons([G,vector_to_rat(E,V,N)],L);
        }
    }
    return reverse(L);
}

/* Series: series() の出力 */
def series2(Series) {
    N = length(car(Series)[1]);
    V = list_add_prefix("x", list_incr(0,N));
    for(L = []; Series != []; Series = cdr(Series)) {
        C = car(Series);
        G = red(gamma2(C[0])); E = C[1];
        if (G != 0) {
            L = cons([G,vector_to_rat(E,V,N)],L);
        }
    }
    return reverse(L);
}

def pattern(M, N)
"Example: pattern(3,2) => [[3,0],[2,1],[1,2],[0,3]]"
{
    V = list_add_prefix("u",list_incr(0,N));
    for(L = [], F = dp_ptod(list_sum(V)^M, V); F != 0; F = dp_rest(F)) {
        L = cons(vtol(dp_etov(dp_ht(F))), L);
    }
    return reverse(L);
}

def pattern_full(M, N)
"Example: pattern_full(3,2) => \
[[0,0],[0,1],[1,0],[0,2],[1,1],[2,0],[0,3],[1,2],[2,1],[3,0]]"
{
    V = list_add_prefix("u",list_incr(0,N));
    G = list_sum(V);
    for(F = 0, I = 0; I <= M; I++) {
        F += G^I;
    }
    for(L = [], F = dp_ptod(F, V); F != 0; F = dp_rest(F)) {
        L = cons(vtol(dp_etov(dp_ht(F))), L);
    }
    return L;
}

static PatternCache;
/* 
PatternCache is used by pattern_weight() and has a structure as
[Length, Max,Pattern, Max].
If M=4 and C=[3,2,1], then PatternCache is the following list:
[3,4,[[[4,0,0],12],[[3,1,0],11],[[2,2,0],10],[[1,3,0],9],[[0,4,0],8],[[3,0,1],10],[[2,1,1],9],[[1,2,1],8],[[0,3,1],7],[[2,0,2],8],[[1,1,2],7],[[0,2,2],6],[[1,0,3],6],[[0,1,3],5],[[0,0,4],4],[[3,0,0],9],[[2,1,0],8],[[1,2,0],7],[[0,3,0],6],[[2,0,1],7],[[1,1,1],6],[[0,2,1],5],[[1,0,2],5],[[0,1,2],4],[[0,0,3],3],[[2,0,0],6],[[1,1,0],5],[[0,2,0],4],[[1,0,1],4],[[0,1,1],3],[[0,0,2],2],[[1,0,0],3],[[0,1,0],2],[[0,0,1],1],[[0,0,0],0]]]
*/

def pattern_weight(M,C) {
    N = length(C);
    if (!islist(PatternCache) || PatternCache[0] != N) {
        for(P=[],I=0; I<=M; I++) {
            Pat = pattern(I,N);
            P = append(assoc(Pat,map(vector_inner_product,Pat,C)),P);
        }
        PatternCache = [N,M,P];
    }else if (PatternCache[1] < M) {
        for(P=PatternCache[2],I=PatternCache[1]+1; I<=M; I++) {
            Pat = pattern(I,N);
            P = append(assoc(Pat,map(vector_inner_product,Pat,C)),P);
        }
        PatternCache = [N,M,P];
    }
    print(PatternCache);
    for(L=[], P=PatternCache[2]; P != []; P = cdr(P)) {
        H = car(P);
        if(H[1]==M) {
            L=cons(H[0],L);
        }
    }
    return L;
}

/* ベクトル V の全ての要素が整数ならば 1, それ以外で 0. */
def all_integers(V) {
    Len = length(V);
    for(I=0; I<Len; I++) {
        N = V[I];
        if(!isnum_int(N)) {
            return 0;
        }
    }
    return 1;
}

/* --------------------------------
   Following functions are imported from ohara_std.rr
   -------------------------------- */

def 'std_+'(A,B) {
    return A+B;
}

def 'std_*'(A,B) {
    return A*B;
}

def 'std_='(Null, Val) {
    return Val;
}

def list_incr(Start,Max) {
    L = [];
    for(I=Max-1; I>=Start; I--) {
        L = cons(I, L);
    }
    return L;
}

def list_sum(L) {
    Sum = 0;
    for( ; L != []; L = cdr(L)) {
        Sum += car(L);
    }
    return Sum;
}

def list_second(L) {
    return SECOND(L);
}

def list_add_prefix(P,L)  {

	return map(strtov, mapat('std_+', 1, P, map(rtostr, L)));
}

def vector_unit(N, I) {
    V = newvect(N);
    V[I] = 1;
    return V;
}

def vector_sum(V) {
    N = length(V);
    Sum = 0;
    for(I=0; I<N; I++) {
        Sum += V[I];
    }
    return Sum;
}

def vector_inner_product(U,V)
"(U,V) ==> inner_product as vector."
{
    N = length(U);
    Sum = 0;
    for(I=0; I<N; I++) {
        Sum += U[I]*V[I];
    }
    return Sum;
}

def vector_shorten(N,V)
"Shorten the size of a vector V to N."
{
	U = newvect(N);
	for(I = 0; I < N; I++) {
		U[I] = V[I];
	}
    return U;
}

def vector_const(Len,Value) {
    V = newvect(Len);
    for(I=0; I<Len; I++) {
        V[I] = Value;
    }
    return V;
}

def vector_split(V)
"Splits a vector V to positive and negative parts."
{
    N=length(V); Pos=newvect(N); Neg=newvect(N);
    for(I=0; I<N; I++) {
        if (V[I]>0) {
            Pos[I] = V[I];
        }else {
            Neg[I] = V[I];
        }
    }
    return [Pos, Neg];
}

endmodule;

end$
