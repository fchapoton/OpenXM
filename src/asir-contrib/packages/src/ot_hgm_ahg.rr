/* $OpenXM: OpenXM/src/asir-contrib/packages/src/ot_hgm_ahg.rr,v 1.8 2014/05/23 06:49:54 ohara Exp $
  Applying the HGM for A-hypergeometric system by a sylvester matrix like method.
  Imported from h-mle/A-hg/Prog/disc5.rr, cbase.rr
  ot_ = oh_ & tk_
*/

import("names.rr")$
import("nk_toric.rr")$
import("tk_sm1emu.rr")$
import("tk_cc111.rr")$
import("oh_base.rr")$
import("oh_number.rr")$

#include <defs.h>

extern Disc_Supp2$
extern Disc_Toric$
extern Disc_R$
extern Disc_R1$
extern Disc_R2$

def cbase(A) {
  W=[[dx1, 1]]; /* dummy */
  T0=mytoric(A,W);
  E=T0[0];
  T=T0[1];
  V=T0[2]; Vb=T0[3]; Vd=add_d(V); 
  Gt=nd_gr(T,Vd,0,0);
  dp_ord(0); /* rev lex */
  T2=map(dp_ptod,Gt,Vd); T2=map(dp_ht,T2); T2=map(dp_dtop,T2,Vd);

  Er=base_replace(E,genrule_p(Vb)); /* prob method */
  printf("We use a probabilistic algorithm to determine the base."); /*Er=E;*/
  print(T2);
  OrdM=poly_r_omatrix(length(V));
  Vall=append(V,Vd);
  G=nd_weyl_gr(append(Er,T2),Vall,0,OrdM);
  G1=G;
  for (I=0; I<length(V); I++) {
    G1=map(poly_in_w,G1,Vall,OrdM[I]);
  }  
  dp_ord(0);
  Gin = map(dp_ht,map(dp_ptod,G1,Vd)); Gin_p=map(dp_dtop,Gin,Vd);
  Std = dp_mbase(Gin); Std=map(dp_dtop,Std,Vd);
  return Std;
}

def ctest1() {
 A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  B=cbase(A);
  return B;
}

def genrule_1(V) {
  R=[];
  for (I=0; I<length(V); I++) {  
    R = cons([V[I],1],R);
  }
  return reverse(R);
}
def genrule_p(V) {
  R=[]; P1=2;
  for (I=0; I<length(V); I++) { 
    P1 = pari(nextprime,P1+1); 
    P2 = pari(nextprime,P1+1);
    R = cons([V[I],P1/P2],R);
    P1 = P2;
  }
  return reverse(R);
}
/*
genrule_1([x,y,z]);
genrule_p([b1,b2,b3]);
ctest1();
*/

def ctest2() {
  A=[[1,1,1,1,1],[0,1,2,3,4]];
  Std=cbase(A);
  printf("Std=%a\n",Std);
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1]]; 
  Mset=append(Std,[dx2]);
  return get_mat(A,W,Std,Mset);
}
/*
R=ctest2();
matrix_rank(R);  We get a full rank matrix.
*/

def ctest3() {
  A=[[1,1,1,1],[0,1,3,4]];
  Std=cbase(A);
  printf("Std=%a\n",Std);
  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; 
  Mset=append(Std,[dx2,dx1,dx1*dx2,dx1*dx3,dx1*dx4,dx2*dx3,dx2*dx4,dx3*dx4,
                   dx1^2,dx2^2,dx3^2]);  /* 30x23, rank 23 の行列. 解ける. std が dx4^2 まであるので 2 次を全部とってきた. */
  return get_mat(A,W,Std,Mset);
}

/* 
R=ctest3();
matrix_rank(R);
*/

def ctest4() {
  A=[[1,1,1],[0,1,2]];
  Std=cbase(A);
  printf("Std=%a\n",Std);
  W=[[dx1,1,dx2,1,dx3,1]]; 
  Mset=append(Std,[1,dx1,dx2,dx3]);
  return get_mat(A,W,Std,Mset);
}

def ctest5() {
 A = [[1,0,0,1,1,0,1],
      [0,1,0,1,0,1,1],
      [0,0,1,0,1,1,1]];
 /* confluent type of ctest1() */
  B=cbase(A);
  return B;
}

/*
  mytoric(A,W)
  [euler,toric,V,Vb,weight_vec,toric_init_by_weight_vec] 
*/

def mytoric(A,W) {
  En=length(A);
  Gkz=tk_sm1emu.gkz([A,vtol(newvect(En))]);
  V=Gkz[1];
  T=Gkz[0];
  E=[]; Vb=[];
  for (I=0; I<En; I++) { E=cons(car(T)-util_v(b,[I+1]),E); T=cdr(T); Vb=cons(util_v(b,[I+1]),Vb);}
  E=reverse(E);  Vb=reverse(Vb);
  T=tk_sm1emu.gb([T,V,W]);
  return [E,T[0],V,Vb,W,T[1]];
  /* [euler,toric,V,Vb,weight_vec,toric_init_by_weight_vec] */
}

def test1() {
  A=[[1,1,1,1],[0,1,2,3]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1]];
  /* W=[[dx1,100,dx2,30,dx3,3]]; */
  F=mytoric(A,W);
  print(F[1]);
  print(map(get_support,F[1],[dx1,dx2,dx3,dx4]));
  return F;
}

def get_support(F,V) {
  if (type(F) >= 4) {
     T=map(get_support,F,V);
     return merge(T);
  }
  if (dn(F) != 1) error("get_support: argument cannot be a rational.");
  F=dp_ptod(F,V);
  S=[];
  while (F != 0) {
    M=dp_ht(F); F=dp_rest(F);
    M=dp_dtop(M,V);
    if (!base_memberq(M,S)) S=cons(M,S);
  }
  return(S);
}

/* coef of M in F */
def mcoef(F,M,V) {
  for (I=0; I<length(V); I++) {
    F=coef(F,deg(M,V[I]),V[I]);
  }
  return F;
}

def test2() {
  F=(dx1+dx2+dx3+a)^4;
  V=[dx1,dx2,dx3];
  print(get_support(F,V));
  return mcoef(F,dx1*dx2^2,[dx1,dx2]);
}

def add_d(V) {
  Dv = newvect(length(V));
  for (I=0; I<length(V); I++) {
    Dv[I] = eval_str("d"+rtostr(V[I]));
  }
  return vtol(Dv);
}

def merge(Varray) {
  A=[];
  for (I=0; I<length(Varray); I++) {
    V=Varray[I];
    for (J=0; J<length(V); J++) {
      if (!base_memberq(V[J],A)) A=cons(V[J],A);
    }
  }
  return reverse(A);
}

/*
 P=get_mat2(A,W,Std,Mset); の時
 Mat=P[0]; RM=P[1]; Supp2=P[2]; とおくと,
 Mat*Supp2 = RM*Std
 が成り立つ.  cf. test3b();
*/
def get_mat2(A,W,Std,Mset) {
  if (Mset == 0) Mset=Std;
  E=mytoric(A,W);
  /* [euler,toric,V,Vb,weight_vec,toric_init_by_weight_vec] */
  Disc_Toric=E;
  Euler=E[0];
  Toric=E[1];
  V=E[2]; Vb=E[3];  Vall=append(V,Vb);
  Vd = add_d(V);
  G=[];
  /* Mset を Euler 作用素に掛けて Toric で reduction する. 行列式の素 */ 
  for (I=0; I<length(Euler); I++) {
    for (J=0; J<length(Mset); J++) {
      F = tk_sm1emu.mul(Mset[J],Euler[I],Vall);
      Fn= tk_sm1emu.reduction([F,Toric,Vall,W])[0];
      G = cons(Fn,G);
    }
  }
  G=reverse(G);
  R = newvect(length(G));
  for (I=0; I<length(G); I++) R[I]=G[I];
  /* G から行列を作る. 右辺は R. */
  Supp = get_support(G,Vd);
  printf("Support=%a, Std=%a \n",Supp,Std);
  Supp2 = base_set_minus(Supp,Std);
  /* Supp2 を 縦の index とする行列を作る */
  Disc_Supp2=Supp2; 
  Mat = newmat(length(G),length(Supp2));
  printf("size=%a\n",size(Mat));
  for (I=0; I<length(G); I++) {
    for (J=0; J<length(Supp2); J++) {
       Mat[I][J] = mcoef(G[I],Supp2[J],Vd);
       R[I] = R[I] - Mat[I][J]*Supp2[J];
    }
  }
  for (I=0; I<length(G); I++) R[I]=-R[I];
  /* 右辺を RM*Std なる行列表示にする. 1 の係数も OK. */
  RM = newmat(length(G),length(Std));
  for (I=0; I<length(G); I++) {
    for (J=0; J<length(Std); J++) {
       RM[I][J] = mcoef(R[I],Std[J],Vd);
    }
  }
  /* Mat*Supp2-RM*Std=G=0? */
  /* mycheck(Mat,RM,Supp2,Std,G) ;*/

  return [Mat,RM,Supp2];
}

def get_mat(A,W,Std,Mset) {
  return get_mat2(A,W,Std,Mset)[0];
}

def mycheck(Mat,RM,Supp2,Std,G) {
  B=Mat*newvect(length(Supp2),Supp2)-RM*newvect(length(Std),Std);
  N=length(B);
  for (I=0; I<N; I++) {
    if (B[I]-G[I]!=0) error("mycheck error");
  }
}

def test3() {
  A=[[1,1,1,1],[0,1,2,3]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1]];
  /* return get_mat(A,W,[1,dx3,dx4],0);*/
  return get_mat(A,W,[1,dx3,dx4],[1,dx2,dx3,dx4]);
}

def test3b() {
  A=[[1,1,0,0],
     [0,0,1,1],
     [1,0,1,0],
     [0,1,0,1]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1]];
  return get_mat2(A,W,[1,dx4],[1,dx4,dx3]);
}


def test4() {
 /* from ud-c11.rr */
 A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  W=[[dx1,1],[dx2,1],[dx3,1],[dx4,1],[dx5,1],[dx6,1],[dx7,1],[dx8,1]];
  /* return get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx8^2],0);  orange3m 24x31, rank is 24 */
  Mset=[1,dx5,dx6,dx7,dx8,dx8^2,dx1,dx2,dx3,dx4];  /* 40x38, but rank is 34 */
  Mset=[1,dx5,dx6,dx7,dx8,dx8^2];
  return get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx8^2],Mset);
}

def test5() {
  /* This std is buggy. 2013-10-06 */
 /* from ud-c11.rr */
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; /* use rev lex */
  /* Mset=[1,dx5,dx6,dx7,dx8,dx6*dx7];   24x32 rank=24 */
  Mset=[1,dx5,dx6,dx7,dx8,dx6*dx7,dx1,dx2,dx3,dx4];  /* 40x39, rank=34 */
  return get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx6*dx7],Mset);
}
/*
R=test5();
matrix_rank(R);
*/

def test6() {
 /* from ud-c11.rr */
  A = [[1,1,1,1,1,1,1,1],
     [0,1,0,0,1,1,0,1],
     [0,0,1,0,1,0,1,1],
     [0,0,0,1,0,1,1,1]];
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; /* use rev lex */
  Mset=[1,dx5,dx6,dx7,dx8, 
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8];
           /* 176*93, rank=93  */
  Disc_R=get_mat(A,W,[1,dx5,dx6,dx7,dx8,dx8^2],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6,x7,x8];
  Vb=[b_1,b_2,b_3,b_4];
  /* load cbase.rr */
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return matrix_rank(base_replace(Disc_R,R1));
}
def test6c() {  /* confluent test6. cf. Notes/c11.tex */
 /* from ud-c11.rr */
  A = [
     [1,0,0,1,1,0,1],
     [0,1,0,1,0,1,1],
     [0,0,1,0,1,1,1]];
  printf("Std=%a\n",cbase(A));
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
  Mset=[1,dx5,dx6,dx7, 
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
                                           dx5*dx5,dx5*dx6,dx5*dx7,
                                                   dx6*dx6,dx6*dx7,
                                                           dx7*dx7];
  /* 108x58, rank=58 */
  Disc_R=get_mat(A,W,[1,dx7,dx6,dx5,dx4,dx7^2],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6,x7];
  Vb=[b_1,b_2,b_3];
  /* load cbase.rr */
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return matrix_rank(base_replace(Disc_R,R1));
}

/* 乱数で選んだベクトルで non-sigular submatrix を探す.
--> これはうまくいかない. やはり一次独立なものを足していくのがいいんだろう. */
def ns_submat(Mat) {
  if (type(Mat) == 4) Mat = matrix_list_to_matrix(Mat);
  M=size(Mat)[0]; N=size(Mat)[1];
  /* Choose N rows from M rows, N<=M. The result should be non-singular mat. */
  Idx=newvect(N);
  while (1) {
    for (I=0; I<N; I++) Idx[I]=-1;
    J=0;
    while (J<N) {
      R=random() % M;
      if (!base_memberq(R,Idx)) {Idx[J]=R; J++;}
    }
    printf("Idx=%a\n",Idx);
    Smat = matrix_submatrix(Mat,Idx);
    if (matrix_rank(Smat) == N) break;
  }
  return [Smat,Idx];
}

def test7() {
  /* 00,01,10,11,12,21,22 */
  A=[
     [1,1,0,0,0,0,0],
     [0,0,1,1,1,0,0],
     [0,0,0,0,0,1,1],
     [1,0,1,0,0,0,0],
     [0,1,0,1,0,1,0]];
  Std=cbase(A);
  printf("Std=%a\n",Std); /* [], 4,7,47 rank=4. */
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
  Mset=[1,dx1,dx2,dx3,dx4,dx5,dx6,dx7];
  /* Mset=[1,dx4,dx7,dx1];   not good. */
  Disc_R=get_mat(A,W,[1,dx4,dx7,dx4*dx7],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6,x7];
  Vb=[b_1,b_2,b_3,b_4,b_5];
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return [matrix_rank(base_replace(Disc_R,R1)),Std];
}

def test8() {
  A=[
     [1,1,0,0],
     [0,0,1,1],
     [1,0,1,0]];
  Std=cbase(A);
  printf("Std=%a\n",Std); /* [], 4 rank=2. */
  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; /* use rev lex */
  Mset=[1,dx4,dx2];  /* [1,dx4,dx3]; also works */
  Disc_R=get_mat(A,W,[1,dx4],Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4];
  Vb=[b_1,b_2,b_3];
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return [matrix_rank(base_replace(Disc_R,R1)),Std];
}

/* 2014-01-30, 18:07, see also photo */
def test9() {
  B=[
     [x10,x11,  0,    0,  0,   0],
     [    0,x11,x01,  0,  0,   0],
     [    0,    0,x01,x10,0,   0],
     [    0,    0,   0,x10,x00,0],
     [    0,    0,   0,   0,x00,x01],
     [x10,    0,    0,   0,   0,x00]]; /* by toric reduction, it is not x01 */
  return det(matrix_list_to_matrix(B));
}

def test10() {
  A=[
     [1,1,1,0,0,0],
     [0,0,0,1,1,1],
     [1,0,0,1,0,0],
     [0,1,0,0,1,0]
   ];
  Std=cbase(A);
  printf("Std=%a\n",Std); /* [], 5,6 rank=3. */
  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1]]; /* use rev lex */
  Mset=[1,dx5,dx6,dx4];
  Disc_R=get_mat(A,W,Std,Mset);
  printf("size of R is %a\n",size(Disc_R));
  V=[x1,x2,x3,x4,x5,x6];
  Vb=[b_1,b_2,b_3,b_4];
  R1=genrule_p(append(V,Vb)); Disc_R1=R1;
  return [matrix_rank(base_replace(Disc_R,R1)),Std];
}


/*
MatData = get_mat2(A,W,StdMon,Mset);
Eqn = get_eqn(MatData);
*/
def get_eqn(MatData) {
    M0=MatData[0];
    M1=MatData[1];
    T=base_var_list(tt_,1,size(M0)[1]);
    S=base_var_list(ss_,1,size(M1)[1]);
    L = vtol(M0*ltov(T)-M1*ltov(S));
    return [L,T,S];
}

def get_eqn2(MatData,Xall,Param) {
    Eqn_LTS = get_eqn(MatData);
    L  = Eqn_LTS[0];
    TT = Eqn_LTS[1];
    SS = Eqn_LTS[2];
    L  = base_replace(L,assoc(Xall, Param));
    if(getopt(solve)==yes) {
        L = poly_solve_linear(L,TT);
    }
    return [L,TT,SS];
}


/* 例: ベクトル値関数 f(t; x1,x2) = (t^2+x1,-x1-t*x2)
   FuncArgs = [ ltov([t^2+x1, -x1-x2*t]), [ [t], [x1,x2] ] ]
   Vals = [ [3/2], [-2, 1.5] ]
*/
def call_func(FuncArgs,Vals) {
    F    = FuncArgs[0];
    Args = FuncArgs[1];
    N = length(Args); /* == length(Vals) */
    if(N>length(Vals)) {
        error("call_func: invalid arguments.\n");
        return 0;
    }
    for(I=0; I<N; I++) {
        V = isvect(Vals[I])? vtol(Vals[I]): Vals[I];
        F = base_replace(F,assoc(Args[I],V));
    }
    return F;
}

/* 
例: ベクトル値関数 f(a; x1,x2) = (a^2+x1+b1,-x1-a*x2+b2)
   ただし、(b1,b2) は連立方程式 
   2*x1*b1+t*b2 -1    = 0,  
   (3*t+1)*b1-x2*b2+3 = 0 
   の解とする。(t,x1,x2がパラメータ)

   Eqn = [ [2*x1*b1+t*b2-1, (3*t+1)*b1-x2*b2+3], [b1,b2], [t,x1,x2] ]
   FuncArgs = [ ltov([t^2+x1+b1, -x1-t*x2+b2]), [ [t], [x1,x2] ], Eqn ]
   Vals = [ [3/2], [-2, 1.5] ]
*/
def call_func_eqn(FuncArgs,Vals) {
    F    = FuncArgs[0];
    Args = FuncArgs[1];
    Eqn  = FuncArgs[2];
    Eq   = Eqn[0]; /* 線形方程式 Eq(S,X) = 0 ここで S はパラメータ */
    X    = Eqn[1];
    S    = Eqn[2]; /* 明示的に使わない.  S と同じものが Args に含まれるようにしておく */
    N    = length(Args); /* == length(Vals) */

    /* パラメータへの値の設定 */
    if(N>length(Vals)) {
        error("call_func: invalid arguments.\n");
        return 0;
    }
    for(I=0; I<N; I++) {
        V   = isvect(Vals[I])? vtol(Vals[I]): Vals[I];
        Rel = assoc(Args[I],V);
        F   = base_replace(F, Rel);
        Eq  = base_replace(Eq,Rel);
    }
    /* Eq(X)=0 を X について解く */
    Sol = poly_solve_linear(Eq,X);
//  printf("X=%a\nSol=%a\n\n",X,map('car',Sol));
    F = base_replace(F,Sol);
    return F;
}

def float2rat(F,N) {
    Dn=10^N;
    Nm=rint(F*Dn);
    return Nm/Dn;
}

def factor_prime(F) {
    if(islist(F)) {
        F = base_flatten(map(factor_prime, F));
        return uniq(qsort(F));
    }
    return map('car',cdr(fctr(F)));
}

def factor_mul(F) {
    if(islist(F)) {
        G=car(F);
        for(F=cdr(F); F!=[]; F=cdr(F)) {
            G=lcm(G,car(F));
        }
        F=G;
    }
    return cdr(fctr(F));
}

/* from test6c */
def test19 () {  /* confluent test6. cf. Notes/c11.tex */
    /* from ud-c11.rr */
    A = [
        [1,0,0,1,1,0,1],
        [0,1,0,1,0,1,1],
        [0,0,1,0,1,1,1]];
//  printf("Std=%a\n",cbase(A));
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7,
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
          dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
          dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
          dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
          dx5*dx5,dx5*dx6,dx5*dx7,
          dx6*dx6,dx6*dx7,
          dx7*dx7];
    V=[x1,x2,x3,x4,x5,x6,x7];
    Vb=[b_1,b_2,b_3];
    Vall = append(V,Vb);

    /* 108x58, rank=58 */
    StdMon = [1,dx7,dx6,dx5,dx4,dx7^2];
    DV=[dx1,dx2,dx3,dx4,dx5,dx6,dx7];
    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;

    Vall = append(V,Vb);
    Dir = [-10/11,-13/10,-8/7,(-41/43)*z,(-10/12)*z,(-25/23)*z,(-37/39)*z];
    DzDir = map(diff,Dir,z);
    Bdat = [-15/10, -26/10, -37/10];
    Pall = append(Dir, Bdat);
    Sol = get_eqn2(Disc_R2,Vall,Pall | solve=yes);
    TT = Sol[1];
    SS = Sol[2];

    Toric=mytoric(A,W)[1];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    NV= length(DV);
    NM = length(StdMon);
    Pf = newvect(NV);
    for(I=0; I<NV; I++) {
        Pf[I] = DV[I]*ltov(StdMon);
        Pf[I] = mapat(oh_base.assoc_match,1,Table,Pf[I]);
    }

    Pf=vtol(Pf);
    P = 0;
    for(I=0; I<NV; I++) {
        P += DzDir[I]*Pf[I];
    }
    P = base_replace(P,Sol[0]);
    Func=[P,[[z],SS]];

#if 1
    /* an initial value at Z=0.001 */
//  InitValFloat=[ 1.833962, 18.984250, 11.719908, 9.602990, 5.922814, 565.608369];
    InitValFloat=[ 1.834885668779896312, 
                   18.96517485446140242, 
                   11.70294822085786770, 
                   9.609467131879854119, 
                   5.920492560166507569, 
                   564.0635393469870808 ];    /* 同じ場所．漸近展開による. */
    InitVal=map(float2rat,InitValFloat,6);
    Z = 1/10^3;
    H = 1/10^6;
    Zs = Z;
	Ze = 1/10;
#endif

#if 0
    /* an initial value at Z=0.1 */
    InitValFloat=[0.457392904554, 1.305954410928, 1.533103031020, 1.067058892481, 0.595251972063, 7.940707579700];
    InitVal=map(float2rat,InitValFloat,12);
    Z = 1/10;
    H = 1/10^4;
    Zs = Z;
	Ze = 25/100;
#endif

    DD = vtol(map(dn,Func[0]));
    Sing = factor_mul(DD);
    printf("Sing=%a\n\n",factor_mul(DD));
    /* 
       Sing=[
	   [z,3],
	   [5863*z-6364,1],
	   [11375*z-13616,1],
	   [30750*z-36593,1],
       [8203069875000*z^3-21363737113875*z^2+16469565786088*z-3170864832832,1]];
     */
    for(L=newvect(length(Sing)),I=0; I<length(Sing); I++) {
        L[I]=pari(roots, Sing[I][0]);
    }
    L=base_flatten(L);
    printf("SingPt=%a\n\n",L);
    /* 
       SingPt=[
       0,
       1.0854511342316220365000852805730854511,
       1.1970109890109890109890109890109890109,
       1.1900162601626016260162601626016260162,
       0.28859221237897573162896079748555733032,
       1.1221912832930888237338607023425237366,
       1.1935752918818449497661958243111942918];
    */

    InitVal=InitValFloat;
    Graph = runge_kutta_linear2(Func,Zs,InitVal,Ze,H);
    return Graph;
}

/* from test6c */
def test20 () {  /* confluent test6. cf. Notes/c11.tex */
    /* from ud-c11.rr */
    A = [
        [1,0,0,1,1,0,1],
        [0,1,0,1,0,1,1],
        [0,0,1,0,1,1,1]];
//  printf("Std=%a\n",cbase(A));
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7,
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
          dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
          dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
          dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
          dx5*dx5,dx5*dx6,dx5*dx7,
          dx6*dx6,dx6*dx7,
          dx7*dx7];
    V=[x1,x2,x3,x4,x5,x6,x7];
    Vb=[b_1,b_2,b_3];
    Vall = append(V,Vb);

    /* 108x58, rank=58 */
    StdMon = [1,dx7,dx6,dx5,dx4,dx7^2];
    DV=[dx1,dx2,dx3,dx4,dx5,dx6,dx7];
    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;

    Vall = append(V,Vb);
    Dir = [-10/11,-13/10,-8/7,(-41/43)*z,(-10/12)*z,(-25/23)*z,(-37/39)*z];
    DzDir = map(diff,Dir,z);
    Bdat = [-15/10, -26/10, -37/10];
    Pall = append(Dir, Bdat);
    Eqn = get_eqn2(Disc_R2,Vall,Pall);
    TT = Eqn[1];
    SS = Eqn[2];

    Toric=mytoric(A,W)[1];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    NV= length(DV);
    NM = length(StdMon);
    Pf = newvect(NV);
    for(I=0; I<NV; I++) {
        Pf[I] = DV[I]*ltov(StdMon);
        Pf[I] = mapat(oh_base.assoc_match,1,Table,Pf[I]);
    }
    Pf=vtol(Pf);
    P = 0;
    for(I=0; I<NV; I++) {
        P += DzDir[I]*Pf[I];
    }
    Func=[P,[[z],SS],Eqn];

#if 1
    /* an initial value at Z=0.001 */
//  InitValFloat=[ 1.833962, 18.984250, 11.719908, 9.602990, 5.922814, 565.608369];
    InitValFloat=[ 1.834885668779896312, 
                   18.96517485446140242, 
                   11.70294822085786770, 
                   9.609467131879854119, 
                   5.920492560166507569, 
                   564.0635393469870808 ];    /* 同じ場所．漸近展開による. */
    InitVal=map(float2rat,InitValFloat,6);
    Z = 1/10^3;
    H = 1/10^6;
    Zs = Z;
	Ze = 1/10;
#endif

#if 0
    /* an initial value at Z=0.1 */
    InitValFloat=[0.457392904554, 1.305954410928, 1.533103031020, 1.067058892481, 0.595251972063, 7.940707579700];
    InitVal=map(float2rat,InitValFloat,12);
    Z = 1/10;
    H = 1/10^4;
    Zs = Z;
	Ze = 25/100;
#endif

//  return map(deval,call_func_eqn(Func,[[Z],InitVal]));
    Graph = runge_kutta_linear2(Func,Zs,InitVal,Ze,H | callf=call_func_eqn );
    return Graph;
}

def mk_table(DV,StdMon,MonTT,Toric,Vall,W,SS,TT) {
    NV=length(DV);
    NB=length(StdMon);
    L=[];
    for(I=0; I<NB; I++) {
        for (J=0; J<NV; J++) {
            L=cons(DV[J]*StdMon[I],L);
        }
    }
    L = uniq(qsort(L));

    /* L の各要素を StdMon, MonTT で表わす.
       そのためにまずは TT, SS で表わす. */
    if((Pos=base_position(1,StdMon))<0) {
        printf("invalid argument. (StdMon=%a).\n",StdMon);
        return []; /* error */
    }
    MM = append(MonTT, base_prune(1, StdMon));
    RR = append(TT, base_prune(SS[Pos], SS));

    L = base_set_minus(L,MM);
    Lred = ltov(L);
    for(I=0; I<length(Lred); I++) {
        Lred[I] = tk_sm1emu.reduction([Lred[I],Toric,Vall,W])[0]; /* */
    }
    N = length(Lred);
    for(I=0; I<N; I++) {
        C=Lred[I];
        if((Pos = base_position(C,MM))>=0) {
            Lred[I] = RR[Pos];
        }else if ((Pos = base_position(-C,MM))>=0) {
            Lred[I] = -RR[Pos];
        }else {
            printf("invalid data.\n");
        }
    }
    Lred = vtol(Lred);

    MM = append(MM,L);
    RR = append(RR,Lred);
    return assoc(MM,RR);
}

def normalize(F) {
    return dp_hc(dp_ptod(F,vars(F)))<0? -F: F;
}

def uniq(L) {
    N=length(L);
    if(N>1) {
        C=L[0];
        R=[C];
        for(I=1; I<N; I++) {
            if(C!=L[I]) {
                C=L[I];
                R=cons(C,R);
            }
        }
        L=reverse(R);
    }
    return L;
}

def number_sign(X) {
    return (X==0)? 0: (X<0)? -1: 1;
}

#define _getopt(X,Y) (type(getopt(X))<0? (Y): getopt(X))

def runge_kutta_linear2(FuncArgs,Xs,Ys,Xe,H) {
	Rk_deval = _getopt(deval,deval);
    if (type(Ys)==type([])) {
        Ys = ltov(Ys);
    }
    CALL = _getopt(callf,call_func);
    N  = rint(number_abs((Xe-Xs)/H));
    H  = number_sign(Xe-Xs)*H;
    H2 = H/2;
    Ans = [[Xs,Ys]];
    printf("\n%a %a\n", (*Rk_deval)(Xs), 'map'(Rk_deval, Ys));
    for(Y=Ys,X=Xs,I=0; I<N; I++) {
        Y1 = (*CALL)(FuncArgs, [[X],   Y]); 
        Y2 = (*CALL)(FuncArgs, [[X+H2],Y+H2*Y1]); 
        Y3 = (*CALL)(FuncArgs, [[X+H2],Y+H2*Y2]); 
        Y4 = (*CALL)(FuncArgs, [[X+H], Y+ H*Y3]); 
/*
        printf("Y1: %a %a\nY2: %a %a\nY3: %a %a\nY4: %a %a\n", 
               (*Rk_deval)(X),    'map'(Rk_deval, Y1),
               (*Rk_deval)(X+H2), 'map'(Rk_deval, Y2),
               (*Rk_deval)(X+H2), 'map'(Rk_deval, Y3),
               (*Rk_deval)(X+H),  'map'(Rk_deval, Y4));
*/
        Y += (H/6)*(Y1+2*(Y2+Y3)+Y4);
        X += H; 
        printf("%a %a\n", (*Rk_deval)(X), 'map'(Rk_deval, Y));
        Ans = cons([X,Y],Ans);
    }
    printf("\n");
    return reverse(Ans);
}

def rk_eval_norm_euclidean(V) {
    N = length(V);
    Norm = 0;
    for(I=0; I<N; I++) {
        Norm += V[I]*V[I];
    }
    return oh_number.deval(Norm^(1/2));
}

def rk_eval_norm_max(V) {
    return oh_base.max(map(oh_number.abs, V));
}

/* W has no zero entry */
def vector_ratio(V,W) {
    N = length(V);
    R = newvect(N);
    for(I=0; I<N; I++) {
        R[I] = V[I]/W[I];
    }
    return R;
}

//  ErrTol = [absolute error tolerance, relative error tolerance]
def rk_error(Y1,Y2,K,Ctrl) {
//  NormF=rk_eval_norm_max;
    NormF=rk_eval_norm_euclidean;
    Y = map(oh_number.abs,Y1-Y2);
    K = map(oh_number.abs,K);
    Scale = rk_scale(Y,K,Ctrl);
    Ratio = vector_ratio(Y,Scale);
    return (*NormF)(Ratio);
}

// Y,K are non-negative vectors
def rk_scale(Y,K,Ctrl) {
    R = Ctrl[1]*(Ctrl[2]*Y + Ctrl[3]*K);
    N = length(R);
    for(I=0; I<N; I++) {
        R[I] += Ctrl[0];
    }
    return R;
}

/* see GSL 1.15 reference manual, section 26.3 */
def rk_step_controller(Ctrl) {
    /* [absolute error tolerance, relative error tolerance, coef. of |y|, coef. of |y'|] */
    DefaultCtrl = [1/10^9,1/10^9,1,0];  // default
    if (islist(Ctrl)) {
        N = length(Ctrl);
        if(N==4) {
            return Ctrl;
        }else if (N==2) {
            return append(Ctrl,[1,0]);
        }else if (N==3 || N==1) {
            return append(Ctrl,vtol(newvect(4-N)));
        }
    }
    return DefaultCtrl;
}

def rk_step45(Call,FuncArgs,X,Y,H,Ctrl,Eval) {
    /* see Numerical Recipies 3rd ed., section 17.2 (pp.910--921) */
    /* Dormand-Prince 4(5) parameters for embedded Runge-Kutta */
    C  = [0,0,1/5,3/10,4/5,8/9,1,1];
    B5 = [0, 35/384, 0, 500/1113, 125/192, -2187/6784, 11/84, 0];
    B4 = [0, 5179/57600, 0, 7571/16695, 393/640, -92097/339200, 187/2100, 1/40];
    A2 = [0,1/5];
    A3 = [0,3/40,9/40];
    A4 = [0,44/45,-56/15,32/9];
    A5 = [0,19372/6561,-25360/2187,64448/6561,-212/729];
    A6 = [0,9017/3168,-355/33,46732/5247,49/176,-5103/18656];
//  A7 = B5;

    K1 = H*(*Call)(FuncArgs, [[X],   Y]); 
    K2 = H*(*Call)(FuncArgs, [[X+C[2]*H], Y+A2[1]*K1]); 
    K3 = H*(*Call)(FuncArgs, [[X+C[3]*H], Y+A3[1]*K1+A3[2]*K2]); 
    K4 = H*(*Call)(FuncArgs, [[X+C[4]*H], Y+A4[1]*K1+A4[2]*K2+A4[3]*K3]); 
    K5 = H*(*Call)(FuncArgs, [[X+C[5]*H], Y+A5[1]*K1+A5[2]*K2+A5[3]*K3+A5[4]*K4]); 
    K6 = H*(*Call)(FuncArgs, [[X+C[6]*H], Y+A6[1]*K1+A6[2]*K2+A6[3]*K3+A6[4]*K4+A6[5]*K5]); 
    Y4 = Y + B4[1]*K1 + B4[2]*K2 + B4[3]*K3 + B4[4]*K4 + B4[5]*K5 + B4[6]*K6; // embedded 4th RK
    Y5 = Y + B5[1]*K1 + B5[2]*K2 + B5[3]*K3 + B5[4]*K4 + B5[5]*K5 + B5[6]*K6;

    Error = (*Eval)(rk_error(Y5,Y4,K1,Ctrl));

    return [Y5,Error];
}

/* 5th order Runge-Kutta method with adaptive stepsize control */
/* see Numerical Recipies 3rd ed., section 17.2 (pp.910--921) */
def runge_kutta_linear3(FuncArgs,Xs,Ys,Xe,H) {
    Eval = _getopt(deval,oh_number.deval);
    Safety = 9/10;

    Ctrl = rk_step_controller(getopt(ctrl));
    printf("ErrorController=%a\n",Ctrl);

    if (type(Ys)==type([])) {
        Ys = ltov(Ys);
    }

    Sign = number_sign(Xe-Xs);
    CALL = _getopt(callf,call_func);
    H  = Sign*number_abs(H);

    X = Xs; Y = Ys;
    Ans = [[X,Y]];
    printf("\n%a %a\n", (*Eval)(X), 'map'(Eval, Y));
    if (X==Xe) {
        printf("\n");
        return Ans;
    }

    while(1) {
        X1 = X; Y1 = Y;
        R = rk_step45(CALL,FuncArgs,X,Y,H,Ctrl,Eval);
        Y5 = R[0]; Error = R[1];
        printf("Error = %a\n", Error);
        if (Error>1) { // Retry because the error is too large.
            E5 = (*Eval)(Error^(-1/5));
            H2 = H*Safety*E5;
            printf("(retry) log10(H): %a => %a\n", dlog(H)/dlog(10), dlog(H2)/dlog(10));
            H  = H2;
            continue;
        }
        X += H; Y = Y5;
        if (Error <= 1/2) { // Enlarging the stepsize because of too small.
            E5 = (*Eval)(Error^(-1/5));
            H2 = H*Safety*E5;
            printf("(next) log10(H): %a => %a\n", dlog(H)/dlog(10), dlog(H2)/dlog(10));
            H  = H2;
        }
        if ( Sign*(Xe-X) <= 0 ) {
            break;
        }
        printf("%a %a\n", (*Eval)(X), 'map'(Eval, Y));
        Ans = cons([X,Y],Ans);
    }
    if ( Xe != X ) { // retry last step
        H = Xe - X; /* abs(Xe-X1) < abs(LastH) */
        R = rk_step45(CALL,FuncArgs,X1,Y1,H,Ctrl,Eval);
        X += H; Y  = R[0];
    }
    printf("%a %a\n", (*Eval)(X), 'map'(Eval, Y));
    Ans = cons([X,Y],Ans);
    printf("\n");
    return reverse(Ans);
}

// ctrl("real_digit",16);
// test19()$
// test20()$

/* 
初期値 (Z=0.001)
InitValFloat=[ 
1.834885668779896312, 
18.96517485446140242, 
11.70294822085786770, 
9.609467131879854119, 
5.920492560166507569, 
564.0635393469870808 ];    // 同じ場所．漸近展開による.

計算結果 (Z=0.00108)
[
1.83134313847,
18.8799005805,
11.6666045147,
9.57611084253,
5.89871455232,
559.320556772 ]

// from Takayama
z=0.00108 の時の値は
1.83134313331868557399
error bound は0.0000000089279079861514485316

(snip)

漸近級数で計算すると, 最後だけ,
558.654942661977
です。２桁は数値積分と一致してますね.

error bound = 8.927907986e-09

A=1.83134313331868557399;
B=1.83134313847;

dabs(A-B);
5.151314486e-09

*/

def hgm_ahg_test_mset(A,W,Mset) {
    StdMon=reverse(cbase(A));
    printf("StdMon=%a\n",StdMon);

    Row = length(A); Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = base_var_list(dx,1,Col);
    Vb = base_var_list(b_,1,Row);

    if(W==[] || W==0) { /* use rev lex order */
        W = [base_flatten(assoc(DV,[1]))];
    }

    R=get_mat2(A,W,StdMon,Mset)[0];
    printf("size of R is %a\n",size(R));

    Rule=genrule_p(append(V,Vb));
    return [matrix_rank(base_replace(R,Rule)),StdMon];
}

def hgm_ahg(A,W,Mset,StdMon,Line,B,InitVal,Start,End,H) {
	Mode=getopt(mode);
	if(type(Mode)<0) {
		Mode=0;
	}
    if(qsort(StdMon) != qsort(reverse(cbase(A)))) { /* error! */
        return 0;
    }
    Row = length(A); Col = length(A[0]);
    V  = base_var_list(x,1,Col);
    DV = base_var_list(dx,1,Col);
    Vb = base_var_list(b_,1,Row);
    Vall = append(V,Vb);

    if(W==[] || W==0) { /* use rev lex order */
        W = [base_flatten(assoc(DV,[1]))];
    }

    Disc_R2=get_mat2(A,W,StdMon,Mset);
    Disc_R=Disc_R2[0];
    MatData=Disc_R2;

	if(Mode==1) {
		Eqn = get_eqn2(Disc_R2,Vall,append(Line, B) | solve=yes);
	}else {
		Eqn = get_eqn2(Disc_R2,Vall,append(Line, B));
	}
    TT = Eqn[1];
    SS = Eqn[2];

    Toric=mytoric(A,W)[1];
    Table = mk_table(DV,StdMon,Disc_R2[2],Toric,Vall,W,SS,TT);

    Z = base_prune(0,map(var,Line))[0];  
    for(P=0,I=0; I<Col; I++) {
        Dir = diff(Line[I],Z);
        if(Dir!=0) {
            PfI = mapat(oh_base.assoc_match,1,Table,DV[I]*ltov(StdMon));
            P += Dir*PfI;
        }
    }
	if(Mode==1) {
		P = base_replace(P,Eqn[0]);
		Func=[P,[[Z],SS]];
//		return runge_kutta_linear2(Func,Start,InitVal,End,H);
		return runge_kutta_linear3(Func,Start,InitVal,End,H | deval=oh_number.deval);
	}
    Func=[P,[[Z],SS],Eqn];
//  return runge_kutta_linear2(Func,Start,InitVal,End,H | callf=call_func_eqn, deval=oh_number.deval );
    return runge_kutta_linear3(Func,Start,InitVal,End,H | callf=call_func_eqn, deval=oh_number.deval );
}

def test100 () {
    /* from ud-c11.rr */
    A = [[1,0,0,1,1,0,1],
         [0,1,0,1,0,1,1],
         [0,0,1,0,1,1,1]];
    Row = length(A); Col = length(A[0]);
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7,
          dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
          dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
          dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
          dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
          dx5*dx5,dx5*dx6,dx5*dx7,
          dx6*dx6,dx6*dx7,
          dx7*dx7];

    StdMon = [1,dx7,dx6,dx5,dx4,dx7^2];
    Line = [-10/11,-13/10,-8/7,(-41/43)*z,(-10/12)*z,(-25/23)*z,(-37/39)*z];
    Bdat = [-15/10, -26/10, -37/10];

#if 1
    /* an initial value at Z=0.001 */
    InitValFloat=[ 1.834885668779896312, 
                   18.96517485446140242, 
                   11.70294822085786770, 
                   9.609467131879854119, 
                   5.920492560166507569, 
                   564.0635393469870808 ];    /* 同じ場所．漸近展開による. */
    InitVal=map(float2rat,InitValFloat,6);
    Start = 1/10^3;
    End = 1/10;
    H = 1/10^6;
#endif

#if 0
    /* an initial value at Z=0.1 */
    InitValFloat=[0.457392904554, 1.305954410928, 1.533103031020, 1.067058892481, 0.595251972063, 7.940707579700];
    InitVal=map(float2rat,InitValFloat,12);
    Start = 1/10;
    End = 25/100;
    H = 1/10^4;
#endif
    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H);
    F = reverse(G)[0];
    return [deval(F[0]),map(deval,F[1])];
}

def test6d() {
    A = [[1,0,0,1,1,0,1],
         [0,1,0,1,0,1,1],
         [0,0,1,0,1,1,1]];
    W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1]]; /* use rev lex */
    Mset=[1,dx5,dx6,dx7, 
            dx1,dx2,dx3,dx4,
            dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,
                    dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,
                             dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,
                                     dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,
                                             dx5*dx5,dx5*dx6,dx5*dx7,
                                                     dx6*dx6,dx6*dx7,
                                                             dx7*dx7];
    return hgm_ahg_test_mset(A,W,Mset);
}

/* F_D from h-mle/FD/Prog/fdpf.rr check(10)  */
def test110() {
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 by check7(10) */
    InitValFloat= [ 1.19505025171429995935011756799039243029388647110495690231,
					-0.171909712765026133647462174136326715493035759705424405645,
					-0.325127216579630777012789631518989535279864106544409154292,
					-0.465226174525471104850159503487993942789075081411665529643];
    InitVal=map(float2rat,InitValFloat,6);
    Start = 0;
    End = 1/10;
	H = 1/10^5;
	TargetValFloat = [1.30653474406446941281514923953551188142993976219689097489,
					  -0.198372479159747173559323964725234816747543096711018280293,
					  -0.386432833081859751387869841763599069918640617829089346345,
					  -0.584424284968205792783937496766437194841036114282518073142];

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H);
    F = reverse(G)[0];
    Val = [deval(F[0]),map(deval,F[1])];
	printf("Val=%a\n  atZ=%a\n\n", Val[1],Val[0]);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def test111() {
	Deval=oh_number.deval;
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 by check7(30) */
    InitValFloat= [ 1.19505025186078973856324535516282809960832446191213484050,
				   -0.171909714259269817594145743377544836183663976613720245516,
				   -0.325127216734109713804903925455918486964102689556102294155,
				   -0.465226174603649105888797335558491584759624199217577452861];
	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^12;
//	End = Start+10*H;
	printf("H=%a\n",H);
	TargetValFloat = [1.30653474526512361790567548176126429002582614030996144986,
					  -0.198372489487087915397232216954501730234040987864606539446,
					  -0.386432835651982983362135481308333777740853851309581833048,
					  -0.584424286257640845566056905386694872409875592930997773923];
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def test112() {
	Deval=oh_number.deval;
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 */
	/* see ndata1.txt */
	InitValFloat= [ 1.1950502518607810772538534319502477092478,
					-0.171909714259135548490788881793,
					-0.325127216734103016669951013427,
					-0.465226174603644620219989884764 ];
	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^8;
	End = Start+10*H;
	printf("H=%a\n",H);

	TargetValFloat = [ 1.1950503579873959974893288926466220932073,
					   -0.171909739138021515928791442706,
					   -0.325127273921048994509468169298,
					   -0.465226283864086289370886598026];
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def test113() {
	Deval=oh_number.deval;
    A = [[1,1,1,1,0,0,0,0],
       [1,0,0,0,1,0,0,0],
       [0,1,0,0,0,1,0,0],
       [0,0,1,0,0,0,1,0],
       [0,0,0,1,0,0,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1,dx5,1,dx6,1,dx7,1,dx8,1]]; */
    W=[];
    Mset=[1,dx5,dx6,dx7,dx8, 
            dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,dx1*dx5,dx1*dx6,dx1*dx7,dx1*dx8,
                  dx2*dx2, dx2*dx3,dx2*dx4,dx2*dx5,dx2*dx6,dx2*dx7,dx2*dx8,
                           dx3*dx3,dx3*dx4,dx3*dx5,dx3*dx6,dx3*dx7,dx3*dx8,
                                   dx4*dx4,dx4*dx5,dx4*dx6,dx4*dx7,dx4*dx8,
                                           dx5*dx5,dx5*dx6,dx5*dx7,dx5*dx8,
                                                   dx6*dx6,dx6*dx7,dx6*dx8,
                                                           dx7*dx7,dx7*dx8,
                                                                   dx8*dx8];

    StdMon=[1,dx8,dx7,dx6];
    Dir = [0,1/2,1/3,1/4,0,0,0,0];
	Pt0 = [1,1/20,1/10,3/20,1,1,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1/2,-19/14,-1/3,-1/5,-1/11];

    /* an initial value at Z=0 */
	/* see ndata2.txt */
	InitValFloat= [ 1.19505025186078955712664300572235872118970085222390413439421,
					-0.1719097142592666327962706769863140069355848346631,
					-0.3251272167341095821098734547768632291192167493124,
					-0.4652261746036490124174695015314618553310166347622];
	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^12;
	End = Start+10*H;
	printf("H=%a\n",H);

	TargetValFloat = [ 1.19505025187140221810829638857678563859063685884558977316613,
					   -0.1719097142617545212428381118370425765918726605528,
					   -0.3251272167398282763191847367312434734359033864699,
					   -0.4652261746145750556601430254764766400183269585405 ];
	// TargetValFloat = [1.30653474526512361790567548176126429002582614030996144986,
	// 				  -0.198372489487087915397232216954501730234040987864606539446,
	// 				  -0.386432835651982983362135481308333777740853851309581833048,
	// 				  -0.584424286257640845566056905386694872409875592930997773923];
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

// Gauss HGF
def test200() {
	Deval=oh_number.deval;
    A = [[1,1,0,0],
       [1,0,1,0],
		 [0,1,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,
                  dx2*dx2, dx2*dx3,dx2*dx4,
                           dx3*dx3,dx3*dx4,
  		                           dx4*dx4];

    StdMon=[1,dx4];
    Dir = [0,1/2,0,0];
	Pt0 = [1,1/20,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1,-1,-1];

    /* an initial value at Z=0 (see ndata3.txt) */
    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^12;
	End = 10*H;
	printf("H=%a\n",H);
/*
	Fexact = 1/(x4*x1-x2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x4) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	TargetValFloat = base_replace(Fexact2,assoc([x1,x2,x3,x4],subst(Line,z,End)));
*/
	TargetValFloat = [ 1379705263165156343490337664965729145605074732345285572275499892485660074802556007951592383292376799714275667111022503488080118437736000623258800003275800000017080000000085600000000370000000001/1310720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -726160664827588394809749236270349809456652910757778242833184281533675898114679524301441522168100618712503509959130283259920748021944004264109200024126200000134520000000714400000003230000000009/655360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
	// [1.05263157895290858725764287183054286621480921352026792318, -1.10803324100889342469749334147697419655861345025295752385]; 
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
	printf("TargetVal=%a\n", TargetValFloat);
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

// Gauss HGF
def test201() {
	Deval=oh_number.deval;
    A = [[1,1,0,0],
       [1,0,1,0],
		 [0,1,0,1]];
/*  W=[[dx1,1,dx2,1,dx3,1,dx4,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,dx4,
          dx1*dx1,dx1*dx2, dx1*dx3,dx1*dx4,
                  dx2*dx2, dx2*dx3,dx2*dx4,
                           dx3*dx3,dx3*dx4,
  		                           dx4*dx4];

    StdMon=[1,dx4];
    Dir = [0,1/2,0,0];
	Pt0 = [1,1/20,1,1];
    Line = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat = [-1,-1,-1];


	Fexact = 1/(x4*x1-x2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x4) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	Fexact3 = base_replace(Fexact2,assoc([x1,x2,x3,x4],Line)); // a function of z

    /* an initial value at Z=0 (see ndata3.txt) */
    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

//	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
    InitVal=InitValFloat;
    Start = 0;
    End   = 1/10;
	H     = 1/10^3;
	printf("H=%a\n",H);
	TargetValFloat = base_replace(Fexact3,[[z,End]]);

	// TargetValFloat = [ 1379705263165156343490337664965729145605074732345285572275499892485660074802556007951592383292376799714275667111022503488080118437736000623258800003275800000017080000000085600000000370000000001/1310720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -726160664827588394809749236270349809456652910757778242833184281533675898114679524301441522168100618712503509959130283259920748021944004264109200024126200000134520000000714400000003230000000009/655360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
	// [1.05263157895290858725764287183054286621480921352026792318, -1.10803324100889342469749334147697419655861345025295752385]; 
//	TargetValFloat = 'map'(Deval,TargetValFloat);

//  G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H); // Runge-Kuttta with rational numbers
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
//	printf("TargetVal=%a\n", TargetValFloat);
	printf("TargetVal=%a\n", 'map'(Deval,TargetValFloat));
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

// Quadratic Equation
def test300() {
	Deval=oh_number.deval;
    A = [[1,1,1],
		 [0,1,2]];
/*  W=[[dx1,1,dx2,1,dx3,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,
            dx1*dx1,dx1*dx2, dx1*dx3,
                    dx2*dx2, dx2*dx3,
                             dx3*dx3];

    StdMon= [1,dx3];
    Dir   = [1,1,0];
	Pt0   = [2,-3,1];
    Line  = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat  = [0,-1];

	Fexact  = (-x2+((-4*x3*x1+x2^2)^(1/2)))/(2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x3) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	Fexact3 = base_replace(Fexact2,assoc([x1,x2,x3],Line)); // a function of z

    /* an initial value at Z=0 (see ndata4.txt) */
//    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

//	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
//  InitVal=InitValFloat;
    Start = 0;
//  End = 1/10;
	H = 1/10^12;
//	H = 1/10^4;
//	H = 1/10^3;
    End = Start + 10*H;
	printf("H=%a\n",H);
	InitVal        = base_replace(Fexact3,[[z,Start]]);
//	TargetValFloat = base_replace(Fexact3,[[z,End]]);

	// TargetValFloat = [ 1379705263165156343490337664965729145605074732345285572275499892485660074802556007951592383292376799714275667111022503488080118437736000623258800003275800000017080000000085600000000370000000001/1310720000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000, -726160664827588394809749236270349809456652910757778242833184281533675898114679524301441522168100618712503509959130283259920748021944004264109200024126200000134520000000714400000003230000000009/655360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000];
	// [1.05263157895290858725764287183054286621480921352026792318, -1.10803324100889342469749334147697419655861345025295752385]; 
//	TargetValFloat = 'map'(Deval,TargetValFloat);

	TargetValFloat = [ 1.9999999999699999999993999999999699999998735990802, -4.0000000000800000000073000000006170000004276327526];

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
//	printf("TargetVal=%a\n", TargetValFloat);
	printf("TargetVal=%a\n", 'map'(Deval,TargetValFloat));
	Error=map(number_abs,vtol(Val[1]-ltov(TargetValFloat)));
	printf("Error=%a\n",Error);
	return Val;
}

def my_abs(A) {
	return (A<0)? -A: A;
}

def test301() {
	Deval=oh_number.deval;
    A = [[1,1,1],
		 [0,1,2]];
/*  W=[[dx1,1,dx2,1,dx3,1]]; */
    W=[];
    Mset=[1,dx1,dx2,dx3,
            dx1*dx1,dx1*dx2, dx1*dx3,
                    dx2*dx2, dx2*dx3,
                             dx3*dx3];

    StdMon= [1,dx3];
    Dir   = [1,1,0];
	Pt0   = [2,-3,1];
    Line  = vtol(ltov(Dir)*z + ltov(Pt0));
    Bdat  = [0,-1];

	Fexact  = (-x2+((-4*x3*x1+x2^2)^(1/2)))/(2*x3);
	Fexact2 = [ Fexact, diff(Fexact,x3) ]; // diff(Fexact,x4) == -x1 * Fexact^2 
	Fexact3 = base_replace(Fexact2,assoc([x1,x2,x3],Line)); // a function of z

    /* an initial value at Z=0 (see ndata4.txt) */
//    InitValFloat= [ 13797052631578947368421/13107200000000000000000, -7261606648199445983379/6553600000000000000000];
	// [1.05263157894736842105262756347656249999999999999999999999,-1.10803324099722991689743041992187499999999999999999999999];

//	InitValFloat = 'map'(Deval,InitValFloat);

//  InitVal=map(float2rat,InitValFloat,6);
//  InitVal=InitValFloat;
    Start = 0;
    End = 1/10;
	H = 1/10^4;
//  End = Start + 10*H;
	printf("H=%a\n",H);
	InitVal        = base_replace(Fexact3,[[z,Start]]);
	InitVal        = 'map'(Deval,InitVal);
	TargetValFloat = base_replace(Fexact3,[[z,End]]);
	TargetValFloat = 'map'(Deval,TargetValFloat);

    G = hgm_ahg(A,W,Mset,StdMon,Line,Bdat,InitVal,Start,End,H|mode=1);
    F = reverse(G)[0];
    Val = [(*Deval)(F[0]),'map'(Deval,F[1])];
	printf("Val=%a\n  at Z=%a\n\n", Val[1],Val[0]);
//	printf("TargetVal=%a\n", TargetValFloat);
	printf("TargetVal=%a\n", 'map'(Deval,TargetValFloat));
	Error = vtol(Val[1]-ltov(TargetValFloat));
	Error = map(number_abs,Error);
	printf("Error=%a\n",Error);
	return Val;
}

/* How to use test functions.

setprec(30);              // specifying precision for pari's floating point number
pari(allocatemem,10^7);   // alocating  stack memory for pari
ctrl("real_digit",16);
load("ot_hgm_ahg.rr");
test112();
test113();
test200();
test201();
test301();

 */

end$
