/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_print.rr,v 1.10 2001/08/22 05:24:18 takayama Exp $ */

#define NOT_YET   print("It has not yet been implemented.")

#define Number 1
#define NUMBER 1
#define RPolynomial 2
#define RPOLYNOMIAL 2
#define Rational 3
#define RATIONAL 3
#define List 4
#define LIST 4
#define Vector 5
#define VECTOR 5
#define Matrix 6
#define MATRIX 6
#define STRING 7
#define STRUCT 8
#define DPolynomial   9
#define DPOLYNOMIAL   9
#define QUOTE 17

Taka_print_dp_vlist_vname="x"$
def taka_print_dp_vlist(N) {
  extern Taka_print_dp_vlist_vname;
  V = Taka_print_dp_vlist_vname+"_"+rtostr(N);
  return strtov(V);
}
  /* Used in taka_tex_form_dpolynomial
     and taka_dp_print  */

def taka_tex_form(S) {
  if (type(S) == Matrix) {
     return taka_tex_form_matrix(S);
  }else if (type(S) == Vector) {
     return taka_tex_form_vector(S);
  }else if (type(S) == List) {
     return taka_tex_form_list(S);
  }else if (taka_is_fractional(S)) {
     return( taka_tex_form_frac(S) );
  }else if (type(S) == DPolynomial) {
     return taka_tex_form_dpolynomial(S);
  }else if (type(S) == RPolynomial) {
     return taka_tex_form_rpolynomial(S);
  }else if (type(S) == STRUCT) {
     return taka_tex_form_struct(S);
  }else if (type(S) == QUOTE) {
     return taka_tex_form_quote(S);
  }else {
   /* How to translate sin to \sin?
      Use vtype, get args, ... to print sin. 
      quote("x+2*y");  there is no way to get the left leaves and right leaves
      for now.   eval_quote.
   */
     return rtostr(S);
  }
}

def taka_tex_form_matrix(A) {
  N = size(A)[0];
  M = size(A)[1];
  S="\\pmatrix{\n";
  for (I=0; I<N; I++) {
    for (J=0; J<M; J++) {
      S += taka_tex_form(A[I][J]);
      if (J != M-1) S += "& ";
    }
    S += " \\cr\n";
  }
  S += "}\n";
  return S;
}

def taka_tex_form_vector(A) {
  N = size(A)[0];
  S="\\pmatrix{\n";
  for (I=0; I<N; I++) {
    S += taka_tex_form(A[I]);
    if (I != N-1) S += "& ";
  }
  S += "\\cr}\n";
  return S;
}

def taka_tex_form_list(A) {
  N = length(A);
  S="[";
  for (I=0; I<N; I++) {
    S += taka_tex_form(A[I]);
    if (I != N-1) S += ", ";
  }
  S += "]";
  return S;
}

def taka_is_fractional(A) {
  if (type(A) == Rational) return 1;
  else if (type(A) == Number && dn(A) != 1) return 1;
  else return 0;
}

def taka_tex_form_frac(A) {
  S = "\\frac{";
  S += taka_tex_form(nm(A))+"}{";
  S += taka_tex_form(dn(A))+"}";
  return S;
}

def taka_tex_form_dpolynomial(F) {
  if (F != 0) {
    N = size(dp_etov(dp_hm(F)))[0];
    Vlist = newvect(N);
    for (I=0; I<N; I++) {
      Vlist[I] = taka_print_dp_vlist(I);
    }
    Vlist = vtol(Vlist);
    Ans="";
  }else{
    Ans="0";
  }
  C = 0;
  while (F != 0) {
     G = dp_hm(F);
     F = dp_rest(F);
     if (type(dp_hc(G)) == NUMBER &&
         dn(dp_hc(G)) == 1) {
       if (dp_hc(G)>0 && C != 0) {
         Ans += "+";
       }
       if (dp_hc(G) == 1) {
       }else if (dp_hc(G) == -1) {
         Ans += "-";
       }else{
         Ans += taka_tex_form(dp_hc(G));
       }
       if (dp_dtop(dp_ht(G),Vlist) != 1) {
         Ans += " "+taka_tex_form(dp_dtop(dp_ht(G),Vlist));
       }
       if (dp_hc(G) == 1 && dp_dtop(dp_ht(G),Vlist) == 1) {
         Ans += "1";
       }
       if (dp_hc(G) == -1 && dp_dtop(dp_ht(G),Vlist) == 1) {
         Ans += "1";
       }
       if (C == 0) C = 1;
     }else{
       if (C != 0) {
         Ans += "+";
       }
       Ans += "(" + taka_tex_form(dp_hc(G)) + ")";
       if (dp_dtop(dp_ht(G),Vlist) != 1) {
         Ans += " "+taka_tex_form(dp_dtop(dp_ht(G),Vlist));
       }
       if (C == 0) C = 1;
     }
  }
  return Ans;
}

def taka_tex_form_rpolynomial(S) {
  return taka_tex_form_quote(quote_to_quote(S));
}

/* Tentative code */
def taka_tex_form_struct(S) {
  if (S->Tag == "poly_factored_polynomial" || S->Tag == "poly_factored_rational") {
     return taka_tex_form_quote( quote_factored_form_to_quote(S));
  }else {
     print("Unknown struct object for tex_form. Return ???");
     return "???";
  }
}

def taka_tex_form_quote(S) {
  S = quotetolist(S);
  return taka_tex_form_quote_list(S);
}

def taka_tex_form_quote_list(S) {
  if (type(S) != List) return taka_tex_form_node_name(S);
  A = " ";
  if (S[0] == "u_op") {
     return taka_tex_form_quote_list_u_op(cdr(S));
  }else if (S[0] == "b_op") {
     return taka_tex_form_quote_list_b_op(cdr(S));
  }else if (S[0] == "t_op") {
     return taka_tex_form_quote_list_t_op(cdr(S));
  }else if (S[0] == "list") {
     return taka_tex_form_quote_list_list(cdr(S));
  }else if (S[0] == "exponent_vector") {
     return taka_tex_form_quote_list_exponent_vector(cdr(S));
  }else if (S[0] == "internal") {
     return taka_tex_form_quote_list_internal(cdr(S));
  }else if (S[0] == "function") {
     return taka_tex_form_quote_list_function(cdr(S));
  }else {
     error("Unknown quote format.");
  }
}

def taka_tex_form_quote_list_u_op(S) {
  if (S[0] == "()") {
    A += "(";
    A += taka_tex_form_quote_list(S[1]);
    A += ") ";
  }else
  if (S[0] == "!") {
    A += "\neg (";
    A += taka_tex_form_quote_list(S[1]);
    A += ") ";
  }else
  if (S[0] == "@!") {
    A += "\neg (";
    A += taka_tex_form_quote_list(S[1]);
    A += ") ";
  }else{
    error("Not implemented");
  }
  return A;
}

def taka_is_internal_zero(S) {
  if (type(S) != LIST) return 0;
  if (length(S) != 2) return 0;
  if (S[0] == "internal" && S[1] == 0) return 1;
  else return 0;
}
def taka_tex_form_quote_list_b_op(S) {
   if (S[0] == "+") {
    T = cdr(S);
    N = length(T);
    for (I=0; I<N; I++) {
      A += taka_tex_form_quote_list(T[I]);
        if (I != N-1) A += S[0];
    }
  }else
  if (S[0] == "-") {
    T = cdr(S);
    N = length(T);
    for (I=0; I<N; I++) {
      if (I == 0 && taka_is_internal_zero(T[I])) {
         /* Do not print 0. */
      } else {
         A += taka_tex_form_quote_list(T[I]);
      }
      if (I != N-1) A += S[0];
    }
  } else
  if (S[0] == "*") {
    T = cdr(S);
    N = length(T);
    for (I=0; I<N; I++) {
      A += taka_tex_form_quote_list(T[I]);
      A += " ";
    }
  } else
  if (S[0] == "/") {
    T = cdr(S);
    A += "\\frac{";
    A += taka_tex_form_quote_list(T[0]);
    A += "} {";
    A += taka_tex_form_quote_list(T[1]);
    A += "} ";
  } else
  if (S[0] == "^") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += "^{";
    A += taka_tex_form_quote_list(T[1]);
    A += "} ";
  } else
  if (S[0] == "%") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " {\\rm mod}\\, ";
    A += taka_tex_form_quote_list(T[1]);
  } else
  if (S[0] == "==" || S[0] == "@==") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " = ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == "&&") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " {\\rm \\ and\\ } ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == "||") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " {\\rm \\ or\\ } ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == "<" || S[0] == "@<") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " \\lt ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == ">" || S[0] == "@>") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " \\gt ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == "<=" || S[0] == "@<=") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " \\leq ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == ">=" || S[0] == "@>=") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " \\geq ";
    A += taka_tex_form_quote_list(T[1]);
  }else
  if (S[0] == "!=" || S[0] == "@!=") {
    T = cdr(S);
    A += taka_tex_form_quote_list(T[0]);
    A += " \\not= ";
    A += taka_tex_form_quote_list(T[1]);
  }else {
    error("Not implemented.");
  }
  return A;
}

def taka_tex_form_list_t_op(S) {
  NOT_YET ;
}

def taka_tex_form_quote_list_exponent_vector(S) {
    T = S;
    A = " [ ";
    N = length(T);
    for (I=0; I<N; I++) {
      A += taka_tex_form_quote_list(T[I]);
      if (I != N-1) {
        A += ", ";
      }
    }
    A += "]";
    return A;
}

def taka_tex_form_quote_list_list(S) {
    T = S;
    A = " [ ";
    N = length(T);
    for (I=0; I<N; I++) {
      A += taka_tex_form_quote_list(T[I]);
      if (I != N-1) {
        A += ", ";
      }
    }
    A += "]";
    return A;
}


def taka_tex_form_quote_list_function(S) {
    A += taka_tex_form_node_name(S[0]);
    A += "(";
    T = cdr(S);
    N = length(T);
    for (I=0; I<N; I++) {
      A += taka_tex_form_quote_list(T[I]);
      if (I != N-1) {
        A += ", ";
      }
    }
    A += ")";
    return(A);
}

def taka_tex_form_quote_list_internal(S) {
  return rtostr(car(S));
}

def taka_tex_form_node_name(S) {
  if (type(S) != STRING) return rtostr(S);
  /* Table of Mathematical Symbols. */
  if (S == "sin") {
     return "\\sin ";
  }else if (S == "cos") {
     return "\\cos ";
  }else if (S == "tan") {
     return "\\tan ";
  }else if (S == "exp") {
     return "\\exp ";
  }else if (S == "log") {
     return "\\log ";
  }else if (S == "alpha") {
     return "\\alpha";
  }else if (S == "beta") {
     return "\beta";
  }else if (S == "gamma") {
     return "\\gamma";
  }else if (S == "ggamma") {
     return "\\Gamma";
  }else {
     return S;
  }
}

/*  test data
   print_tex_form(quote(1+2));
   print_tex_form(quote(-1));
   print_tex_form(quote(x+1/2*y));
   print_tex_form(quote_to_quote(-(x-1/3*y)^3));
   print_tex_form(quote( (sin(x)+y)/(x-y) ));
   print_tex_form(quote([[1,2],[x-10,1/y]]));
   print_tex_form(quote(newmat(2,2,[[1,2],[1/x,exp(x)]])));
*/
def taka_output(S) {
  shell("rm t.tex ");
  output("t.tex");
  print(S);
  output();
}

def taka_print(S) {
  if (type(S) == DPolynomial) {
    return taka_dp_print(S);
  }else{
    return rtostr(S);
  }
}
def taka_dp_print(F) {
  if (F != 0) {
    N = size(dp_etov(dp_hm(F)))[0];
    Vlist = newvect(N);
    for (I=0; I<N; I++) {
      Vlist[I] = taka_print_dp_vlist(I);
    }
    Vlist = vtol(Vlist);
    Ans="distributed_polynomial(\"   ";
  }else{
    Ans="0";
  }
  C = 0;
  while (F != 0) {
     G = dp_hm(F);
     F = dp_rest(F);
     if (dp_hc(G)>0 && C != 0) {
       Ans += "+";
     }
     Ans += rtostr(dp_dtop(G,Vlist));
     if (C == 0) C = 1;
  }
  Ans += "   \")";
  return Ans;
}

def taka_dvi_form(S) {
  S = taka_tex_form(S);
  File0 = ox_work_dir()+"/"+ox_new_file_name();
  File = File0+".tex";
  shell("rm -f "+File);
  output(File);
  S = "\\documentclass[12pt]{article} \\pagestyle{empty} \\begin{document}\n"+
      "$"+
      S + "$ \n \\end{document}\n";
  print(S);
  output();
  shell(" (cd "+ox_work_dir()+" ; latex "+File0+" >>/dev/null) ");
  return [File0+".dvi",File0,File,ox_work_dir()];
         /* (0) .dvi, (1) no extension, (2) .tex, (3) workding dir */
}
def taka_xdvi_form(S) {
  F = taka_dvi_form(S);
  /* Use xdvi for a moment. */
  shell(" xdvi -s 3 -geometry 800x300 "+F[1]+"  >>/dev/null & ");
  return F;
}
/* test data 
 print_xdvi_form(quote_sort_polynomial((x-sin(x)*y)^3,[x,y],[1,1]));
*/

def taka_gif_form(S) {
  F = taka_dvi_form(S);
  File0 = F[1];
  Work_dir = F[3];
  shell(" (cd "+Work_dir+" ; latex2html -tmp /tmp "+File0+" >>/dev/null) ");
  shell(" (cd "+Work_dir+" ; cp "+File0+"/*.gif "+File0+".gif"+ " ) ");
  /* shell(" (cd "+Work_dir+" ; rm -rf "+File0+" ) "); */
  /* BUG: we should use pstoimg in a future.
     latex2html does not always generate image output for a simple expression.
  */
  return [File0+".gif",File0,File,ox_work_dir()];
}

Loaded_taka_print=1$
end$
