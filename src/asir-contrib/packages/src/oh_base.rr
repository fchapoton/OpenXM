/* $OpenXM$ */

module oh_base;

localf length, nth, range;
localf max2, min2, sum2, mul2;
localf iterate, max, min, sum, mul;

def length(L) {
    return (type(L)==4||type(L)==5)? ::length(L): 0;
}

/*&usage
Syntax: object nth(list L|alt=Alt): n-th member of L with fool proof.
Example:
[1] oh_base.nth([a,b,c,d],2)
c
[2] oh_base.nth([a,b,c,d],-1|alt=x)
x
*/
def nth(L,I) {
	Alt=getopt(alt);
	if (type(Alt) >= 0) {
		return (0<=I && I<::length(L))? L[I]: Alt;
	}
    return L[I];
}

/*&usage
Syntax: list range(integer A, integer B): the list from A to B.
Example:
[1] oh_base.range(2,6)
[2,3,4,5,6]
[2] oh_base.range(3,-2)
[3,2,1,0,-1,-2]
*/
def range(Start,End) {
    L = [];
    if(Start<=End) {
        for(I=End; I>=Start; I--) {
            L = cons(I,L);
        }
    }else {
        for(I=Start; I<=End; I++) {
            L = cons(I,L);
        }
    }
    return L;
}

/*&usage
Syntax: object max2(object A,object B|comp=cmp): the large object under a comparison function.
Example:
[1] oh_base.max2(-2,1);
1
[2] def cmp(A,B) { return (A^2>B^2);}
[3] oh_base.max2(-2,1|comp=cmp);
-2
*/

def max2(A,B) {
	Comp=getopt(comp);
	if (type(Comp) >= 0) {
		return ((*Comp)(A,B))? A: B;
	}
    return (A>B)? A: B;
}

def min2(A,B) {
	Comp=getopt(comp);
	if (type(Comp) >= 0) {
		return ((*Comp)(A,B))? B: A;
	}
    return (A>B)? B: A;
}

def sum2(A,B) {
    return A+B;
}

def mul2(A,B) {
    return A*B;
}

/*&usage
Syntax: object iterate(function F,list L): action of n-term operator generated by 2-term operator F.
Example:
[1] oh_base.max2(-2,1);
1
[2] oh_base.iterate(oh_base.max2, [-2,0,3,-4,1]);
3
[3] oh_base.sum2(a,b);
a+b
[4] oh_base.iterate(oh_base.sum2, [a,b,c,d,e]);
a+b+c+d+e
*/
def iterate(Op2,L) {
    A=car(L);
    for(L=cdr(L); L!=[]; L=cdr(L)) {
        A=(*Op2)(A,car(L));
    }
    return A;
}

def max(L) {
    return iterate(max2,L);
}

def min(L) {
    return iterate(min2,L);
}

def sum(L) {
    return iterate(sum2,L);
}

def mul(L) {
    return iterate(mul2,L);
}

endmodule;

end;
