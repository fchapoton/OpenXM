/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_poly.rr,v 1.15 2004/03/11 01:57:39 takayama Exp $ */
#include "tags.h"

def taka_poly_solve_poly1(F,V) {
  if (type(F) == 3) { /* Rational */
    G = dn(F); 
    if (deg(G,V) != 0) {
      return quote(root_of(F));
    }
  }
  Ans = [ ] ;
  G = nm(F);
  F = fctr(G);
  N = length(F);
  for (I=0; I<N; I++) {
    if (deg(F[I][0],V) == 0) {
    }else if (deg(F[I][0],V) == 1) {
       Sol = red( -coef(F[I][0],0,V)/coef(F[I][0],1,V) );
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }else {
       /* Sol = quote(root_of( F[I][0] )); */
       Sol = F[I][0];
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }
  }
  return Ans;
}

def taka_poly_solve_linear(Z,X) {
  Size_Z = length(Z);
  Sol = [ ];
  F = [];
  for (I = 0; I < Size_Z; I++) {
    if (Z[I] != 0) {
      if (type(Z[I]) == 3) {
        F = append(F,[ nm(red(Z[I])) ]);
      }else{
        F = append(F, [Z[I]]);
      }
    }
  }

  if (F == []) {
    return Sol;
  }

  G = gr(F, reverse(X), 2);

  if (G[0] == 1 || G[0] == -1) {
    return [];
  }

  Sol = newvect(length(X));
  N = 0;
  for (I = 0; I < length(G); I++) {
    for (J = length(X) - 1; J >= 0; J--) {
      Nm = nm(G[I]); Dn = dn(G[I]);
      if (coef(Nm, 1, X[J]) != 0) {
        Sol[J] = [X[J], X[J] - Nm/coef(Nm, 1, X[J])];
        N++;
        break;
      }
    }
  }
  Sol2 = newvect(N);
  I = 0;
  for (J=0; J<size(Sol)[0]; J++) {
    if (Sol[J] == 0) {
    }else{
       Sol2[I] = Sol[J]; I++;
    }
  }
  return vtol(Sol2);
}

def taka_poly_factor(S) {
  if (type(S) == LIST || type(S) == MATRIX || type(S) == VECTOR) {
    return( map(taka_poly_factor,S) );
  }
  if (type(S) == RPOLYNOMIAL) {
     S1 = new_poly_factored_polynomial();
     S1->F = fctr(S);
     return S1;
  }
  if (type(S) == RATIONAL) {
     NN = nm(S); DD = dn(S);
     NN = taka_poly_factor(NN);
     DD = taka_poly_factor(DD);
     S = new_poly_factored_rational();
     S->Numerator = NN;
     S->Denominator = DD;
     return S;
  }
  if (type(S) == QUOTE) {
    A = quote_to_obj(S);
    B = taka_poly_factor(A);
    return B; /* object is not translated to a quote. */
  }
  /* It has not yet been implemented. */
  return S;
}

/* 
  printing method for POLY_FACTORED_FORM 
*/
def taka_poly_input_form_poly_factored_polynomial(S) {
  A="new__poly_factored_polynomial(";
  A += print_input_form(S->F);
  A += ")";
  return A;
}
def taka_poly_input_form_poly_factored_rational(S) {
  A="new__poly_factored_rational(";
  A += print_input_form(S->Numerator);
  A += ",";
  A += print_input_form(S->Denominator);
  A += ")";
  return A;
}

def taka_poly_terminal_form_poly_factored_polynomial(S) {
  A="{";
  A += "F->";
  A += print_terminal_form(S->F);
  A += "}";
  return A;
}
def taka_poly_terminal_form_poly_factored_rational(S) {
  A="{";
  A += "Numerator->";
  A += print_terminal_form(S->Numerator);
  A += ", Denominator->";
  A += print_terminal_form(S->Denominator);
  A += "}";
  return A;
}

def taka_poly_tex_form_poly_factored_polynomial(S,Tb) {
  return taka_tex_form_quote( quote_factored_form_to_quote(S),Tb);
}

/* Printing and input method
   for POLY_RING
*/
def taka_poly_input_form_poly_ring(S) {
  A  = "new__poly_ring(";
  A += taka_input_form(S->Variables)+",";
  A += taka_input_form(S->Order)+",";
  A += taka_input_form(S->K)+",";
  A += taka_input_form(S->Weyl);
  A += ")";
  return A;
}
def taka_poly_terminal_form_poly_ring(S) {
  A  = "{";
  A += "Variables->"+taka_terminal_form(S->Variables)+",";
  A += "Order->"+taka_terminal_form(S->Order)+",";
  A += "K->"+taka_terminal_form(S->K)+",";
  A += "Weyl->"+taka_terminal_form(S->Weyl)+"}";
  return A;
}

def taka_poly_tex_form_poly_ring(S,Tb) {
  taka_tex_form(S->K,Tb);
  taka_tex_form(S->Variables,Tb);
  write_to_tb(" \\mbox{\ where the order is defined by \ } ",Tb);
  taka_tex_form(S->Order,Tb);
}

/* Printing and input method
   for POLY_POLYNOMIAL
*/
def taka_poly_input_form_poly_polynomial(S) {
  A  = "new__poly_polynomial(";
  A += taka_input_form(S->Ring)+",";
  A += taka_input_form(S->F)+")";
  return A;
}
def taka_poly_terminal_form_poly_polynomial(S) {
  A  = "{";
  /* A += "Ring->"+taka_terminal_form(S->Ring)+","; */
  R = S->Ring;
  P = quote_sort_polynomial(S->F,R->Variables,R->Order);
  A += "F->"+taka_terminal_form(P)+"}";
  return A;
}

def taka_poly_tex_form_poly_polynomial(S,Tb) {
  R = S->Ring;
  P = quote_sort_polynomial(S->F,R->Variables,R->Order);
  taka_tex_form(P,Tb);
}

/* Printing and input method 
   for POLY_IDEAL
*/
def taka_poly_input_form_poly_ideal(S) {
  A  = "new__poly_ideal(";
  A += taka_input_form(S->Generators)+",";
  A += taka_input_form(S->Ring)+",";
  A += taka_input_form(S->Grobner);
  A += ")";
  return A;
}
def taka_poly_terminal_form_poly_ideal(S) {
  R = S->Ring;
  P = map(quote_sort_polynomial,S->Generators,R->Variables,R->Order);
  A  = "{";
  A += "Generators->";
  A += taka_terminal_form(P);
  A += "}";
  return A;
}

def taka_poly_tex_form_poly_ideal(S,Tb) {
  R = S->Ring;
  P = map(quote_sort_polynomial,S->Generators,R->Variables,R->Order);
  taka_tex_form(P,Tb);
}

/* Utility function to get variables. */
def taka_poly_get_variables(L) {
  if (type(L) == LIST) {
    N = length(L);
    V = [ ];
    for (I=0; I<N; I++) {
      V = base_set_union(V,vars(L[I]));
    }
    return V;
  }else if (type(L) == STRUCT) {
    if (struct_type(L) == POLY_IDEAL) {
      return L->Ring->Variables;
    }
  }else if (type(L) == RPOLYNOMIAL) {
    return vars(L);
  }else if (L == 0) {
    return [ ];
  }
  return "???";
}

/*
  taka_poly_elimination_ideal(I,V,VV|grobner_basis=yes);
 --> new interface
  taka_poly_elimination_ideal(I,VV | v=V, grobner_basis=yes);
*/
def taka_poly_elimination_ideal(I,VV) {
  II = I;
  /* option grobner */
  Gb = getopt(grobner_basis);
  if (type(Gb) == -1) {
    Gb = 0;
  }else{
    Gb = 1;
  } 
  /* option v */
  V = getopt(v);
  if (type(V) == -1) {
    V = taka_poly_get_variables(I);
  }

  if (type(I) == STRUCT) {
    if (struct_type(I) == POLY_IDEAL) {
      I = II->Generators;
      V = II->Ring->Variables;
      if (II->Grobner) {
         Gb = 1;
      }else {
         Gb = 0;
      }
    }else{
      error("Argument should be ideal.");
    }
  }
  if (!Gb) {
     V2 = base_set_minus(V,VV);
     V2 = append(V2,VV);
     /* Computing a lexicographic GB. */
     I = gr(I,V2,2);
  }

  S = map(taka_poly_elimination_poly,I,V,VV);
  S = base_prune(0,S);
  if (type(II) == STRUCT) {
    SS = new__poly_ideal(new__poly_ring(VV,2,II->Ring->K,II->Weyl),S,0);
    return SS;
  }else{
    return S;
  }
}

def taka_poly_elimination_poly(F,V,VV) {
  U = vars(F);
  U = base_intersection(U,V);
  if (base_subsetq(U,VV)) {
     return F;
  }else{
     return 0;
  }
}

def taka_poly_grobner_basis(I) {
  II = I;
  /* option order */
  Or = getopt(order);
  if (type(Or) == -1) {
    Or = 0;
  }
  /* option v */
  V = getopt(v);
  if (type(V) == -1) {
    if (type(I) == LIST && length(I) > 0 && type(I[0]) == QUOTE) {
       I = quote_to_obj(I); QuoteIn = 1;
       V = taka_poly_get_variables(I);
    }else{
       V = taka_poly_get_variables(I);
    }
  }
  Gb = 0;
  if (type(I) == STRUCT) {
    if (struct_type(I) == POLY_IDEAL) {
      I = II->Generators;
      V = II->Ring->Variables;
      Or = II->Ring->Order;
      if (II->Grobner) {
         Gb = 1;
      }else {
         Gb = 0;
      }
      R = II->Ring;
    }else{
      error("Argument should be ideal.");
    }
  }else{
    R = new__poly_ring(V,Or,base_Q,0);
  }
  if (!Gb) {
    Or = taka_poly_legacy_order(Or,V);
    /* print(V); print(Or); */
    G = dp_gr_main(I | v=V, order=Or);
    if (QuoteIn) G = quote_to_quote(G);
  }else{
    G = II->Generators;
  }

  SS = new__poly_ideal(R,G,1);
  return SS;
}

def taka_poly_legacy_order(Ord,V) {
  if (type(Ord) > 1) return Ord;
  if (Ord == 0) return [append([@grlex],V)];
  else if (Ord == 1) return [append([@glex],V)];
  else if (Ord == 2) return [append([@lex],V)];
  error("Unknown order.");
}

def taka_poly_hilbert_polynomial(I) {
  /* option grobner */
  S = getopt(s);
  if (type(S) == -1) {
    S = h;
  }
  /* option v */
  V = getopt(v);
  if (type(V) == -1) {
    V = taka_poly_get_variables(I);
  }
  Gb = 0;
  if (type(I) == STRUCT) {
   if (struct_type(I) == POLY_IDEAL) {
     if (I->Grobner) {
       Gb = 1;
     }
     G = I->Generators;
   }
  }else {
     G = I;
  }
  if (!Gb) {
    A=gr(G,V,0); 
    B=map(dp_ht,map(dp_ptod,A,V));
  }else{
    if (I->Order != 0) {
     /*
      Use poly_initial instead. 
      print("Warning. It computes the hilbert polynomial for initial.");
      print("         If the order is not graded order, it DOES NOT return");
      print("         the hilbert polynomial for the original ideal.");
     */
      A = gr(G,V,0);
    }else{
      dp_ord(I->Order);
      A = G;
    }
    B=map(dp_ht,map(dp_ptod,A,V));
  }
  C=map(dp_dtop,B,V);
  H = sm1.hilbert([C,V]);
  return subst(H,h,S);
}

def taka_poly_initial(I) {
  II = I;
  /* option order */
  Or = getopt(order);
  if (type(Or) == -1) {
    Or = 0;
  }
  /* option v */
  V = getopt(v);
  if (type(V) == -1) {
    V = taka_poly_get_variables(I);
  }
  Gb = 0;
  if (type(I) == STRUCT) {
    if (struct_type(I) == POLY_IDEAL) {
      I = II->Generators;
      V = II->Ring->Variables;
      Or = II->Ring->Order;
      if (II->Grobner) {
         Gb = 1;
      }else {
         Gb = 0;
      }
      R = II->Ring;
    }else{
      error("Argument should be ideal.");
    }
  }else{
    R = new__poly_ring(V,Or,base_Q,0);
  }
  if (!Gb) {
    G = gr(I,V,Or);
  }else{
    G = II->Generators;
  }

  dp_ord(Or);
  G2 = map(dp_ptod,G,V);
  /* G3 = map(dp_hm,G2); */
  G3 = map(dp_ht,G2); 
  G4 = map(dp_dtop,G3,V);

  if (R->Weyl) {
    R = new__poly_ring(R->Variables,R->Order,R->K,0);
    /* New ring is commutative. */
  }
  SS = new__poly_ideal(R,G4,1);
  return SS;
}

def taka_poly_initial_coefficients(I) {
  II = I;
  /* option order */
  Or = getopt(order);
  if (type(Or) == -1) {
    Or = 0;
  }
  /* option v */
  V = getopt(v);
  if (type(V) == -1) {
    V = taka_poly_get_variables(I);
  }
  Gb = 0;
  if (type(I) == STRUCT) {
    if (struct_type(I) == POLY_IDEAL) {
      I = II->Generators;
      V = II->Ring->Variables;
      Or = II->Ring->Order;
      if (II->Grobner) {
         Gb = 1;
      }else {
         Gb = 0;
      }
      R = II->Ring;
    }else{
      error("Argument should be ideal.");
    }
  }else{
    R = new__poly_ring(V,Or,base_Q,0);
  }
  if (!Gb) {
    G = gr(I,V,Or);
  }else{
    G = II->Generators;
  }

  dp_ord(Or);
  G2 = map(dp_ptod,G,V);
  G3 = map(dp_hc,G2); 
  return G3;
}

def taka_poly_initial_term(F) {
  V = getopt(v);
  Order = getopt(order);
  Weight = getopt(weight);
  if (type(F) == STRUCT) {
    if (struct_type(F) == POLY_POLYNOMIAL) {
      VV = F->Ring->Variables;
      OOrder = F->Ring->Order;
      F = F->F;
    }else{
      error("Invalid structure as an argument.");
    }
  }
  if (type(V) == -1) {
    if (VV == 0) {
      V = taka_poly_get_variables(F);  
    }else {
      V = VV;
    }
  }
  if (type(Order) == -1) {
    if (OOrder == 0) {
      Order = 0;
    }else{
      Order = OOrder;
    }
  }
  if (type(Weight) == -1) {
    Weight = 0;
  }
  if (Weight == 0) {
     dp_ord(Order);
     G = dp_ptod(F,V);
     T = dp_hm(G);

     return [dp_dtop(T,V)];
  }else {
     dp_ord(taka_poly_weight_vector(Weight,V));
     G = dp_ptod(F,V);
     C = 0;  T = 0;
     D = dp_ht(G);
     D = taka_poly_degree(D|weight=Weight,v=V);
     while (G != 0) {
       H = dp_ht(G);
       if (D > taka_poly_degree(H|weight=Weight,v=V)) break;
       T += dp_hm(G);
       G = G-dp_hm(G);
     }
     return [dp_dtop(T,V),D];
  }
}

def taka_poly_degree(F) {
  if (F == 0) return 0;
  V = getopt(v);
  Weight = getopt(weight);
  if (type(F) == STRUCT) {
    if (struct_type(F) == POLY_POLYNOMIAL) {
      VV = F->Ring->Variables;
      F = F->F;
    }else{
      error("Invalid structure as an argument.");
    }
  }
  if (type(V) == -1) {
    if (VV == 0) {
      if (type(F) != DPOLYNOMIAL) {
        V = taka_poly_get_variables(F);  
      }else{
        V = dp_etov(F);
        V = vtol(V); /* Dummy */
      }
    }else {
      V = VV;
    }
  }
  N = length(V);
  if (type(Weight) == -1) {
    Weight = newvect(N);
    for (I=0; I<N; I++) Weight[I] = 1;
  }else{
    Weight = taka_poly_weight_vector_parse(Weight,V);
  }

  if (F == 0) return 0;
  if (type(F) != DPOLYNOMIAL) {
    dp_ord(taka_poly_weight_vector(Weight,V));
    F = dp_ptod(F,V);
  }
  if (type(Weight) != VECTOR) {
    Weight = newvect(N,Weight);
  }
  D = matrix_inner_product(dp_etov(F),Weight);
  return D;
}

/*
  taka_poly_weight_vector(W,V) returns "order".
  cf. dp_ord().
  Example:
  taka_poly_weight_vector([1,0,0],[x,y,z]);
  taka_poly_weight_vector([[1,1,1],[1,-1,0]],[x,y,z]);
  taka_poly_weight_vector([x,1,y,1],[x,y,z]);
*/
def taka_poly_weight_vector(W,V) {
  if (type(W) == VECTOR || type(W) == MATRIX) {
     W = omatrix_mtol(W);
  }else if (type(W) == NUMBER || type(W) == 0) {
     return W;
  }    
  if (type(W[0]) == LIST) {
    return taka_poly_weight_vectors(W,V);
  }else{
    return taka_poly_weight_vector1(W,V);
  }
  error("Invalid argument for taka_poly_weight_vector");
}

def taka_poly_weight_vector1(W,V) {
  WW = taka_poly_weight_vector_parse(W,V);
  N = length(V);
  WW = newmat(N+1,N,[WW]);
  for (I=1; I<N+1; I++) {
    WW[I][N-I] = -1;
  }
  return WW;
}

def taka_poly_weight_vectors(W,V) {
  L = length(W);
  WW = [ ];
  for (I=0; I<L; I++) {
    WW = append(WW,[taka_poly_weight_vector_parse(W[I],V)]);
  }
  N = length(V);
  M = N+L;
  WW = newmat(M,N,WW);
  J = 1;
  for (I=L; I<M; I++) {
    WW[I][N-J] = -1; J++;
  }
  return WW;
}

/* w = [1,0,0,1], or [x,1,y,1] */
def taka_poly_weight_vector_parse(W,V) {
  N = length(V);
  M = length(W);
  Ans = newvect(N);
  Type = 0;
  for (I=0; I<M; I++) {
    if (type(W[I]) == STRING) {
      W[I] = eval_str(W[I]);
    }
    if (type(W[I]) == RPOLYNOMIAL) {
       Type = 1;
       K = base_position(W[I],V);
       if (K >=0 && K < N) {
          Ans[K] = W[I+1];
       }else{
         print("W=",0); print(W);
         print("V=",0); print(V);
         error("weight vector format error.");
       }
    }else if (!Type) {
       if (N != M) {
         error("weight vector format error.");
         print("W=",0); print(W);
         print("V=",0); print(V);
       }
       Ans[I] = W[I];
    }
  }
  return vtol(Ans);
}

Taka_poly_loaded = 1$
end$


