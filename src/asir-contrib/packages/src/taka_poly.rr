/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_poly.rr,v 1.5 2001/08/21 02:07:18 takayama Exp $ */
#define RPOLYNOMIAL 2
#define RATIONAL 3
#define LIST 4
#define VECTOR 5
#define MATRIX 6
#define STRUCT 8

def taka_poly_solve_poly1(F,V) {
  if (type(F) == 3) { /* Rational */
    G = dn(F); 
    if (deg(G,V) != 0) {
      return quote(root_of(F));
    }
  }
  Ans = [ ] ;
  G = nm(F);
  F = fctr(G);
  N = length(F);
  for (I=0; I<N; I++) {
    if (deg(F[I][0],V) == 0) {
    }else if (deg(F[I][0],V) == 1) {
       Sol = red( -coef(F[I][0],0,V)/coef(F[I][0],1,V) );
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }else {
       /* Sol = quote(root_of( F[I][0] )); */
       Sol = F[I][0];
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }
  }
  return Ans;
}

def taka_poly_solve_linear(Z,X) {
  Size_Z = length(Z);
  Sol = [ ];
  F = [];
  for (I = 0; I < Size_Z; I++) {
    if (Z[I] != 0) {
      if (type(Z[I]) == 3) {
        F = append(F,[ nm(red(Z[I])) ]);
      }else{
        F = append(F, [Z[I]]);
      }
    }
  }

  if (F == []) {
    return Sol;
  }

  G = gr(F, reverse(X), 2);

  if (G[0] == 1 || G[0] == -1) {
    return [];
  }

  Sol = newvect(length(X));
  N = 0;
  for (I = 0; I < length(G); I++) {
    for (J = length(X) - 1; J >= 0; J--) {
      Nm = nm(G[I]); Dn = dn(G[I]);
      if (coef(Nm, 1, X[J]) != 0) {
        Sol[J] = [X[J], X[J] - Nm/coef(Nm, 1, X[J])];
        N++;
        break;
      }
    }
  }
  Sol2 = newvect(N);
  I = 0;
  for (J=0; J<size(Sol)[0]; J++) {
    if (Sol[J] == 0) {
    }else{
       Sol2[I] = Sol[J]; I++;
    }
  }
  return vtol(Sol2);
}

def taka_poly_factor(S) {
  if (type(S) == LIST || type(S) == MATRIX || type(S) == VECTOR) {
    return( map(taka_poly_factor,S) );
  }
  if (type(S) == RPOLYNOMIAL) {
     S1 = new_poly_factored_polynomial();
     S1->F = fctr(S);
     return S1;
  }
  if (type(S) == RATIONAL) {
     NN = nm(S); DD = dn(S);
     NN = taka_poly_factor(NN);
     DD = taka_poly_factor(DD);
     S = new_poly_factored_rational();
     S->Numerator = NN;
     S->Denominator = DD;
     return S;
  }
  /* It has not yet been implemented. */
  return S;
}

/*
  taka_poly_elimination_ideal(I,V,VV|grobner_basis=yes);
*/
def taka_poly_elimination_ideal(I,V,VV) {
  Gb = getopt(grobner_basis);
  if (type(Gb) == -1) {
    Gb = 0;
  }else{
    Gb = 1;
  } 
  if (!Gb) {
     V2 = base_set_minus(V,VV);
     V2 = append(V2,VV);
     /* Computing a lexicographic GB. */
     I = gr(I,V2,2);
  }
  S = map(taka_poly_elimination_poly,I,V,VV);
  S = base_prune(0,S);
  return S;
}

def taka_poly_elimination_poly(F,V,VV) {
  U = vars(F);
  U = base_intersection(U,V);
  if (base_subsetq(U,VV)) {
     return F;
  }else{
     return 0;
  }
}

Taka_poly_loaded = 1$
end$


