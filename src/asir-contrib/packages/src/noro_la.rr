load("gr")$
load("sp")$

def random_mat(N,Bound)
{
	A = matrix(N,N);
	for ( I = 0; I < N; I++ )
		for ( J = 0; J < N; J++ )
			A[I][J] = (random()%Bound)*(random()%2?-1:1);
	return A;
}

def random_rmat(M,N,Bound)
{
	A = matrix(M,N);
	for ( I = 0; I < M; I++ )
		for ( J = 0; J < N; J++ )
			A[I][J] = (random()%Bound)*(random()%2?-1:1);
	return A;
}

def random_vect(N,Bound)
{
	A = vector(N);
	for ( I = 0; I < N; I++ )
		A[I] = (random()%Bound)*(random()%2?-1:1);
	return A;
}

def dup_vector(A)
{
	S = size(A); R = S[0];
	M = vector(R);
	for( I = 0; I < R; I++ )
		M[I] = A[I];
	return M;
}

def zero_vector(A)
{
	S = size(A);
	M = S[0];
	for ( I = 0; I < M; I++ )
		if ( A[I] ) return 0;
	return 1;
}

def zero_mat(A)
{
	S = size(A);
	M = S[0]; N = S[1];
	for ( I = 0; I < M; I++ )
		for ( J = 0; J < N; J++ )
			if ( A[I][J] ) return 0;
	return 1;
}

def const_term(F)
{
	V = var(F);
	if ( V )
		return const_term(coef(F,0,V));
	else
		return F;
}

def get_alg(L)
{
	for ( T = L, R = []; T != []; T = cdr(T) )
		R = union_sort(R,getalgtreep(car(T)));
	return R;
}

def compute_kernel(A)
{
	B = getopt(rhs);
	if ( type(B) == -1 || (type(B)==5 && zero_vector(B)) ) B = 0;
	S = size(A); M = S[0]; N = S[1];
	for ( I = 0, V = vector(N); I < N; I++ ) V[I] = strtov("x"+rtostr(I));
	VL = reverse(vtol(V));
	E = B ? vtol(A*V-B) : vtol(A*V);
	Alg = get_alg(E);
	if ( Alg != [] ) {
		AlgV = map(algptorat,Alg);
		Defpoly = map(defpoly,Alg);
		Eext = append(reverse(Defpoly),map(algptorat,E));
		VLext = append(VL,AlgV);
		Ord = [[0,N],[0,length(Alg)]];
#if 1
		G = dp_f4_main(Eext,VLext,Ord);
#else
		G = nd_gr(Eext,VLext,0,Ord);
#endif
		G = map(rattoalgp,G,Alg);
		for ( T = G, G0 = []; T != []; T = cdr(T) )
			if ( vars(car(T)) != [] ) G0 = cons(car(T),G0);
		G = reverse(G0);
	} else {
		dp_ord(0);
		G = nd_gr(E,VL,0,0);
	}
	D = map(dp_ptod,G,VL);
	for ( LCM = 1, T = D; T != []; T = cdr(T) )
		LCM = ilcm(dp_hc(car(T)),LCM);
	for ( T = D, Sol = LCM*V; T != []; T = cdr(T) ) {
		P = car(T);
		EV = dp_etov(dp_ht(P));
		for ( I = 0; !EV[I]; I++ );
		Sol[N-I-1] = dp_dtop((-LCM/dp_hc(P))*dp_rest(P),VL);
	}
	for ( T = reverse(vars(Sol)), Ker = []; T != []; T = cdr(T) ) {
		Sol0 = map(coef,Sol,1,car(T));
		for ( I = 0; I < N && !Sol0[I]; I++ );
		Ker = cons([Sol0,I],Ker);
	}
	return B ? [map(const_term,Sol)/LCM,Ker] : Ker;
}

def jordan_canonical_form(A)
{
	N = size(A)[0];
	M = linalg.minipoly_mat(A);
	FM = fctr(M);
	/* skip const */
	FM = cdr(FM);
	L = length(FM);

	/* extracting roots and multiplicities */
	Alpha = vector(L);
	E = vector(L);
	D = vector(L);
	for ( I = 0; I < L; I++ ) {
		F = FM[I][0];
		D[I] = deg(F,x);
		Alpha[I] = D[I]==1 ? -coef(F,0,x)/coef(F,1,x) : newalg(F);
		E[I] = FM[I][1];
	}

	Q = matrix(N,N);
	for ( K = 0, J = 0; K < L; K++ ) {
		JBK = compute_jordan_block_basis(A,Alpha[K],E[K]);
		for ( T = JBK; T != []; T = cdr(T), J++ ) {
			V = car(T);
			for ( I = 0; I < N; I++ )
				Q[I][J] = V[I];
		}
	}
	return Q;
}

def reduce_vect(M,Base)
{
	N = size(M)[0];
	M = linalg.dup_vect(M);
	for ( T = Base; T != []; T = cdr(T) ) {	
		B = car(T);
		BM = B[0]; I = B[1];
		if ( M[I] ) {
			/* M <- M*BM[I]-M[I]*BM */
			C1 = BM[I]; C2 = M[I];
			linalg.mulsub_vect(M,C1,BM,C2);
		}
	}
	for ( I = 0; I < N; I++ )
		if ( M[I] ) return [M,I];
	return [0,-1];
}

/* Span(Base) = Ker((A-Alpha*E)^E) */

def compute_jordan_block_basis(A,Alpha,E)
{
	NI = linalg.unit_mat(size(A)[0]);
	N = A-Alpha*NI;
	Ker = vector(E+1);
	R = vector(E+1);
	for ( I = 0; I <= E; I++ ) {
		Ker[I] = compute_kernel(NI);
		R[I] = length(Ker[I]);
		NI *= N;
	}
	/* PW : previous W */
	PW = [];
	AllBase = [];
	for ( I = E-1; I >= 0; I-- ) {
		NPW = [];
		for ( T = PW, Base = Ker[I]; T != []; T = cdr(T) ) {
			NPW = cons(N*car(T),NPW);
			Red = reduce_vect(car(NPW),Base);
			Base = linalg.insert_to_sbase(Red,Base);
		}
		/* number of elements to be added */
		DW = length(Ker[I+1])-length(Ker[I])-length(NPW);
		print(DW,0); print("=>",0);
		PW = NPW;
		for ( T = Ker[I+1]; DW > 0; T = cdr(T) ) {
			Red = reduce_vect(car(T)[0],Base);
			if ( Red[0] ) {
				DW--;
				PW = cons(Red[0],PW);
				Base = linalg.insert_to_sbase(Red,Base);
				for ( Kry = [car(T)[0]], K = 0; K < I; K++ )
					Kry = cons(N*car(Kry),Kry);
				AllBase = append(reverse(Kry),AllBase);
			}
		}
		print(DW);
	}
	return reverse(AllBase);
}

def first_element(L)
{
	return car(L);
}

def next_combination(N,K,C)
{
	if ( !K ) return 0;
	for ( I = K-1; I >= 0 && C[I] == N+I-K; I-- );
	if ( I < 0 ) return 0;
	T = ++C[I++];
	for ( T++ ; I < K; I++, T++ ) C[I] = T;
	return 1;
}

def reduce_symmetric_form(F,E,V)
{
	N = size(E)[0]-1;
	F = dp_ptod(F,V);
	W = vector(N+1);
	for ( I = 0; I <= N; I++ )
		W[I] = strtov("e"+rtostr(I));
	R = 0;
	while ( F ) {
		HT = dp_ht(F);
		S = E[0];
		SE = 1;
		while ( dp_td(HT) ) {
			for ( I = N; I >= 1; I-- )
				if ( dp_redble(HT,dp_ht(E[I])) ) {
					HT = dp_subd(HT,dp_ht(E[I]));
					S *= E[I];
					SE *= W[I];
					break;
				}
		}
		C = dp_hc(F);
		F -= S*C;
		R += SE*C;
	}
	return R;
}

def generate_elementary_symmetric_form(N)
{
	C = vector(N);
	V = vector(N);
	for ( I = 0; I < N; I++ )
		V[I] = strtov("x"+rtostr(I));
	R = [1];
	for ( I = 1; I <= N; I++ ) {
		for ( J = 0; J < I; J++ ) C[J] = J;
		EI = 0;
		do {
			for ( J = 0, E = 1; J < I; J++ )
				E *= V[C[J]];
			EI += E;
		} while ( next_combination(N,I,C) );
		R = cons(EI,R);
	}
	dp_ord(2);
	V = vtol(V);
	return [ltov(map(dp_ptod,reverse(R),V)),V];
}

def partial_fraction(F,E)
{
	V = var(F);
	N = deg(F,V);
	FE = F^E;
	R = -1;
	L = generate_elementary_symmetric_form(N);
	ES = L[0];
	ESV	=L[1];
	NE = N*E;
	for ( I = 0; I < N; I++ ) {
		for ( J = 0, H = 0; J < E; J++ ) {
			T = strtov("h"+rtostr(I)+"_"+rtostr(J));
			H += T*V^J;
		}
		Q = sdiv(FE,(V-ESV[I])^E);
		R += srem(Q*H,subst(F,V,ESV[I]));
	}
	HV = [];
	for ( J = E-1; J >= 0; J-- )
		for ( I = N-1; I >= 0; I-- )
			HV = cons(strtov("h"+rtostr(I)+"_"+rtostr(J)),HV);
	for ( I = 0, L2 = []; I < NE; I++ )
		L2 = cons(coef(R,I,V),L2);
	for ( I = 1, SGN = -1, L1 = []; I <= N; I++, SGN =-SGN )
		L1 = cons(dp_dtop(ES[I],ESV)-SGN*coef(F,I,V),L1);
	L = append(L1,L2);
#if 0
	G2 = dp_gr_main(L2,HV,0,0,2);
	G1 = dp_gr_main(L1,ESV,0,0,2);
	AllV = append(HV,ESV);
	G = nd_gr(append(G1,G2),AllV,0,2);
#else
	AllV = append(HV,ESV);
	G = nd_gr(L,AllV,0,2);
#endif
	R = 0;
	for ( I = 0; I < N; I++ ) {
		for ( J = 0, H = 0; J < E; J++ ) {
			T = strtov("h"+rtostr(I)+"_"+rtostr(J));
			H += T*V^J;
		}
		Q = sdiv(FE,(V-ESV[I])^E);
		T = p_true_nf(srem(ESV[I]*Q*H,subst(F,V,ESV[I])),G,AllV,2);
		R += T[0]/T[1];
	}
	return R;
}
end$
