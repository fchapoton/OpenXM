/* $OpenXM: OpenXM/src/asir-contrib/packages/src/noro_print.rr,v 1.1 2004/02/26 10:48:06 noro Exp $ */
#include "tags.h"
#define NOT_YET   print("It has not yet been implemented.")

Noro_print_dp_vlist_vname="x"$
Noro_print_warning=0$
Noro_print_tex_table=[]$

def taka_tex_form_top(S,Argv) {
  extern Noro_print_tex_table;
  Noro_print_tex_table = [];
  for (I=0; I<length(Argv); I++) {
    if (Argv[I][0] == "table") {
      Noro_print_tex_table = Argv[I][1];
    }else{
      error("Unknown option "+rtostr(Argv[I][0])+" in print_tex_form.");
    }
  }
  Tb = string_to_tb("");
  noro_tex_form(S,Tb);
  Str = tb_to_string(Tb);
  return Str;
}

def noro_tex_form(S,Tb) {
  if (type(S) == MATRIX) {
     noro_tex_form_matrix(S,Tb);
  }else if (type(S) == VECTOR) {
     noro_tex_form_vector(S,Tb);
  }else if (type(S) == LIST) {
     noro_tex_form_list(S,Tb);
  }else if (noro_is_fractional(S)) {
     ( noro_tex_form_frac(S,Tb) );
  }else if (type(S) == DPOLYNOMIAL) {
     noro_tex_form_polynomial(S,Tb);
  }else if (type(S) == RPOLYNOMIAL) {
     noro_tex_form_polynomial(S,Tb);
  }else if (type(S) == STRUCT) {
     noro_tex_form_struct(S,Tb);
  }else if (type(S) == QUOTE) {
     noro_tex_form_quote(S,Tb);
  }else {
   /* How to translate sin to \sin?
      Use vtype, get args, ... to print sin. 
      quote("x+2*y");  there is no way to get the left leaves and right leaves
      for now.   eval_quote.
   */
	 write_to_tb(rtostr(S),Tb);
  }
}

def noro_tex_form_list(A,Tb) {
  S = objtoquote(A);
  quotetotex_tb(S,Tb);
}

def noro_tex_form_polynomial(S,Tb) {
  S = objtoquote(S);
  S = quotetotex_tb(S,Tb);
}

def noro_tex_form_quote(S,Tb) {
  quotetotex_tb(S,Tb);
}

def noro_tex_form_matrix(A,Tb) {
  N = size(A)[0];
  M = size(A)[1];
  write_to_tb("\\pmatrix{\n",Tb);
  for (I=0; I<N; I++) {
    for (J=0; J<M; J++) {
      noro_tex_form(A[I][J],Tb);
      if (J != M-1) write_to_tb("& ",Tb);
    }
    write_to_tb(" \\cr\n",Tb);
  }
  write_to_tb("}\n",Tb);
}

def noro_tex_form_vector(A,Tb) {
  N = size(A)[0];
  write_to_tb("\\pmatrix{\n",Tb);
  for (I=0; I<N; I++) {
    noro_tex_form(A[I],Tb);
    if (I != N-1) write_to_tb("& ",Tb);
  }
  write_to_tb("\\cr}\n",Tb);
}

def noro_is_fractional(A) {
  if (type(A) == RATIONAL) return 1;
  else if (type(A) == NUMBER && dn(A) != 1) return 1;
  else return 0;
}

def noro_tex_form_frac(A,Tb) {
  extern Print_tex_form_fraction_format;
  if (Print_tex_form_fraction_format == "frac") {
    write_to_tb("\\frac{",Tb);
    noro_tex_form(nm(A),Tb); write_to_tb("}{",Tb);
    noro_tex_form(dn(A),Tb); write_to_tb("}",Tb);
  }else if (Print_tex_form_fraction_format == "auto") {
	Ntb = string_to_tb(""); noro_tex_form(nm(A),Ntb);
	Dtb = string_to_tb(""); noro_tex_form(dn(A),Dtb);
    if (str_len(Ntb) > 120 || str_len(Dtb) > 120) {
      write_to_tb("(",Tb); write_to_tb(Ntb,Tb); write_to_tb(")/",Tb);
      write_to_tb("(",Tb); write_to_tb(Dtb,Tb); write_to_tb(")",Tb);
    }else {
      write_to_tb("\\frac{",Tb); write_to_tb(Ntb,Tb);
	  write_to_tb("}{",Tb); write_to_tb(Dtb,Tb); write_to_tb("}",Tb);
    }
  }else {
    write_to_tb("(",Tb); noro_tex_form(nm(A),Tb); write_to_tb(")/",Tb);
    write_to_tb("(",Tb); noro_tex_form(dn(A),Tb); write_to_tb(")",Tb);
  } 
}

/* Tentative */
def noro_tex_form_struct(S,Tb) {
  if (struct_type(S) == POLY_FACTORED_POLYNOMIAL || 
      struct_type(S) == POLY_FACTORED_RATIONAL) {
      Str = noro_poly_tex_form_poly_factored_polynomial(S);
	  write_to_tb(Str,Tb);
  }
  else if (struct_type(S) == POLY_RING) {
      Str = noro_poly_tex_form_poly_ring(S);
	  write_to_tb(Str,Tb);
  }
  else if (struct_type(S) == POLY_POLYNOMIAL) {
      Str = noro_poly_tex_form_poly_polynomial(S);
	  write_to_tb(Str,Tb);
  }
  else if (struct_type(S) == POLY_IDEAL) {
      Str = noro_poly_tex_form_poly_ideal(S);
	  write_to_tb(Str,Tb);
  }else {
     print("Unknown struct object for tex_form. Return ???");
  }
}

Loaded_noro_print=1$
end$
