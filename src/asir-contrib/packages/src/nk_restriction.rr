load("bfct")$

/*
#define DEBUG_RESTRICTION
*/

module nk_restriction;

localf generic_bfct_and_gr;
localf initial_ideal;
localf restriction;
localf max_int_root;
localf test_max_int_root;
localf gen;
localf cons_rev;
localf test_gen;
localf ord_w;
localf weyl_mul;
localf test_restriction;
localf test_restriction2;
localf test_restriction3;
localf restriction_ideal;
localf restriction_ideal_internal;
localf test_restriction_ideal_internal;
localf test_nd_weyl_gr;
localf fourier_trans;
localf test_fourier_trans;
localf inv_fourier_trans;
localf test_inv_fourier_trans;
localf integration;
localf test_integration;
localf test_integration2;
localf test_integration3;
localf test_integration4;
localf test_integration5;
localf integration_ideal;
localf integration_ideal_internal;
localf integration_ideal_;
localf integration_ideal_internal_;
localf test_integration_ideal;
localf test_integration_ideal2;
localf test_integration_ideal5;
localf test_integration_ideal5_;
localf fano2;
localf fano3;
localf p_to_mat;
localf test_p_to_mat;
localf fano_polytope_a;
localf test_fano_polytope_a;
localf fano_polytope;
localf a_to_poly;
localf test_a_to_poly;
localf var_list;
localf test_var_list;
localf d_var;
localf int_fano;

/* source from lib/bfct generic_bfct */
/* generic b-fucntion に加えて F の <_(-W,W) についての GB を返す */ 
/* F : ideal, V : var list(x), DV : var list(dx), W : weight vect */
def generic_bfct_and_gr(F,V,DV,W)
{
	N = length(V);
	N2 = N*2;

	/* If W is a list, convert it to a vector */
	if ( type(W) == 4 )
		W = newvect(length(W),W);

	/* dp_weyl_set_weight とは...? */
	dp_weyl_set_weight(W);

	/* create a term order M in D<x,d> (DRL) */
	M = newmat(N2,N2);
	for ( J = 0; J < N2; J++ )
		M[0][J] = 1;
	for ( I = 1; I < N2; I++ )
		M[I][N2-I] = -1;
	
	VDV = append(V,DV);

	/* create a non-term order MW in D<x,d> */
	MW = newmat(N2+1,N2);
	for ( J = 0; J < N; J++ )
		MW[0][J] = -W[J];
	for ( ; J < N2; J++ )
		MW[0][J] = W[J-N];
	for ( I = 1; I <= N2; I++ )
		for ( J = 0; J < N2; J++ )
			MW[I][J] = M[I-1][J];

	/* create a homogenized term order MWH in D<x,d,h> */
	MWH = newmat(N2+2,N2+1);
	for ( J = 0; J <= N2; J++ )
		MWH[0][J] = 1;
	for ( I = 1; I <= N2+1; I++ )
		for ( J = 0; J < N2; J++ )
			MWH[I][J] = MW[I-1][J];

	/* homogenize F */
	VDVH = append(VDV,[h]);
	FH = map(dp_dtop,map(dp_homo,map(dp_ptod,F,VDV)),VDVH);
	
	/* compute a groebner basis of FH w.r.t. MWH */
	dp_gr_flags(["Top",1,"NoRA",1]);
	GH = dp_weyl_gr_main(FH,VDVH,0,1,11);
	dp_gr_flags(["Top",0,"NoRA",0]);

	/* dehomigenize GH */
	G = map(subst,GH,h,1);

	/* G is a groebner basis w.r.t. a non term order MW */
	/* take the initial part w.r.t. (-W,W) */
	GIN = map(initial_part,G,VDV,MW,W);

	/* GIN is a groebner basis w.r.t. a term order M */
	/* As -W+W=0, gr_(-W,W)(D<x,d>) = D<x,d> */
	
	/* find b(W1*x1*d1+...+WN*xN*dN) in Id(GIN) */
	for ( I = 0, T = 0; I < N; I++ )
		T += W[I]*V[I]*DV[I];
	B = weyl_minipoly(GIN,VDV,0,T); /* M represents DRL order */
	return [B, G];
}

/* source from lib/bfct generic_bfct */
/* F の <_(-W,W) についての GB とその initial part を返す */ 
/* F : ideal, V : var list(x), DV : var list(dx), W : weight vect */
def initial_ideal(F,V,DV,W)
{
	N = length(V);
	N2 = N*2;

	/* If W is a list, convert it to a vector */
	if ( type(W) == 4 )
		W = newvect(length(W),W);

	/* dp_weyl_set_weight とは...? */
	dp_weyl_set_weight(W);

	/* create a term order M in D<x,d> (DRL) */
	M = newmat(N2,N2);
	for ( J = 0; J < N2; J++ )
		M[0][J] = 1;
	for ( I = 1; I < N2; I++ )
		M[I][N2-I] = -1;
	
	VDV = append(V,DV);

	/* create a non-term order MW in D<x,d> */
	MW = newmat(N2+1,N2);
	for ( J = 0; J < N; J++ )
		MW[0][J] = -W[J];
	for ( ; J < N2; J++ )
		MW[0][J] = W[J-N];
	for ( I = 1; I <= N2; I++ )
		for ( J = 0; J < N2; J++ )
			MW[I][J] = M[I-1][J];

	/* create a homogenized term order MWH in D<x,d,h> */
	MWH = newmat(N2+2,N2+1);
	for ( J = 0; J <= N2; J++ )
		MWH[0][J] = 1;
	for ( I = 1; I <= N2+1; I++ )
		for ( J = 0; J < N2; J++ )
			MWH[I][J] = MW[I-1][J];

	/* homogenize F */
	VDVH = append(VDV,[h]);
	FH = map(dp_dtop,map(dp_homo,map(dp_ptod,F,VDV)),VDVH);
	
	/* compute a groebner basis of FH w.r.t. MWH */
	dp_gr_flags(["Top",1,"NoRA",1]);
	GH = dp_weyl_gr_main(FH,VDVH,0,1,11);
	dp_gr_flags(["Top",0,"NoRA",0]);

	/* dehomigenize GH */
	G = map(subst,GH,h,1);

	/* G is a groebner basis w.r.t. a non term order MW */
	/* take the initial part w.r.t. (-W,W) */
	GIN = map(initial_part,G,VDV,MW,W);

	/* GIN is a groebner basis w.r.t. a term order M */
	/* As -W+W=0, gr_(-W,W)(D<x,d>) = D<x,d> */
	
	return [G, GIN];
}

/*
 * restriction module の計算([SST, Alg5.2.8])
 * Id : ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def restriction(Id, VL, DVL, W)
{
tstart();
	Result = generic_bfct_and_gr(Id, VL, DVL, W);
print("-- generic_bfct_and_gr :",2);
tstop();
	BF = Result[0];
	GB = Result[1];

tstart();
	/* BF の最大整数根 S0 を取り出す */
	L = fctr(BF);
	BFF = L;
	/* L の最初の要素は係数なので捨てる */
	L = cdr(L);
	N = length(L);
	S0 = [];
	for (I = 0; I < N; I++) {
		T = L[I][0];
		Root = -coef(T, 0, s) / coef(T, 1, s);
		if (dn(Root) == 1) {
			if (S0 == []) {
				S0 = Root;
			} else if (Root > S0) {
				S0 = Root;
			} 
		}
	}
	/* b-function が非負整数根を持たない場合([SST, Cor5.2.7]) */
	if (S0 == [] || S0 < 0) 
		return 0;
	print("generic bfct : " + rtostr(BFF), 1);
	print("S0 : " + rtostr(S0), 1);
	for (M = 0; M < length(W); M++) 
		if (W[M] <= 0)
			break;

	/* W の正の要素の部分だけとりだしたもの WW */
	WW = newvect(M);
	for (I = 0; I < M; I++)
		WW[I] = W[I];
	WW = vtol(WW);
	/* B_{S0} の生成 */
	Base = gen(WW, S0);
	print("B_{S0} length : " + rtostr(length(Base)),1); 

	V = newvect(length(W), W); 
	MinusW = vtol(-V);
	WVect = append(MinusW, W);
	VarL  = append(VL, DVL);
	NN = length(GB);
	OrderGB = newvect(NN);	
	for (I = 0; I < NN; I++) 
		OrderGB[I] = ord_w(GB[I], VarL, WVect); 
	Generator = [];
	for (I = 0; I < NN; I++) {
		/* 
		 * B_{S0 - OrderGB[I]} 
		 * i.e. WW[0]*I[0]+...+WW[M-1]*I[M-1] <= 
                 * S0 - OrderGB[I] なる (I[0],...,I[M-1]) の生成 
		 */
		B = gen(WW, S0 - OrderGB[I]);
		while (B != []) {
			Index = car(B);
			D = 1;
			for (J = 0; J < M; J++) 
				D *= DVL[J]^Index[J];
			P = weyl_mul(D, GB[I], VarL);
			for (J = 0; J < M; J++)
				P = subst(P, VL[J], 0);	
			if (P != 0)  
				Generator = cons(P, Generator);
			B = cdr(B);
		}
	}
print("-- fctr(BF) + base :", 2);
tstop();
	return [Generator, Base];
}

/* F は s の多項式 */
/* ただし F は Q 上 1 次式に因数分解できるものとする */
def max_int_root(F)
{
	L = fctr(F);
	/* L の最初の要素は係数なので捨てる */
	L = cdr(L);
	N = length(L);
	S0 = [];
	for (I = 0; I < N; I++) {
		T = L[I][0];
		Root = -coef(T, 0, s) / coef(T, 1, s);
		if (dn(Root) == 1) {
			if (S0 == []) {
				S0 = Root;
			} else if (Root > S0) {
				S0 = Root;
			} 
		}
	}
	return S0;
}

def test_max_int_root()
{
	print(max_int_root(3*(s+3)^2*(s+1)^3));
	print(max_int_root((s+1/2)*(s+1/3)*(s+3)^2*(s+1)^3));
	print(max_int_root((s+1/2)*(s+1/3)*(s+1/5)^2*(s+1/10)^3));
}

/* 
 * I[0]*W[0] + ... + I[M-1]*W[M-1] <= S0 なる 
 * [I[0], ..., I[M-1]] を返す
 */ 
def gen(W, S0)
{
	if (W == []) 
		return [[]];
	Weight = car(W);
	LL = [];
	for (I = 0; I <= S0 / Weight; I++) {
		L = gen(cdr(W), S0 - Weight * I);
		L = map(cons_rev, L, I); 
		LL = append(L, LL);
	}
	return LL;
}

/* map 適用のため */
def cons_rev(L, I)
{
	return cons(I, L);
}

def test_gen()
{
	print(gen([1],3));
	print(gen([1,1,1],3));
	print(gen([1,1,1],5));
	print(gen([1,2,3],5));
}

/* from localb.rr */
def ord_w(P, VL, W)
{
        if (P == 0) {
                print("ord_w(0)");
                return;
        }

        N = length(VL);
        DP = dp_ptod(P, VL);

        V = dp_etov(DP);
        DP = dp_rest(DP);       
        for (Max = 0, I = 0; I < N; I++)
                Max += V[I] * W[I];     
        while (DP != 0) {
                V = dp_etov(DP);
                DP = dp_rest(DP);       
                for (Weight = 0, I = 0; I < N; I++)
                        Weight += V[I] * W[I];  
                if (Max < Weight)
                        Max = Weight;
        }
        return Max;
}

/* from localb.rr */
def weyl_mul(P, Q, VL)
{
        DP = dp_ptod(P, VL);
        DQ = dp_ptod(Q, VL);
        return dp_dtop(dp_weyl_mul(DP, DQ), VL);
}

/* restriction のよい計算例はないか... */
def test_restriction()
{
	L = [x*dx-1, y*dy-1];
	print("restriction");
	R1 = restriction(L, [x,y], [dx,dy], [1,0]);
	print(R1);
	print("sm1.restriction");
	R2 = sm1.restriction(L, [x,y], [x]);
	print(R2);
}

def test_restriction2()
{
	/* from [SST, p202] */
	L = [dx^2, dy^2];
	print("restriction");
	R1 = restriction(L, [x,y], [dx,dy], [1,0]);
	print(R1);
	print("sm1.restriction");
	R2 = sm1.restriction(L, [x,y], [x]);
	print(R2);
}

def test_restriction3()
{
	/* Appell F_1 */
	L = [x*(1-x)*dx^2+y*(1-x)*dx*dy+(c-(a+b+1)*x)*dx-b*y*dy-a*b,
	     y*(1-y)*dy^2+x*(1-y)*dx*dy+(c-(a+bb+1)*y)*dy-bb*x*dx-a*bb];
	/* parameter つきでは無理なので特定の値で */
}

/*
 * restriction ideal の計算 [SST, Alg5.2.12] 
 * Id : D-ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def restriction_ideal(Id, VL, DVL, W)
{
	L = restriction(Id, VL, DVL, W);
#ifdef DEBUG_RESTRICTION
	print("restriction :");
	print(L);
#endif
tstart();
	GG = restriction_ideal_internal(L, VL, DVL, W);
print("-- restriction_ideal_internal :", 2);
tstop();
	return GG;
}

/* L : result of restriction */
def restriction_ideal_internal(L, VL, DVL, W)
{
	/* 
	 * restriction module の結果をベクトル表示に直す       
	 * Base と同じ順に dx^Base[I] の係数を I 成分に格納   
	 * restriction の結果の Base は最後の要素が [0,...,0]  
	 * だからベクトル表示した場合、最後の成分が 1 の係数  
	 */
	Gen = L[0];
	Base = L[1];

	M = 0;
	for (M = 0; M < length(W); M++)
		if (W[M] <= 0)
			break;

	N = length(Base);
	P = length(Gen);
	GenV = newvect(P);
	for (I = 0; I < P; I++) {
		T = Gen[I];
		V = newvect(N);
		for (J = 0; J < N; J++) {
			Exp = Base[J];
			/* T の dx_1^Exp[0] .. dx_M-1^Exp[M-1] の係数 を求める */
			C = T;
			for (K = 0; K < M; K++) {
				C = coef(C, Exp[K], DVL[K]);	
			}
			V[J] = C;	
		}
		GenV[I] = vtol(V);
	}	
#ifdef DEBUG_RESTRICTION
	print("Generators :");
	print(GenV);
#endif
	
	NN = length(VL) - M;
	VLY = newvect(NN * 2);
	for (I = 0; I < NN; I++) {
		VLY[I] = VL[I + M];
		VLY[I + NN] = DVL[I + M];
		
	}
	VLY = vtol(VLY);
	GenV = vtol(GenV);
	/* GenV の要素はリストでないと nd_weyl_gr で internal error */
	G = nd_weyl_gr(GenV, VLY, 0, [1,0]);	
#ifdef DEBUG_RESTRICTION
	print("GB :");
	print(G);
#endif

	/* G の元の中で、最後の成分(i.e. 1 の係数) のみ 0 でないものを取り出す */
	Len = length(G);
	GG = [];
	for (I = 0; I < Len; I++) {
		T = G[I];
		for (J = 0; J < N - 1; J++) 
			if (T[J] != 0) 
				break;
		if (J == N - 1 && T[N - 1] != 0) 
			GG = cons(T[N - 1], GG);		
	}
#ifdef DEBUG_RESTRICTION
	print("GG :");
	print(GG);
#endif

	return GG;
}

def test_restriction_ideal_internal()
{
	L = restriction([x*dx-1,y*dy-1],VL=[x,y],DVL=[dx,dy],W=[1,0]);
	print(L);
	restriction_ideal_internal(L, VL, DVL, W);
}

def test_nd_weyl_gr()
{
	/* internal error 
	nd_weyl_gr([newvect(2,[1,x]),newvect(2,[x,y])], [x,y,dx,dy],0,[1,0]);
	*/

	/* invarid argument 
	nd_weyl_gr(newvect(2,[[1,x],[x,y]]), [x,y,dx,dy], 0, [1,0]);
	*/
	
	/* correct */
	nd_weyl_gr([[1,x],[x,y]],[x,y,dx,dy],0,[1,0]);
}

/* 微分作用素 P(x,dx) を Fourier 変換したものを返す */ 
/* i.e. x_i -> - dx_i, dx_i -> x_i                  */
def fourier_trans(P, VL, DVL)
{
	N = length(VL);
	VLL = append(VL, DVL);
	DP = dp_ptod(P, VLL);
	S = 0;
	VE = newvect(2 * N);
	while (DP != 0) {
		C = dp_hc(DP);
		V = dp_etov(DP);

		/* x^a -> (-1)^|a| dx^a に変換(dp で) */
		M = 0;	
		for (I = 0; I < N; I++) 
			VE[I] = 0;
		for (I = 0; I < N; I++) {
			VE[N + I] = V[I];
			M += V[I];	
		}
		DPD = dp_vtoe(VE);
		if (M % 2 == 1) 
			DPD = -DPD;

		/* dx^a -> x^a に変換 */
		for (I = 0; I < N; I++) 
			VE[I] = V[N + I];
		for (I = 0; I < N; I++) 
			VE[N + I] = 0;
		DPX = dp_vtoe(VE);

		T = C * dp_weyl_mul(DPD, DPX);
		S += T;
		DP = dp_rest(DP);
	}
	return dp_dtop(S, VLL);
}

def test_fourier_trans()
{
	print(fourier_trans(x*dx, [x], [dx]));
	print(fourier_trans(x^2*dx^2, [x], [dx]));
	print(fourier_trans(x*dx*y+1, [x], [dx]));
}

/* 微分作用素 P(x,dx) を Fourier 変換したものを返す */ 
/* i.e. x_i -> dx_i, dx_i -> - x_i                  */
def inv_fourier_trans(P, VL, DVL)
{
	N = length(VL);
	VLL = append(VL, DVL);
	DP = dp_ptod(P, VLL);
	S = 0;
	VE = newvect(2 * N);
	while (DP != 0) {
		C = dp_hc(DP);
		V = dp_etov(DP);

		/* x^a -> dx^a に変換(dp で) */
		M = 0;	
		for (I = 0; I < N; I++) 
			VE[I] = 0;
		for (I = 0; I < N; I++) 
			VE[N + I] = V[I];
		DPD = dp_vtoe(VE);

		/* dx^a -> (-1)^|a| x^a に変換 */
		for (I = 0; I < N; I++) {
			VE[I] = V[N + I];
			M += V[N + I];	
		}
		for (I = 0; I < N; I++) 
			VE[N + I] = 0;
		DPX = dp_vtoe(VE);
		if (M % 2 == 1) 
			DPX = -DPX;

		T = C * dp_weyl_mul(DPD, DPX);
		S += T;
		DP = dp_rest(DP);
	}
	return dp_dtop(S, VLL);
}

def test_inv_fourier_trans()
{
	print(inv_fourier_trans(fourier_trans(x^2*dx^2*y+x*dx*dy+y, [x], [dx]),[x],[dx]));
}

/*
 * integration module の計算([SST, Alg5.5.4])
 * Id : ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def integration(Id, VL, DVL, W)
{
	for (M = 0; M < length(W); M++) 
		if (W[M] <= 0)
			break;
	VLM = newvect(M);
	DVLM = newvect(M);
	for (I = 0; I < M; I++) {
		VLM[I]  = VL[I];
		DVLM[I] = DVL[I];	
	}
	VLM = vtol(VLM);
	DVLM = vtol(DVLM);
	
	FId = map(fourier_trans, Id, VLM, DVLM);
	R = restriction(FId, VL, DVL, W);
#ifdef DEBUG_RESTRICTION
	print("restriction of FId :");
	print(R); 
#endif
	Generator = map(inv_fourier_trans, R[0], VLM, DVLM);
	return [Generator, R[1]];
}

def test_integration()
{
	/* [SST, Ex5.5.2, 5.5.6] */
	/* integration of the annihilating ideal of 1/(t^2-x) w.r.t. t */
	Id = [2*t*dx+dt, t*dt+2*x*dx+2];
	return integration(Id, [t,x],[dt,dx],[1,0]);
}

def test_integration2()
{
	/* [SST, Ex5.6.13] */
	/* integration of the annihilating ideal of e^(t^3-x*t) w.r.t. t */
	Id = [dt - (3*t^2-x), dx + t];
	return integration(Id, [t,x],[dt,dx],[1,0]);
}

def test_integration3()
{
	/* [SST, Ex5.5.9]     */
	/* 計算が合わない??   */
	F = x^3+t1^3+t2^3;
	Ann = ann(F);
	Ann0 = map(subst, Ann, s, -2);
	Int = integration(Ann0, [t1,t2,x],[dt1,dt2,dx],[1,1,0]);
	return Int;
}

def test_integration4()
{
	/* [SST, Ex5.5.16]     */
	/* test_integration3 と同じイデアルだが、重みベクトルが異なる */
	F = x1^3+x2^3+x3^3;
	Ann = ann(F);
	Ann0 = map(subst, Ann, s, -2);
	Int = integration(Ann0, [x1,x2,x3],[dx1,dx2,dx3],[1,2,3]);
	return Int;
}

def test_integration5()
{
	/* [SST, Ex5.6.4] */
	G = x1*t1^2*t2+x2*t1^2*t2^2+x3*t1*t2^2+x4+x5*t1*t2;
	Ann = ann(G);
	/* G の bfct は s + 1 */
	Ann0 = map(subst, Ann, s, -1);	
	Int = integration(Ann0, [t1,t2,x1,x2,x3,x4,x5],[dt1,dt2,dx1,dx2,dx3,dx4,dx5],[1,1,0,0,0,0,0]);
	return Int;
}	

/*
 * integration ideal の計算 [SST, Alg5.5.4] 
 * Id : D-ideal
 * VL : var list (x)
 * DVL: var list (dx)
 * W  : weight vector
 *      VL と長さは同じ
 *      W[0], ..., W[M] が正で、それ以降の要素は 0 としておく
 */
def integration_ideal(Id, VL, DVL, W)
{
	L = integration(Id, VL, DVL, W);
#ifdef DEBUG_RESTRICTION
	print("integration :");
	print(L);
#endif
tstart();
	GG = integration_ideal_internal(L, VL, DVL, W);
print("-- integration_ideal_internal :", 2);
tstop();
	return GG;
}

/* L : result of integration */
def integration_ideal_internal(L, VL, DVL, W)
{
	/* 
	 * integration module の結果をベクトル表示に直す       
	 * Base と同じ順に x^Base[I] の係数を I 成分に格納   
	 * restriction の結果の Base は最後の要素が [0,...,0]  
	 * だからベクトル表示した場合、最後の成分が 1 の係数  
	 */
	Gen = L[0];
	Base = L[1];

	M = 0;
	for (M = 0; M < length(W); M++)
		if (W[M] <= 0)
			break;

	N = length(Base);
	P = length(Gen);
	GenV = newvect(P);
	for (I = 0; I < P; I++) {
		T = Gen[I];
		V = newvect(N);
		for (J = 0; J < N; J++) {
			Exp = Base[J];
			/* T の x_1^Exp[0] .. x_M-1^Exp[M-1] の係数 を求める */
			C = T;
			for (K = 0; K < M; K++) {
				C = coef(C, Exp[K], VL[K]);	
			}
			V[J] = C;	
		}
		GenV[I] = vtol(V);
	}	
#ifdef DEBUG_RESTRICTION
	print("Generators :");
	print(GenV);
#endif
	
	NN = length(VL) - M;
	VLY = newvect(NN * 2);
	for (I = 0; I < NN; I++) {
		VLY[I] = VL[I + M];
		VLY[I + NN] = DVL[I + M];
		
	}
	VLY = vtol(VLY);
	GenV = vtol(GenV);
	/* GenV の要素はリストでないと nd_weyl_gr で internal error */
	G = nd_weyl_gr(GenV, VLY, 0, [1,0]);	
#ifdef DEBUG_RESTRICTION
	print("GB :");
	print(G);
#endif

	/* G の元の中で、最後の成分(i.e. 1 の係数) のみ 0 でないものを取り出す */
	Len = length(G);
	GG = [];
	for (I = 0; I < Len; I++) {
		T = G[I];
		for (J = 0; J < N - 1; J++) 
			if (T[J] != 0) 
				break;
		if (J == N - 1 && T[N - 1] != 0) 
			GG = cons(T[N - 1], GG);		
	}
#ifdef DEBUG_RESTRICTION
	print("GG :");
	print(GG);
#endif

	return GG;
}

/* nd_weyl_gr を実行せず、加群の生成元を返す */
/* 計算は完了していない                      */
def integration_ideal_(Id, VL, DVL, W)
{
	L = integration(Id, VL, DVL, W);
	LL = integration_ideal_internal_(L, VL, DVL, W);
	return LL;
}

/* nd_weyl_gr を実行せず、加群の生成元を返す */
def integration_ideal_internal_(L, VL, DVL, W)
{
	/* 
	 * integration module の結果をベクトル表示に直す       
	 * Base と同じ順に x^Base[I] の係数を I 成分に格納   
	 * restriction の結果の Base は最後の要素が [0,...,0]  
	 * だからベクトル表示した場合、最後の成分が 1 の係数  
	 */
	Gen = L[0];
	Base = L[1];

	M = 0;
	for (M = 0; M < length(W); M++)
		if (W[M] <= 0)
			break;

	N = length(Base);
	P = length(Gen);
	GenV = newvect(P);
	for (I = 0; I < P; I++) {
		T = Gen[I];
		V = newvect(N);
		for (J = 0; J < N; J++) {
			Exp = Base[J];
			/* T の x_1^Exp[0] .. x_M-1^Exp[M-1] の係数 を求める */
			C = T;
			for (K = 0; K < M; K++) {
				C = coef(C, Exp[K], VL[K]);	
			}
			V[J] = C;	
		}
		GenV[I] = vtol(V);
	}	
#ifdef DEBUG_RESTRICTION
	print("Generators :");
	print(GenV);
#endif
	
	NN = length(VL) - M;
	VLY = newvect(NN * 2);
	for (I = 0; I < NN; I++) {
		VLY[I] = VL[I + M];
		VLY[I + NN] = DVL[I + M];
		
	}
	VLY = vtol(VLY);
	GenV = vtol(GenV);

	return [GenV, VLY];
}

def test_integration_ideal()
{
	/* [SST, Ex5.5.2, 5.5.6] */
	/* integration of the annihilating ideal of 1/(t^2-x) w.r.t. t */
	Id = [2*t*dx+dt, t*dt+2*x*dx+2];
	L = integration(Id, VL=[t,x],DVL=[dt,dx],W=[1,0]);
	print("integration module :");
	print(L);
	R = integration_ideal_internal(L, VL, DVL, W);
	print("integration ideal :");
	print(R);
}

def test_integration_ideal2()
{
	/* [SST, Ex5.5.7] */
	F = (x1+x2*t+x3*t^2+x4*t^3)*t^2;
	BF = bfct(F);
	print("BF :");
	print(BF); 
	Ann = ann(F);
	Ann0 = map(subst, Ann, s, -1/5);
	print("Ann(F^s)|s=(-1/5) :");
	print(Ann0);
	print("integration ideal :");
	Int = integration_ideal(Ann0, [t,x1,x2,x3,x4],[dt,dx1,dx2,dx3,dx4],[1,0,0,0,0]);
	print(Int);
}

def test_integration_ideal5()
{
	/* [SST, Ex5.6.4] */
	G = x1*t1^2*t2+x2*t1^2*t2^2+x3*t1*t2^2+x4+x5*t1*t2;
	Ann = ann(G);
	/* G の bfct は s + 1 */
	Ann0 = map(subst, Ann, s, -1);	
	/* 計算終わらず */
	Int = integration_ideal(Ann0, [t1,t2,x1,x2,x3,x4,x5],[dt1,dt2,dx1,dx2,dx3,dx4,dx5],[1,1,0,0,0,0,0]);
	return Int;
}

def test_integration_ideal5_()
{
	/* [SST, Ex5.6.4] */
	G = x1*t1^2*t2+x2*t1^2*t2^2+x3*t1*t2^2+x4+x5*t1*t2;
	Ann = ann(G);
	/* G の bfct は s + 1 */
	Ann0 = map(subst, Ann, s, -1);	
	Int = integration_ideal_(Ann0, [t1,t2,x1,x2,x3,x4,x5],[dt1,dt2,dx1,dx2,dx3,dx4,dx5],[1,1,0,0,0,0,0]);
	return Int;
}

/*----------------------------------------------------------------- */
/*-------------- test data for integration ideal ------------------ */
/*----------------------------------------------------------------- */

/*
#define DEBUG_FANO
*/

/* 2 次元 Fano 多面体で頂点の座標が 0,1,-1 のいづれかのもの + 原点 */
def fano2(I)
{
	Fano2 = [
		[[-1,0],[0,1],[1,-1],[0,0]],
		[[-1,0],[0,-1],[0,1],[1,0],[0,0]],
		[[-1,0],[-1,1],[0,1],[1,-1],[0,0]],
		[[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[0,0]],
		[[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[0,0]]];
	return Fano2[I];
}

/* 3 次元 Fano 多面体で頂点の座標が 0,1,-1 のいづれかのもの + 原点 */
def fano3(I)
{
	Fano3 = [
		[[-1,0,0],[0,0,1],[0,1,0],[1,-1,1],[0,0,0]],
		[[-1,0,0],[0,0,-1],[0,0,1],[0,1,1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,1,1],[0,0,1],[0,1,0],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[0,0,-1],[0,0,1],[0,1,-1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,0,1],[0,0,1],[0,1,0],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[0,-1,1],[0,0,-1],[0,0,1],[0,1,-1],[1,0,0],[0,0,0]],
		[[-1,0,0],[-1,1,0],[-1,1,1],[0,0,1],[0,1,1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[0,-1,1],[0,0,-1],[0,0,1],[0,1,0],[1,0,-1],[0,0,0]],
		[[-1,0,0],[-1,1,1],[0,0,-1],[0,0,1],[0,1,1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,0,-1],[-1,1,1],[0,0,1],[0,1,0],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,0,-1],[0,0,-1],[0,0,1],[0,1,-1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,1,1],[0,-1,-1],[0,0,1],[0,1,0],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,1,1],[0,-1,-1],[0,0,-1],[0,0,1],[0,1,1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,1,0],[-1,1,1],[0,-1,-1],[0,0,1],[0,1,1],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,0,1],[0,-1,1],[0,0,-1],[0,0,1],[0,1,0],[1,0,-1],[0,0,0]],
		[[-1,0,0],[-1,0,1],[-1,1,1],[0,-1,0],[0,0,1],[0,1,0],[1,-1,-1],[0,0,0]],
		[[-1,0,0],[-1,1,1],[1,-1,-1],[0,0,-1],[0,0,1],[0,1,1],[1,-1,-1],[1,0,0],[0,0,0]],
		[[-1,0,0],[-1,0,1],[-1,1,1],[0,-1,0],[0,0,1],[0,1,0],[1,-1,-1],[1,0,-1],[0,0,0]]];
	return Fano3[I];
}

/* L : 点データのリスト ex. fano2, fano3 の返り値 */
def p_to_mat(L)
{
	N = length(L);
	M = length(L[0]);
	A = newmat(M + 1, N);
	for (J = 0; J < N; J++)
		A[0][J] = 1;
	for (J = 0; J < N; J++) 
		for (I = 0; I < M; I++) 
			A[I + 1][J] = L[J][I];
	return A;
}

def test_p_to_mat()
{
	L = fano2(0);
	print(L);
	print(p_to_mat(L));

	L = fano3(10);
	print(L);
	print(p_to_mat(L));
}

/* fano polytope に付随する GKZ 系の行列 A を返す                 */
/* D : dimension (2 or 3), I : data index (0--4(D=2), 0--17(D=3)) */
def fano_polytope_a(D, I)
{
	if (D == 2) {
		L = fano2(I);
	} else if (D == 3) {
		L = fano3(I);
	} else {
		print("D is 2 or 3");
		return;
	}
	return p_to_mat(L);
}

def test_fano_polytope_a()
{
	print(fano_polytope_a(2, 0));
	print(fano_polytope_a(3, 11));
}

def fano_polytope(D, I)
{
	A = fano_polytope_a(D, I);
	P = a_to_poly(A);
	return append([A], P);
}

/* 
 * 行列 A から多項式を生成               
 * p_to_mat(fano*(I)) が A 
 * ex. A = [[1,1,1],[-1,0,1],[0,1,-1]]
 *     F = x1*t1^-1 + x2*t2 + x3*t1*t2^-1 
 *     t1*t2*F = x1*t2  x2*t1*t2^2 + x3*t1^2 <-- これを返す
 */ 
def a_to_poly(A)
{
	M = size(A)[0];
	N = size(A)[1];
	XV = var_list("x", 1, N);
	TV = var_list("t", 1, M-1);	
	S = 0;
	V = newvect(M - 1);
	for (J = 0; J < N; J++) {
		for (I = 0; I < M - 1; I++) {
			V[I] = A[I + 1][J];
			V[I]++;
		}
		DPE = dp_vtoe(V);	
		E = dp_dtop(DPE, TV);
		S += E * XV[J];
	}
	VL = append(TV, XV);
	DXV = map(d_var, XV);
	DTV = map(d_var, TV);
	DVL = append(DTV, DXV);
	return [S, VL, DVL];
}

def test_a_to_poly()
{
	A = newmat(3,3,[[1,1,1],[-1,0,1],[0,1,-1]]);
	print(A);
	print(a_to_poly(A));
	
	A = p_to_mat(fano3(10));
	print(A);
	print(a_to_poly(A));
}

def var_list(Str, From, To)
{
	L = [];
	for (I = From; I <= To; I++) 
		L = cons(strtov(Str + rtostr(I)), L);
	return reverse(L);
}

def test_var_list()
{
	print(var_list("a", 1, 11));
	print(var_list("tt", 0, 5));
}

/* 不定元 Var に "d" を追加した不定元を生成 */
def d_var(Var)
{
	return strtov("d" + rtostr(Var));
}

def int_fano(D, I)
{
	L = fano_polytope(D, I);
	F = L[1];
	VL = L[2];
	DVL = L[3];
	
	W = newvect(length(VL));
	for (I = 0; I < D; I++)
		W[I] = 1;
	W = vtol(W);

	print("F :", 2);
	print(F, 2);
tstart();
	Id = ann(F);
print("-- ann :", 2);
tstop();
	print("Ann F^s : ", 2);
	print(Id, 2);

#ifdef DEBUG_FANO
	/* b　関数の計算が重たいので skip */
tstart();
	BF = bfunction(F);
print("-- bfunction :", 2);
tstop();
	print("bfct : ");
	print(fctr(BF));
#endif
	Id0 = map(subst, Id, s, -1);
	print("Ann F^(-1) : ", 2);
	print(Id0, 2);
	J = integration_ideal(Id0, VL, DVL, W);
	return J;
}
endmodule$
end$
