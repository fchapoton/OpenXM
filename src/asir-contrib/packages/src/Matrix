/* $OpenXM: OpenXM/src/asir-contrib/packages/src/Matrix,v 1.6 2001/08/11 02:59:24 takayama Exp $ */

/*-------------------------------*/
/* Package for matrix operations */
/*-------------------------------*/

#define _DEBUG_Matrix_ 0

/*---------*/
/* Utility */
/*---------*/
def omatrix_clone(M) {
  if (type(L) == 5) {
    N = size(M)[0];
    A = newvect(N);
    for (I=0; I<N; I++) {
      A[I] = omatrix_clone(M[I]);
    }
    return A;
  }else if (type(L) == 6) {
    M = size(M)[0];
    N = size(M)[1];
    A = newmat(M,N);
    for (I=0; I<M; I++) {
      for (J=0; J<N; J++) {
        A[I][J] = omatrix_clone(M[I][J]);
      }
    }
    return A;
  }else{
    return(M);
  }
}
def omatrix_ltom(L) {
  if (type(L) != 4 && type(L) != 5 && type(L) !=6) {
    error("parameter type error.");
  }
  if (type(L) == 5 || type(L) == 6) return L;
  if (type(L[0]) != 4) return omatrix_ltov(L);
  return newmat(length(L), length(L[0]), L);
}

def omatrix_mtol(M) {
  if (type(M) == 5) { /* vector case */
    return vtol(M);
  }
  if (type(M) != 6) {
    error("parameter type error.");
  }
  Size = size(M);
  L = [];
  for (I = 0; I < Size[0]; I++) {
    Row = [];
    for (J = 0; J < Size[1]; J++) {
      Row = append(Row, [M[I][J]]);
    }
    L = append(L, [Row]);
  }
  return L;
}

def omatrix_ltov(L) {
  if (type(L) != 4) {
    error("parameter type error.");
  }
  return newvect(length(L), L);
}

/*-------------------*/
/* matrix operations */
/*-------------------*/
def omatrix_is_0(L) {
  if (type(L) == 5) {
    L = vtol(L);
  }
  if (type(L) != 4) {
    error("parameter type error.");
  }
  for (I = 0; I < length(L); I++) {
    if (L[I] != 0) {
      return 0;
    }
  }
  return 1;
}

def omatrix_1(N) {
  R = newmat(N, N);
  for (I = 0; I < N; I++) {
    R[I][I] = 1;
  }
  return R;
}

def omatrix_diag(L) {
  if (type(L) == 5) {
    L = vtol(L);
  }
  Size = length(L);

  R = newmat(Size, Size);
  for (I = 0; I < Size; I++) {
    R[I][I] = L[I];
  }
  return R;
}

def omatrix_mini(A, Row, Col) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  if (type(A) != 6) {
    error("parameter type is wrong.");
  }
  Size_A = size(A);
  if (Size_A[0] <= 1 || Size_A[1] <= 1) {
    error("a size of matrix A is too small.");
  }
  R = newmat(Size_A[0]-1, Size_A[1]-1);
  for (II = 0, I = 0; I < Size_A[0]; I++) {
    if (I != Row) {
      for (JJ = 0, J = 0; J < Size_A[1]; J++) {
	if (J != Col) {
	  R[II][JJ] = A[I][J];
	  JJ++;
	}
      }
      II++;
    }
  }
  return R;
}

def omatrix_det(A) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  if (type(A) != 6) {
    error("parameter type is wrong.");
  }
  Size_A = size(A);
  if (Size_A[0] != Size_A[1]) {
    error("A is not NxN.");
  }
  Size = Size_A[0];

  if (Size == 1) {
    return A[0][0];
  }
  else {
    Det = 0;
    for (I = 0; I < Size; I++) {
      Det += (-1)^I*A[0][I]*omatrix_det(omatrix_mini(A, 0, I));
    }
    return red(Det);
  }
}

def omatrix_cofactor(A, Row, Col) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  Size_A = size(A);
  if (Size_A[0] != Size_A[1]) {
    error("A is not NxN.");
  }
  Size = Size_A[0];

  if (Size == 1) {
    return 1;
  }
  else {
    return (-1)^(Row + Col)*omatrix_det(omatrix_mini(A, Row, Col));
  }
}

def omatrix_adjugate(A) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  Size_A = size(A);
  if (Size_A[0] != Size_A[1]) {
    error("A is not NxN.");
  }
  Size = Size_A[0];

  R = newmat(Size, Size);
  for (I = 0; I < Size; I++) {
    for (J = 0; J < Size; J++) {
      R[I][J] = omatrix_cofactor(A, J, I);
    }
  }
  return R;
}

def omatrix_inverse(A) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  Size_A = size(A);
  if (Size_A[0] != Size_A[1]) {
    error("A is not NxN.");
  }
  Size = Size_A[0];

  Det_A = omatrix_det(A);
  if (Det_A == 0) {
    error("Det(A) is zero.");
  }

  return omatrix_adjugate(A)/Det_A;
}

def omatrix_trans(A) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  Size_A = size(A);
  Size_row = Size_A[1];
  Size_col = Size_A[0];

  R = newmat(Size_row, Size_col);
  for (I = 0; I < Size_row; I++) {
    for (J = 0; J < Size_col; J++) {
      R[I][J] = A[J][I];
    }
  }
  return R;
}

/* Solve A*X=Y */
def omatrix_solve(A, X, Y) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }
  if (type(X) == 4) {
    X = omatrix_ltov(X);
  }
  if (type(Y) == 4) {
    Y = omatrix_ltov(Y);
  }

  Size_A = size(A);
  Size_X = size(X);
  Size_Y = size(Y);

  /* ord(reverse(vtol(X))); */

  Sol = newvect(Size_X[0]);
  for (I = 0; I < Size_X[0]; I++) {
    Sol[I] = [X[I], X[I]];
  }

  Z = A*X - Y;
  Size_Z = size(Z);
  F = [];
  for (I = 0; I < Size_Z[0]; I++) {
    if (Z[I] != 0) {
      F = append(F, [Z[I]]);
    }
  }
  
  if (F == []) {
    return vtol(Sol);
  }

  G = gr(F, reverse(vtol(X)), 2);
#if _DEBUG_Matrix_
  print("G = ", 0);print(G);
#endif

  if (G[0] == 1 || G[0] == -1) {
    return [];
  }

  for (I = 0; I < length(G); I++) {
    for (J = Size_X[0] - 1; J >= 0; J--) {
      Nm = nm(G[I]); Dn = dn(G[I]);
      if (coef(Nm, 1, X[J]) != 0) {
	Sol[J] = [X[J], X[J] - Nm/coef(Nm, 1, X[J])];
	break;
      }
    }
  }

  return vtol(Sol);
}

/* A basis of Ker(A) */
def omatrix_kernel(A) {
  if (type(A) == 4) {
    A = omatrix_ltom(A);
  }

  Size_A = size(A);

  X = newvect(Size_A[1]);
  for (I = 0; I < Size_A[1]; I++) {
    X[I] = uc();
  }
  /* ord(reverse(vtol(X))); */

  Z = A*X;
  Size_Z = size(Z);
  F = [];
  for (I = 0; I < Size_Z[0]; I++) {
    if (Z[I] != 0) {
      F = append(F, [Z[I]]);
    }
  }

  if (F == []) {
    E = omatrix_1(Size_A[1]);
    Basis = newvect(Size_A[1]);
    for (I = 0; I < Size_A[1]; I++) {
      Basis[I] = E[I];
    }
    return append(size(Basis), vtol(Basis));
  }

  G = gr(F, reverse(vtol(X)), 2);
#if _DEBUG_Matrix_
  print("G = ", 0);print(G);
#endif

  if (G[0] == 1 || G[0] == -1) {
    return [];
  }

  Sol = newvect(Size_A[1]);
  for (I = 0; I < Size_A[1]; I++) {
    Sol[I] = [X[I], X[I], 1];
  }

  for (I = 0; I < length(G); I++) {
    for (J = Size_A[1] - 1; J >= 0; J--) {
      Nm = nm(G[I]); Dn = dn(G[I]);
      if (coef(Nm, 1, X[J]) != 0) {
	Sol[J] = [X[J], coef(Nm, 1, X[J])/Dn*X[J] - G[I], coef(Nm, 1, X[J])/Dn];
	break;
      }
    }
  }
#if _DEBUG_Matrix_
  print("Sol = ",0);print(Sol);
#endif

  if (Size_A[1] - length(G) == 0) {
    return [0];
  }
  else {
    Dim = Size_A[1] - length(G);
    Basis = [];
    for (I = 0; I < Size_A[1]; I++) {
      E = [];
      for (J = 0; J < Size_A[1]; J++) {
	Sol_Nm = nm(Sol[J][1]); Sol_Dn = dn(Sol[J][1]);
	E = append(E, [red(coef(Sol_Nm,1,X[I])/Sol_Dn)/Sol[J][2]]);
      }
      if (!omatrix_is_0(E)) {
	Basis = append(Basis, [E]);
      }
    }
    if (Dim != length(Basis)) {
      error("algorithm error in omatrix_kernel().");
    }
    return append([Dim], [Basis]);
  }
}

def omatrix_eigenvalues(M) {
  if (type(M) == 4) {
    M = omatrix_ltom(M);
  }
  N = size(M)[0];
  L = newvect(N);
  for (I=0; I<N; I++) {
    L[I] = omatrix_v;
  }
  M2 = omatrix_diag(L);
  M2 = M-M2;
  L = omatrix_det(M2);
  return taka_base_solve_poly1(L,omatrix_v);
}



Loaded_Matrix = 1 $
end$
