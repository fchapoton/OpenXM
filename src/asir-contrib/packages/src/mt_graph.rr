import("glib3.rr")$
pari(allocatemem,10^8)$
extern Tb$
extern NN$
extern Fmax$
extern Xmin$
extern Ymin$
extern Xmax$
extern Ymax$
extern Trans$
extern LevelMax$
extern Slope$

extern MZvalues$  /* value table of functions */
extern Msize$     /* size of Mvmat */
extern MXtoI$     /* (X-Xmin)*MXtoI --> index I */
extern MYtoJ$     /* (Y-Ymin)*MYtoJ --> index J */
extern MXfromI$
extern MYfromJ$

LevelMax = -1$  /* -1, no recursion */ 
Slope = 0.1$

#define MTSIZE 10

def plot3dInitTable() {
  extern MZvalues$
  extern Msize$   
  extern MXtoI$   
  extern MYtoJ$   
  extern MXfromI$
  extern MYfromJ$

  extern LevelMax$
  extern NN$
  extern Xmax$
  extern Xmin$
  extern Ymax$
  extern Ymin$

  if (LevelMax >= 0) {
    Msize = (NN+2)*(2^(LevelMax+1));
    MM = 2^(LevelMax+1);
  }
  else {
    Msize = (NN+2);
    MM = 1;
  }
  MZvalues=newmat(Msize,Msize);
  MXtoI = eval(exp(0)*NN*MM/(Xmax-Xmin));
  MYtoJ = eval(exp(0)*NN*MM/(Ymax-Ymin));
  MXfromI = 1/MXtoI;
  MYfromJ = 1/MYtoJ;
}

def plot3d(F) {
  extern Tb;
  extern NN;
  extern Fmax;
  extern Trans;


  Tb=string_to_tb("")$
  D=getopt(domain);
  if (type(D) <0) {
    D=[[-MTSIZE,MTSIZE],[-MTSIZE,MTSIZE]];
  }
  Xmin=D[0][0]; Xmax=D[0][1];
  Ymin=D[1][0]; Ymax=D[1][1];
  printf("domain=%a: Xmin=%a,Xmax=%a, Ymin=%a, Ymax=%a\n",D,Xmin,Xmax,Ymin,Ymax);
  if ((Xmin >= Xmax) || (Ymin >=Ymax)) error("Invalid domain.");
  /* (MTSIZE*2/(Xmax-Xmin))*(x-Xmin)-MTSIZE =a*x-b */
  /* (MTSIZE*2/(Ymax-Ymin))*(y-Ymin)-MTSIZE =c*y-d */
  Trans=newmat(2,2);  /* [[a,b],[c,d]] */
  Trans[0][0] = eval(exp(0)*MTSIZE*2/(Xmax-Xmin));
  Trans[0][1] = eval(-Xmin*exp(0)*MTSIZE*2/(Xmax-Xmin)-MTSIZE);
  Trans[1][0] = eval(exp(0)*MTSIZE*2/(Ymax-Ymin));
  Trans[1][1] = eval(-Ymin*exp(0)*MTSIZE*2/(Ymax-Ymin)-MTSIZE);
  print(Trans);

  NN=getopt(mesh);
  if (type(NN) < 0) {
    NN=20;
  }
  printf("Mesh size is %a x %a. mesh=%a\n",NN,NN,NN);
  
  Xstep = eval(exp(0)*(Xmax-Xmin)/NN);
  Ystep = eval(exp(0)*(Ymax-Ymin)/NN);

  plot3dInitTable();

  /* Find the maximun of F */
  Fmax = ueval(F,Xmin,Ymin,-1,-1);  if (Fmax < 0) Fmax = -Fmax;
  Fmax_x = Xmin; Fmax_y = Ymin;
  for (X=Xmin; X<Xmax; X += Xstep) {
    for (Y=Ymin; Y<Ymax; Y += Ystep) {
      Z = ueval(F,X,Y,-1,-1);
      if (Z < 0)
        Z = -Z;
      if (Fmax < Z) {
        Fmax = Z;
        Fmax_x = X;
        Fmax_y = Y;
      }
    }
  }
  if (Fmax == 0.0) Fmax = 0.1;
  printf("Fmax is %a\n",Fmax);

  for (X=Xmin; X<Xmax; X += Xstep) {
    for (Y=Ymin; Y<Ymax; Y += Ystep) {
      adaptive_outxyz(F,X,Y,Xstep,Ystep,0,0);

    }
  }
  S=tb_to_string(Tb);
  output("tmp.txt")$
  printf("%a",S)$
  output()$
}

def adaptive_outxyz(F,X,Y,Xstep,Ystep,Xlevel,Ylevel) {
  extern LevelMax;
  extern Slope;
  extern Fmax;
  Xslope = (ueval(F,X,Y,-1,-1)-ueval(F,X+Xstep,Y,-1,-1))/Fmax; 
  if (Xslope < 0) Xslope = -Xslope;
  Yslope = (ueval(F,X,Y,-1,-1)-ueval(F,X,Y+Ystep,-1,-1))/Fmax; 
  if (Yslope < 0) Yslope = -Yslope;

  if ((Xlevel > LevelMax) || (Ylevel > LevelMax) || 
      ((Xslope < Slope) && (Yslope < Slope))) {
   Ystart=Y;
   for (I = 0; I < 2^Xlevel ; I++, X += Xstep) {
    for (J = 0, Y=Ystart; J < 2^Ylevel ; J++, Y += Ystep) {
      /* debug_mesh(X,Y,Xstep,Ystep); */
      write_to_tb("t ",Tb);      
      outxyz(F,X,Y); outxyz(F,X+Xstep,Y); outxyz(F,X,Y+Ystep);
      write_to_tb(" \n",Tb);
      write_to_tb("x ",Tb);
      outtexcoords(X,Y); outtexcoords(X+Xstep,Y); outtexcoords(X,Y+Ystep);
      write_to_tb(" \n",Tb);
      write_to_tb("t ",Tb);      
      outxyz(F,X,Y+Ystep); outxyz(F,X+Xstep,Y); outxyz(F,X+Xstep,Y+Ystep);
      write_to_tb(" \n",Tb);
      write_to_tb("x ",Tb);
      outtexcoords(X,Y+Ystep); outtexcoords(X+Xstep,Y); outtexcoords(X+Xstep,Y+Ystep);
      write_to_tb(" \n",Tb);
/*      Y += Ystep; */
    }

   }
  }else if ((Xslope >= Slope) && (Yslope >= Slope)) {
    adaptive_outxyz(F,X,Y,Xstep/2,Ystep/2,Xlevel+1,Ylevel+1);
  }else if ((Xslope < Slope) && (Yslope >= Slope)) {
    adaptive_outxyz(F,X,Y,Xstep,Ystep/2,Xlevel,Ylevel+1);
  }else if ((Xslope >= Slope) && (Yslope < Slope)) {
    adaptive_outxyz(F,X,Y,Xstep/2,Ystep,Xlevel+1,Ylevel);
  }else error("This case must not reached.");
}

def ueval(F,X,Y,I,J) {
  extern MZvalues$
  extern Msize$   
  extern MXtoI$   
  extern MYtoJ$   
  extern MXfromI$
  extern MYfromJ$

  extern Xmax$
  extern Xmin$
  extern Ymax$
  extern Ymin$

  /* Table lookup */
  if ((I >= 0) && (type(MZvalues[I][J]) != 0)) return MZvalues[I][J];

  if (I < 0) {
    I = pari(round,(X-Xmin)*MXtoI);
    J = pari(round,(Y-Ymin)*MYtoJ);
  } 
  if (type(MZvalues[I][J]) != 0) return MZvalues[I][J];

  if (type(F) == 17) { /* quote */
     Z = base_replace(F,[[x,X],[y,Y]]);
     Z = eval_quote(Z);
  }else{
     Z = subst(F,x,X,y,Y);
  }
  Z = eval(exp(0)*Z);
  MZvalues[I][J] = Z;
  return Z;
}
def outxyz(F,X,Y) {
  extern Tb;
  extern Trans;
  extern Xmin;
  extern Ymin;
  extern MXtoI;
  extern MYtoJ;
  extern MXfromI;
  extern MYfromJ;

  Z = ueval(F,X,Y,-1,-1);

  /* scaling */
  Z = Z*MTSIZE*0.8/Fmax;
  X = Trans[0][0]*X+Trans[0][1];
  Y = Trans[1][0]*Y+Trans[1][1];

  /* Truncate Z */
  if (Z > MTSIZE*2) Z = MTSIZE*2;
  if (Z < -MTSIZE*2) Z=-MTSIZE*2;

  /* Adjust numerical errors of X,Y */
  X = Xmin+pari(round,(X-Xmin)*MXtoI)*MXfromI;
  Y = Ymin+pari(round,(Y-Ymin)*MYtoJ)*MYfromJ;

  /* deval is used to avoid the expression like -8.1234 E-19 by Pari
  */
  S=sprintf(" %a %a %a ",deval(X),deval(Y),deval(Z));
  write_to_tb(S,Tb);
}

def outtexcoords(X,Y) {
  extern Tb$
  extern NN$
  extern Trans$
  extern Xmin$
  extern Ymin$
  extern Xmax$
  extern Ymax$ 
  N = NN/(Xmax-Xmin)*2;
  X = Trans[0][0]*X+Trans[0][1];
  Y = Trans[1][0]*Y+Trans[1][1];

  S = sprintf(" %a %a ",deval((X-Xmin)/(Xmax-Xmin)/N), deval((Y-Ymin)/(Ymax-Ymin)/N));
  write_to_tb(S,Tb);
}

def debug_mesh_init(X,Y) {
   glib_window(-X,-Y,X,Y);
   glib_clear();
}
/* Sample input. 
   test2();  
   LevelMax = 0;
   adaptive_outxyz(x,0.0, 0.0, 1.0, 1.0, 1,1);
*/
def debug_mesh(X,Y,Xstep,Ystep) {
   glib_line(X,Y,X+Xstep,Y);
   glib_line(X+Xstep,Y,X,Y+Ystep);
   glib_line(X,Y+Ystep,X,Y);

   glib_line(X,Y+Ystep,X+Xstep,Y);
   glib_line(X+Xstep,Y,X+Xstep,Y+Ystep);
   glib_line(X+Xstep,Y+Ystep,X,Y+Ystep);
   glib_flush();
} 

def test1() {
  shell("rm tmp.txt");
  plot3d((x^2+y^2)/30);
  shell("./graph tmp.txt &");
}

def test2() {
  /* debug_mesh_init(3,3); */
  shell("rm tmp.txt");
  plot3d(cos((x^2+y^2)^(1/2))+cos(3*(x^2+y^2)^(1/2)) | domain=[[-3,3],[-3,3]], mesh=30);
  shell("./graph tmp.txt &");
}

def test3() {
  shell("rm tmp.txt");
  plot3d(quote(sin(x)));
  shell("./graph tmp.txt &");
}
end$
