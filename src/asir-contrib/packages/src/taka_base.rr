/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_base.rr,v 1.21 2003/11/27 11:41:08 ohara Exp $ */
#include "tags.h"

def taka_base_rule_name(I) {
  return strtov("taka_base_v"+rtostr(I));
}

def taka_base_cancel(S) {
  if (type(S) == LIST || type(S) == MATRIX || type(S) == VECTOR) {
    return(map(taka_base_cancel,S));
  }
  if (type(S) == 3) {
    return red(S);
  }else{
    return S;
  }
}

def taka_base_flatten(S) {
/*  RemoveZero = getopt(remove_zero);
  if (type(RemoveZero) == -1) {
    RemoveZero = 0;
  }else{
    RemoveZero = 1;
  } Options should be passed to the subroutine. */
  Ans = [ ];
  if (type(S) == LIST) {
    N = length(S);
    for (I=0; I<N; I++) {
      T = taka_base_flatten(S[I]);
      Ans = append(Ans,T);
    }
    return Ans;
  }
  if (type(S) == VECTOR) {
    N = size(S)[0];
    for (I=0; I<N; I++) {
      T = taka_base_flatten(S[I]);
      Ans = append(Ans,T);
    }
    return Ans;
  }
  if (type(S) == MATRIX) {
    N = size(S)[0];
    M = size(S)[1];
    for (I=0; I<N; I++) {
      for (J=0; J<M; J++) {
        T = taka_base_flatten(S[I][J]);
        Ans = append(Ans,T);
      }
    }
    return Ans;
  }
  return [S];
}

def taka_base_replace(S,Rule) {
  if (type(Rule) == STRUCT) {  /* cf. datatype.rr  struct base_rule*/
    Rule = Rule->Rule;
  }
  N = length(Rule);
  for (I=0; I<N; I++) {
    S = taka_subst(S,Rule[I][0],taka_base_rule_name(I));
  }
  for (I=0; I<N; I++) {
    S = taka_subst(S,taka_base_rule_name(I),Rule[I][1]);
  }
  return S;
}

/*
def taka_subst(S,X,A) {
  if (type(S) == QUOTE) {
    if (type(A) != QUOTE) {
      A = quote_to_quote(A);
    }
  }else{
    return(subst(S,X,A));
  }
  return quote_replace(S,X,A);
}
*/
def taka_subst(S,X,A) {
  if (type(S) == QUOTE) {
    if (type(A) != QUOTE) {
      A = quote_to_quote(A);
    }
  }else{
    return(subst(S,X,A));
  }
  return subst_quote(S,X,A);
}

def taka_base_set_minus(A,B) {
  Ans = [ ];
  N = length(A);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(A[I],B)) {
      Ans = append(Ans,[A[I]]);
    }
  }
  return Ans;
}

def taka_base_set_union(A,B) {
  Ans = [ ];
  N = length(A);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(A[I],Ans)) {
      Ans = append(Ans,[A[I]]);
    }
  }
  N = length(B);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(B[I],Ans)) {
      Ans = append(Ans,[B[I]]);
    }
  }
  return vtol(qsort(newvect(length(Ans),Ans)));
}

def taka_base_memberq(A,S) {
  N = length(S);
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A == S[I]) return 1;
    }
  }
  return 0;
}

def taka_base_position(A,S) {
  N = length(S);
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A == S[I]) return I;
    }
  }
  return -1;
}

def taka_base_subsetq(A,B) {
  /* Better algorithm should be used in the final version. */
  N = length(A);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(A[I],B)) return 0;
  }
  return 1;
}

def taka_base_intersection(A,B) {
  /* Better algorithm should be used in the final version. */
  Ans = [ ];
  N = length(A);
  for (I=0; I<N; I++) {
    if (taka_base_memberq(A[I],B)) {
      Ans = append(Ans,[A[I]]);
    }
  }
  return Ans;
}

def taka_base_prune(A,S) {
  N = length(S);
  Ans = [ ];
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A != S[I])  {
        Ans = append(Ans,[S[I]]);
      }
    }else{
      Ans = append(Ans,[S[I]]);
    }
  }
  return Ans;
}

/*&usage
  Syntax: list base_permutation(list L) :   All permutations of L.
  Example: 
  [771] base_permutation([1,2,3]);
        [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
*/
def taka_base_permutation(L) {
  N = length(L);
  if (N <= 1) {
    return [L];
  }
  Ans = [ ];
  for (I = 0; I<N; I++) {
    C = base_set_minus(L,[L[I]]);
    V = taka_base_permutation(C);
    for (J=0; J<length(V); J++) {
      Ans = append(Ans,[cons(L[I],V[J])]);
    }
  }
  return(Ans);
}

/*&usage
  Syntax: list base_choose(list L,number M) : all subsets of L of size M.
  Example: 
  [841] taka_base_choose([1,2,3,4],2);
        [[4,3],[3,2],[4,2],[2,1],[3,1],[4,1]]
*/
def taka_base_choose(L,M) {
  N = length(L);
  if (length(L) == 0) return [ ];
  if (M < 1) return [ ];
  if (M == 1) {
    A = newvect(N);
    for (I=0; I<N; I++) {
      A[I] = [L[I]];
    }
    return vtol(A);
  }
  V1 = taka_base_choose(cdr(L),M);
  V2 = taka_base_choose(cdr(L),M-1);
  V2 = map(append,V2,[car(L)]);
  return append(V1,V2);
}

def taka_base_subsets_of_size(K,S) {
  if (length(S) < K) return [ ];
  if (K < 0) error("base_subsets_of_size: the size must be non-negative.");
  if (K == 0) return [ ];
  if (K == 1) {
    N = length(S);
    R = [];
    for (I=0; I<N; I++) {
       R = cons([S[I]],R);
    }
    return R;
  }else {
    N = length(S);
    R = []; P = [];
    for (I=0; I<N; I++) {
      P = cons(S[I],P);
      T = taka_base_set_minus(S,P);
      Ri = taka_base_subsets_of_size(K-1,T);
      M = length(Ri);
      for (J=0; J<M; J++) {
        R = cons( cons(S[I],Ri[J]), R);
      }
    }
    return R;
  }
}

def taka_base_real_part(T) {
  if (type(T) <= 1) {
    if (ntype(T) == 4) return real(T);
    else return T;
  }
  if (type(T) == 4 || type(T) == 5) {
    return map(taka_base_real_part,T);
  }  else  return T;
}
def taka_base_imaginary_part(T) {
  if (type(T) <= 1) {
    if (ntype(T) == 4) return imag(T);
    else return 0;
  }
  if (type(T) == 4 || type(T) == 5) {
    return map(taka_base_imaginary_part,T);
  }  else  return T;
}

def taka_base_is_integer(T) {
  if (type(T) == 0) return 1;
  if (type(T) == 1) {
   if (ntype(T) == 0) {
     if (dn(T) == 1) return 1;
   }
  }
  return 0;
}

Taka_base_loaded = 1$
end$


