/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_base.rr,v 1.1 2001/08/10 08:37:08 takayama Exp $ */
#define LIST 4
#define VECTOR 5
#define MATRIX 6
#define STRUCT 8

def taka_base_solve_poly1(F,V) {
  if (type(F) == 3) { /* Rational */
    G = dn(F); 
    if (deg(G,V) != 0) {
      return quote(root_of(F));
    }
  }
  Ans = [ ] ;
  G = nm(F);
  F = fctr(G);
  N = length(F);
  for (I=0; I<N; I++) {
    if (deg(F[I][0],V) == 0) {
    }else if (deg(F[I][0],V) == 1) {
       Sol = red( -coef(F[I][0],0,V)/coef(F[I][0],1,V) );
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }else {
       /* Sol = quote(root_of( F[I][0] )); */
       Sol = F[I][0];
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }
  }
  return Ans;
}

def taka_base_rule_name(I) {
  return strtov("taka_base_v"+rtostr(I));
}

def taka_base_replace(S,Rule) {
  if (type(S) == LIST) {
    return map(taka_base_replace,S,Rule);
  }
  if (type(S) == MATRIX || type(S) == VECTOR) {
    Sl = matrix_matrix_to_list(S);  print(S1);
    S1 = map(taka_base_replace,S1,Rule);  print(S1);
    return matrix_list_to_matrix(S1);
  }
  if (type(Rule) == STRUCT) {  /* cf. datatype.rr  struct base_rule*/
    Rule = Rule->Rule;
  }
  N = length(Rule);
  for (I=0; I<N; I++) {
    S = subst(S,Rule[I][0],taka_base_rule_name(I));
  }
  for (I=0; I<N; I++) {
    S = subst(S,taka_base_rule_name(I),Rule[I][1]);
  }
  return S;
}


Taka_base_loaded = 1$
end$


