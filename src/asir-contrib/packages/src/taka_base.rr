/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_base.rr,v 1.4 2001/08/15 04:20:04 takayama Exp $ */
#define LIST 4
#define VECTOR 5
#define MATRIX 6
#define STRUCT 8


def taka_base_rule_name(I) {
  return strtov("taka_base_v"+rtostr(I));
}

def taka_base_replace(S,Rule) {
  if (type(S) == LIST) {
    N = length(S);
    Ans = newvect(N);
    for (I=0; I<N; I++) {
      Ans[I] = taka_base_replace(S[I],Rule);
    }
    return vtol(Ans);
  }
  if (type(S) == MATRIX || type(S) == VECTOR) {
    S1 = matrix_clone(S);  
    
    if (type(S1) == VECTOR) {
       N = size(S1)[0];
       for (I=0; I<N; I++) {
         S1[I] = taka_base_replace(S1[I],Rule);
       }
       return(S1);
    }else if (type(S1) == MATRIX) {
       M = size(S1)[0]; N = size(S1)[1];
       for (I=0; I<M; I++) {
         for (J=0; J<N; J++) {
           S1[I][J] = taka_base_replace(S1[I][J],Rule);
         }
       }
       return(S1);
    }else {
       print(S1); error("internal error: matrix_clone is not working properly.");
    }
  }
  if (type(Rule) == STRUCT) {  /* cf. datatype.rr  struct base_rule*/
    Rule = Rule->Rule;
  }
  N = length(Rule);
  for (I=0; I<N; I++) {
    S = subst(S,Rule[I][0],taka_base_rule_name(I));
  }
  for (I=0; I<N; I++) {
    S = subst(S,taka_base_rule_name(I),Rule[I][1]);
  }
  return S;
}

def taka_base_set_minus(A,B) {
  Ans = [ ];
  N = length(A);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(A[I],B)) {
      Ans = append(Ans,[A[I]]);
    }
  }
  return Ans;
}

def taka_base_memberq(A,S) {
  N = length(S);
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A == S[I]) return 1;
    }
  }
  return 0;
}

Taka_base_loaded = 1$
end$


