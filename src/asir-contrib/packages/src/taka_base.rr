/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_base.rr,v 1.3 2001/08/14 13:13:45 takayama Exp $ */
#define LIST 4
#define VECTOR 5
#define MATRIX 6
#define STRUCT 8

def taka_base_solve_poly1(F,V) {
  if (type(F) == 3) { /* Rational */
    G = dn(F); 
    if (deg(G,V) != 0) {
      return quote(root_of(F));
    }
  }
  Ans = [ ] ;
  G = nm(F);
  F = fctr(G);
  N = length(F);
  for (I=0; I<N; I++) {
    if (deg(F[I][0],V) == 0) {
    }else if (deg(F[I][0],V) == 1) {
       Sol = red( -coef(F[I][0],0,V)/coef(F[I][0],1,V) );
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }else {
       /* Sol = quote(root_of( F[I][0] )); */
       Sol = F[I][0];
       for (J=0; J<F[I][1]; J++) {
         Ans = append(Ans,[ Sol ]);
       }
    }
  }
  return Ans;
}

def taka_base_rule_name(I) {
  return strtov("taka_base_v"+rtostr(I));
}

def taka_base_replace(S,Rule) {
  if (type(S) == LIST) {
    N = length(S);
    Ans = newvect(N);
    for (I=0; I<N; I++) {
      Ans[I] = taka_base_replace(S[I],Rule);
    }
    return vtol(Ans);
  }
  if (type(S) == MATRIX || type(S) == VECTOR) {
    S1 = matrix_clone(S);  
    
    if (type(S1) == VECTOR) {
       N = size(S1)[0];
       for (I=0; I<N; I++) {
         S1[I] = taka_base_replace(S1[I],Rule);
       }
       return(S1);
    }else if (type(S1) == MATRIX) {
       M = size(S1)[0]; N = size(S1)[1];
       for (I=0; I<M; I++) {
         for (J=0; J<N; J++) {
           S1[I][J] = taka_base_replace(S1[I][J],Rule);
         }
       }
       return(S1);
    }else {
       print(S1); error("internal error: matrix_clone is not working properly.");
    }
  }
  if (type(Rule) == STRUCT) {  /* cf. datatype.rr  struct base_rule*/
    Rule = Rule->Rule;
  }
  N = length(Rule);
  for (I=0; I<N; I++) {
    S = subst(S,Rule[I][0],taka_base_rule_name(I));
  }
  for (I=0; I<N; I++) {
    S = subst(S,taka_base_rule_name(I),Rule[I][1]);
  }
  return S;
}


Taka_base_loaded = 1$
end$


