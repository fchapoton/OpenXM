/* $OpenXM: OpenXM/src/asir-contrib/packages/src/taka_base.rr,v 1.11 2001/08/21 11:27:16 takayama Exp $ */
#include "tags.h"

def taka_base_rule_name(I) {
  return strtov("taka_base_v"+rtostr(I));
}

def taka_base_cancel(S) {
  if (type(S) == LIST || type(S) == MATRIX || type(S) == VECTOR) {
    return(map(taka_base_cancel,S));
  }
  if (type(S) == 3) {
    return red(S);
  }else{
    return S;
  }
}

def taka_base_flatten(S) {
/*  RemoveZero = getopt(remove_zero);
  if (type(RemoveZero) == -1) {
    RemoveZero = 0;
  }else{
    RemoveZero = 1;
  } Options should be passed to the subroutine. */
  Ans = [ ];
  if (type(S) == LIST) {
    N = length(S);
    for (I=0; I<N; I++) {
      T = taka_base_flatten(S[I]);
      Ans = append(Ans,T);
    }
    return Ans;
  }
  if (type(S) == VECTOR) {
    N = size(S)[0];
    for (I=0; I<N; I++) {
      T = taka_base_flatten(S[I]);
      Ans = append(Ans,T);
    }
    return Ans;
  }
  if (type(S) == MATRIX) {
    N = size(S)[0];
    M = size(S)[1];
    for (I=0; I<N; I++) {
      for (J=0; J<M; J++) {
        T = taka_base_flatten(S[I][J]);
        Ans = append(Ans,T);
      }
    }
    return Ans;
  }
  return [S];
}

def taka_base_replace(S,Rule) {
  if (type(S) == LIST || type(S) == MATRIX || type(S) == VECTOR) {
     return(map(taka_base_replace,S,Rule));
  }
  if (type(Rule) == STRUCT) {  /* cf. datatype.rr  struct base_rule*/
    Rule = Rule->Rule;
  }
  N = length(Rule);
  for (I=0; I<N; I++) {
    S = subst(S,Rule[I][0],taka_base_rule_name(I));
  }
  for (I=0; I<N; I++) {
    S = subst(S,taka_base_rule_name(I),Rule[I][1]);
  }
  return S;
}


def taka_base_set_minus(A,B) {
  Ans = [ ];
  N = length(A);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(A[I],B)) {
      Ans = append(Ans,[A[I]]);
    }
  }
  return Ans;
}

def taka_base_memberq(A,S) {
  N = length(S);
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A == S[I]) return 1;
    }
  }
  return 0;
}

def taka_base_position(A,S) {
  N = length(S);
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A == S[I]) return I;
    }
  }
  return -1;
}

def taka_base_subsetq(A,B) {
  /* Better algorithm should be used in the final version. */
  N = length(A);
  for (I=0; I<N; I++) {
    if (!taka_base_memberq(A[I],B)) return 0;
  }
  return 1;
}

def taka_base_intersection(A,B) {
  /* Better algorithm should be used in the final version. */
  Ans = [ ];
  N = length(A);
  for (I=0; I<N; I++) {
    if (taka_base_memberq(A[I],B)) {
      Ans = append(Ans,[A[I]]);
    }
  }
  return Ans;
}

def taka_base_prune(A,S) {
  N = length(S);
  Ans = [ ];
  for (I=0; I<N; I++) {
    if (type(A) == type(S[I])) {
      if (A != S[I])  {
        Ans = append(Ans,[S[I]]);
      }
    }else{
      Ans = append(Ans,[S[I]]);
    }
  }
  return Ans;
}

Taka_base_loaded = 1$
end$


