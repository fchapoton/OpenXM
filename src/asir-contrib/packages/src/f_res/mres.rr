/*	$Id$	*/

def mres( Equations, Vars )
{
	Rsc = getopt(rsc);
	Prim = getopt(p);
	Sub = getopt(sub);
	Rowidx = getopt( rowidx );
	Colidx = getopt( colidx );

	M = mresM( Equations, Vars | rsc=Rsc,p=Prim,sub=Sub,rowidx=Rowidx,colidx=Colidx );

	gauger.check();
	print("Determinant",0);print(size(M),0);print("...",2);
	if( indexof( "nd_det", flist() ) >= 0 ){
		R = nd_det( M );
	} else {
		R = det( M );
	}
	print("done");

	gauger.check();
	return R;
}

def mresM( Equations, Vars )
{
	Rsc = getopt(rsc);
	Prim = getopt(p);
	Sub = getopt(sub);
	Rowidx = getopt( rowidx );
	Colidx = getopt( colidx );

	gauger.check();
	print("Matrix construction...",2);
	P1 = map( dp_ptod, Equations, Vars );
	P2 = map( dp_homo, P1 );
	W = append( Vars, [uc()] );
	P3 = map( dp_dtop, P2, W );
	M = mhrM( P3, W );
	print("done");

	if( type(Rsc) != -1 && Rsc == 1 ){
		gauger.check();
		print("Rank Matrix Construction",0);print(size(M),0);print("...",2);
		Submatrix = submatrix( M | p=Prim,sub=Sub,rowidx=Rowidx,colidx=Colidx );
		print("done");
	} else {
		Submatrix = M;
	}

	return Submatrix;
}

def mhrM( Equations, Vars )
{
	N = length(Vars) - 1;

	Di = newvect(N+1);

	/*	Computing d = \sum_{i=0}^n d_i-n	*/
	for(I=0;I<=N;I++){
		Di[I] = dp_td( dp_ptod( Equations[I], Vars ) );
		D += Di[I];
	}
	D = D - N;

	Mono = dmono( D, N+1 );
	gauger.check();

	S = newvect( N+1 );
	for(I=0;I<=N;I++){
		S[I] = [];
	}

	Work = Mono;
	while( Work != [] ){
		for(I=0;I<=N;I++){
			T = car( Work );
			if( T[I] >= Di[I] ){
				S[I] = cons( T, S[I] );
				break;
			}
		}
		Work = cdr( Work );
	}

	L = length( Mono );
	M = newmat( L, L );

	for(I=K=0;I<=N;I++){
		T = S[I];
		while( T != [] ){
			DF = dp_ptod( Equations[I], Vars );
			A = ltov(car(T));
			A[I] = A[I] - Di[I];
			A = vtol( A );

			while( DF != 0 ){
				C = dp_hc( DF );
				V = vtol( dp_etov( DF ) );
				Idx = indexof( listadd( V, A ), Mono );
				M[K][Idx] = C;
				DF = dp_rest( DF );
			}
			T = cdr( T );
			K++;
		}
	}

	return M;
}

def dmono( D, N )
{
	/*	N : number of variable.
		D : total degree.
		return : all monomial of total degree D for N variable.
		dmono( 2, 2 ) returns [ [0,2], [1,1], [2,0] ] .
	*/

	if( N == 1 ){
		return [ [D] ];
	}

	R = [];
	for(I=0;I<=D;I++){
		Last = dmono( I, N-1 );

		while( Last != [] ){
			R = cons( cons( D-I, car(Last) ), R );
			Last = cdr( Last );
		}
	}

	return R;
}

def indexof( List, Lists )
{
	/*	Find the first "List" in "Lists", and return the index.
		if "List" is not found, return (-1).
	*/

	N = 0;
	while( Lists != [] ){
		if( List == car( Lists ) ){
			return N;
		}
		Lists = cdr( Lists );
		N++;
	}

	return (-1);
}

def listadd( A, B )
{
	/*	addtion of list like vector.
		listadd( [1,2,3], [2,2,2] ) returns [3,4,5] .
	*/
	A = ltov( A );
	B = ltov( B );

	return vtol( A+B );
}

end$
