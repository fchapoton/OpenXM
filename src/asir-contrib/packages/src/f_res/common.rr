/*	$Id$	*/

module gauger;
static Time;
Time = []$

localf check$
localf clear$
localf gettime$
localf diff$

def check()
{
	Time = cons( time(), Time );
}

def clear()
{
	Time = [];
}

def gettime()
{
	return Time;
}

def diff( A, B )
{
	return [ B[0]-A[0], B[1]-A[1], B[2]-A[2], B[3]-A[3] ];
}

endmodule;


def submatrix( Matrix )
{
	/*	This function returns full-rank submatrix of "Matrix".	*/

	MatRow = size( Matrix )[0];
	MatCol = size( Matrix )[1];

	RowIdx = getopt(rowidx);
	ColIdx = getopt(colidx);

	if( type(RowIdx) != 5 || length(RowIdx) != MatRow ){
		RowIdx = newvect( MatRow );
		for(I=0;I<MatRow;I++){
			RowIdx[I] = I;
		}
	}
	if( type(ColIdx) != 5 || length(ColIdx) != MatCol ){
		ColIdx = newvect( MatCol );
		for(I=0;I<MatCol;I++){
			ColIdx[I] = I;
		}
	}

	M = newmat( MatRow, MatCol );
	for(I=0;I<MatRow;I++){
		for(J=0;J<MatCol;J++){
			M[I][J] = Matrix[ RowIdx[I] ][ ColIdx[J] ];
		}
	}

	Prim = getopt(p);
	Sub = getopt(sub);

	CVar = vars( M );

	if( type(Prim) != 1 ){
		Prim = 65535;
	}

	if( type(Sub) != 4 ){
		Sub = [];
		for(I=0;I<length(CVar);I++){
			Sub = cons( prime(15+2*I) % Prim , Sub );
		}
	}

	while( CVar != [] ){
		M = subst( M, car(CVar), car(Sub) );
		CVar = cdr( CVar );
		Sub = cdr( Sub );
	}


	/*	Initialize for Fraction-Free Gaussian Elimination	*/
	InvDivisor = 1;

	/*	Fraction-Free Gaussian Elimination	*/
	/*	Eliminate below row R, with pivot in column K.	*/
	for(K=R=0;K<MatCol&&R<MatRow;K++,R++){

		/*	Find a nonzero pivot.	*/
		for(P=R;P<MatRow;P++){
			if( M[P][K] != 0 ){
				break;
			}
		}
		if( P == MatRow ){
			if( R == MatRow-1 ){
				MatCol--;
				break;
			}

			/*	swith columns K and MatCol-1	*/
			for(I=R;I<MatRow;I++){
				Tmp = M[I][MatCol-1];
				M[I][MatCol-1] = M[I][K];
				M[I][K] = Tmp;
			}
			ColIdx[K] = ColIdx[MatCol-1];
			MatCol--;			

			/*	do again	*/
			R--;
			K--;
			continue;
		}

		/*	Pivot is in row P, so swith rows P and R.	*/
		if( P != R ){
			for(J=K;J<MatCol;J++){
				Tmp = M[P][J];
				M[P][J] = M[R][J];
				M[R][J] = Tmp;
			}
			Tmp = RowIdx[P];
			RowIdx[P] = RowIdx[R];
			RowIdx[R] = Tmp;
		}

		for(I=R+1;I<MatRow;I++){
			for(J=K+1;J<MatCol;J++){
				M[I][J] = ( ( M[R][K]*M[I][J] - M[R][J]*M[I][K] ) * InvDivisor ) % Prim;
			}
			M[I][K] = 0;
		}

		Divisor = M[R][K];
		InvDivisor = inv( Divisor, Prim );
	}

	Submatrix = newmat( R, R );
	for(I=0;I<R;I++){
		for(J=0;J<R;J++){
			Submatrix[I][J] = Matrix[ RowIdx[I] ][ ColIdx[J] ];
		}
	}

	return Submatrix;
}

def indexof( List, Lists )
{
	/*	Find the first "List" in "Lists", and return the index.
		if "List" is not found, return (-1).
	*/

	N = 0;
	while( Lists != [] ){
		if( List == car( Lists ) ){
			return N;
		}
		Lists = cdr( Lists );
		N++;
	}

	return (-1);
}

def listadd( A, B )
{
	/*	addtion of list like vector.
		listadd( [1,2,3], [2,2,2] ) returns [3,4,5] .
	*/
	A = ltov( A );
	B = ltov( B );

	return vtol( A+B );
}

end$
