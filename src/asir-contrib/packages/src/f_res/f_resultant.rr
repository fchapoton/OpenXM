/*	$Id$	*/

module resultant$

localf dres$
localf dixonpolynomial$
localf matrixdecomp$
localf submatrix$
localf indexof$


def dres( Equations, Vars )
{
	Prim = getopt(p);
	Sub = getopt(sub);
	Norsc = getopt(norsc);
	Rowidx = getopt(rowidx);
	Colidx = getopt(colidx);

	print("Dixon polynomial...",2);
	Tmp = dixonpolynomial( Equations, Vars );
	print("done");

	Dpoly = Tmp[0];
	UC = Tmp[1];

	print("Matrix decomposition...",2);
	Matrix =  matrixdecomp( Dpoly, UC, Vars );
	print("done");

	if( Norsc != 1 ){
		print("Rank Submatrix Construction",0);print(size(Matrix[1]),0);print("...",2);
		Submatrix = submatrix( Matrix[1] |p=Prim,sub=Sub,rowidx=Rowidx,colidx=Colidx );
		print("done");
	} else {
		Submatrix = Matrix[1];
	}

	print("Determinant",0);print(size(Submatrix),0);print("...",2);
	R = nd_det( Submatrix );

	print("done");

	return R;
}

def dixonpolynomial( Equations, Vars )
{
	/*	This function returns dixonpolynomial and new variable:
		It returns [ Dixonpolynomial, vector of new variable ].
	*/

	N = length( Vars );

	if( length( Equations ) != N+1 ){
		print("dixonpolynomial : length of Vars is not correct");
		return;
	}

	UC = newvect( N );
	for(I=0;I<N;I++){
		UC[I] = uc();
	}

	M = newmat( N+1, N+1 );

	for(J=0;J<=N;J++){
		M[0][J] = Equations[J];
	}

	for(I=1;I<=N;I++){
		Equations = subst( Equations, Vars[I-1], UC[I-1] ); 
		for(J=0;J<=N;J++){
			M[I][J] = Equations[J];
		}
	}

	Dpoly = nd_det( M );

	for(I=0;I<N;I++){
		Dpoly = sdiv( Dpoly, ( Vars[I] - UC[I] ) );
	}

	return [ Dpoly, UC ];
}

def matrixdecomp( Dpoly, UC_, Vars )
{
	/*	This function decomposes Dixonpolynomial to WDV. where,
		V is column vector of all monomials in "Vars" which appear in "Dpoly".
		V is row vector of all monomials in "UC" which appear in "Dpoly".
		remark : "Dpoly" is polynomial, "UC" is vector and "Vars" is list.
	*/

	UC = vtol(UC_);
	Dpoly2 = dp_ptod( Dpoly, UC );

	RowList = RowVect = [];
	while( Dpoly2 != 0 ){
		RowList = cons( dp_hc( Dpoly2 ), RowList );
		RowVect = cons( dp_etov( Dpoly2 ), RowVect );
		Dpoly2 = dp_rest( Dpoly2 );
	}
	MaxRow = length( RowList );

	M = newvect( MaxRow );

	ColVect = [];
	for(I=0;I<MaxRow;I++){
		ThisRow = [];
		Obj = dp_ptod( RowList[I], Vars );
		while( Obj != 0 ){
			HT = dp_etov( Obj );
			T = indexof( HT, ColVect );
			if( T == (-1) ){
				T = length( ColVect );
				ColVect = append( ColVect, [ HT ] );
			}
			ThisRow = cons( [ T, dp_hc( Obj ) ], ThisRow );
			Obj = dp_rest( Obj );
		}
		M[I] = newvect( length( ColVect ) );
		while( ThisRow != [] ){
			Tmp = car( ThisRow );
			M[I][ Tmp[0] ] = Tmp[1];
			ThisRow = cdr( ThisRow );
		}
	}
	MaxCol = length( ColVect );

	Matrix = newmat( MaxRow, MaxCol );
	for(I=0;I<MaxRow;I++){
		JM = length( M[I] );
		for(J=0;J<JM;J++){
			Matrix[I][J] = M[I][J];
		}
	}

	V = newvect( MaxRow );
	for(I=0;I<MaxRow;I++){
		V[I] = dp_dtop( dp_vtoe( RowVect[I] ), UC );
	}

	W = newvect( MaxCol );
	for(I=0;I<MaxCol;I++){
		W[I] = dp_dtop( dp_vtoe( ColVect[I] ), Vars );
	}

	return [ V, Matrix, W ];
}

def submatrix( Matrix )
{
	/*	This function returns full-rank submatrix of "Matrix".	*/

	MatRow = size( Matrix )[0];
	MatCol = size( Matrix )[1];

	RowIdx = getopt(rowidx);
	ColIdx = getopt(colidx);

	if( type(RowIdx) != 5 || length(RowIdx) != MatRow ){
		RowIdx = newvect( MatRow );
		for(I=0;I<MatRow;I++){
			RowIdx[I] = I;
		}
	}
	if( type(ColIdx) != 5 || length(ColIdx) != MatCol ){
		ColIdx = newvect( MatCol );
		for(I=0;I<MatCol;I++){
			ColIdx[I] = I;
		}
	}

	M = newmat( MatRow, MatCol );
	for(I=0;I<MatRow;I++){
		for(J=0;J<MatCol;J++){
			M[I][J] = Matrix[ RowIdx[I] ][ ColIdx[J] ];
		}
	}

	Prim = getopt(p);
	Sub = getopt(sub);

	CVar = vars( M );

	if( type(Prim) != 1 ){
		Prim = 65535;
	}

	if( type(Sub) != 4 ){
		Sub = [];
		for(I=0;I<length(CVar);I++){
			Sub = cons( prime(15+2*I) % Prim , Sub );
		}
	}

	while( CVar != [] ){
		M = subst( M, car(CVar), car(Sub) );
		CVar = cdr( CVar );
		Sub = cdr( Sub );
	}


	/*	Initialize for Fraction-Free Gaussian Elimination	*/
	InvDivisor = 1;

	/*	Fraction-Free Gaussian Elimination	*/
	/*	Eliminate below row R, with pivot in column K.	*/
	for(K=R=0;K<MatCol&&R<MatRow;K++,R++){

		/*	Find a nonzero pivot.	*/
		for(P=R;P<MatRow;P++){
			if( M[P][K] != 0 ){
				break;
			}
		}
		if( P == MatRow ){
			if( R == MatRow-1 ){
				MatCol--;
				break;
			}

			/*	swith columns K and MatCol-1	*/
			for(I=R;I<MatRow;I++){
				Tmp = M[I][MatCol-1];
				M[I][MatCol-1] = M[I][K];
				M[I][K] = Tmp;
			}
			ColIdx[K] = ColIdx[MatCol-1];
			MatCol--;			

			/*	do again	*/
			R--;
			K--;
			continue;
		}

		/*	Pivot is in row P, so swith rows P and R.	*/
		if( P != R ){
			for(J=K;J<MatCol;J++){
				Tmp = M[P][J];
				M[P][J] = M[R][J];
				M[R][J] = Tmp;
			}
			Tmp = RowIdx[P];
			RowIdx[P] = RowIdx[R];
			RowIdx[R] = Tmp;
		}

		for(I=R+1;I<MatRow;I++){
			for(J=K+1;J<MatCol;J++){
				M[I][J] = ( ( M[R][K]*M[I][J] - M[R][J]*M[I][K] ) * InvDivisor ) % Prim;
			}
			M[I][K] = 0;
		}

		Divisor = M[R][K];
		InvDivisor = inv( Divisor, Prim );
	}

	Submatrix = newmat( R, R );
	for(I=0;I<R;I++){
		for(J=0;J<R;J++){
			Submatrix[I][J] = Matrix[ RowIdx[I] ][ ColIdx[J] ];
		}
	}

	return Submatrix;
}

def indexof( List, Lists )
{
	/*	Find the first "List" in "Lists", and return the index.
		if "List" is not found, return (-1).
	*/

	N = 0;
	while( Lists != [] ){
		if( List == car( Lists ) ){
			return N;
		}
		Lists = cdr( Lists );
		N++;
	}

	return (-1);
}


endmodule$

end$
