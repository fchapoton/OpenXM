/* $OpenXM: OpenXM/src/asir-contrib/packages/src/names.rr,v 1.107 2011/04/27 06:48:58 takayama Exp $ */
/* $Revision$ */
#define NOT_YET   print("It has not yet been implemented.")
load("oxrfc100.rr")$

def asir_contrib_copyright() {
  S=
  "OpenXM/Risa/Asir-Contrib $Revision$ (20110416), Copyright 2000-2011, OpenXM.org committers\n"+
  "helph(); [html help], ox_help(0); ox_help("+asciitostr([34])+"keyword"+asciitostr([34])+
 "); ox_grep("+asciitostr([34])+"keyword"+asciitostr([34])+");\n"+
  "     for help messages (unix version only).\n";
  return S;
}

def asir_contrib_document_url() {
  return "http://www.math.kobe-u.ac.jp/OpenXM/Current/doc/index-doc.html";
}
 
if (!ctrl("quiet_mode")) {
  print(asir_contrib_copyright(),0)$
  print(asir_contrib_document_url())$
}else{ }$


/* Include data type declaration. */
load("datatype.rr")$
#include "tags.h"
/* Include a standard library. It should be included
   in a different place in a future. */
load("sm1.rr")$
load("gnuplot.rr")$
load("tigers.rr")$
load("phc.rr")$
load("quote.rr")$  
load("misc.rr")$ 
load("tex_symbols.rr")$
load("xml_basic_symbols.rr")$
load("taka_print_cmo100.rr")$
load("taka_util.rr")$
load("taka_pfp.rr")$
load("taka_weyl.rr")$
load("plucker.rr")$
load("oxshell.rr")$
load("taka_ahg.rr")$
load("mt_graph.rr")$
load("oh_number.rr")$
import("nn_ndbf.rr")$

/* should use load_exec() for demand loading. */
def ox_loadfile(Tag,FileName) {
/*  if (!Tag) Result=load(FileName); else return(1); */
  if (!Tag) Result=load_exec(FileName); else return(1);
  if (Result == 0) error("File "+FileName+" was not found.");
  return(1);
}
#define ox_loadfile_(A,B) load(B)
ox_loadfile_(Loaded_taka_base,"taka_base.rr")$
ox_loadfile_(Loaded_noro_print,"noro_print.rr")$
ox_loadfile_(Loaded_noro_print_default,"noro_print_default.rr")$
ox_loadfile_(Loaded_om,"om.rr")$
ox_loadfile_(Loaded_ok_matrix,"ok_matrix.rr")$
ox_loadfile_(Loaded_taka_base,"taka_base.rr")$
ox_loadfile_(Loaded_taka_poly,"taka_poly.rr")$
ox_loadfile_(Loaded_glib,"glib")$
/* This file and logname give a list of canonical names of functions.
   Names are classified in categories such as number, matrix, and so on.
   If you implement one of the functions listed below, 
   please call your functions from here.
   Example:
     if your number_chop is implemented by the name
          hoge_chop,
     you should write here as
     def number_chop(Exp,Dx) {  return(hoge_chop(Exp,Dx)); }
*/

#define OX_LOADFILE(A,B)   /* Do nothing. */


Print_tex_form_fraction_format="auto"$  /* "frac" or "auto" or "/" */
Print_tex_form_no_automatic_subscript=0$ /* 0 or 1 */

/* Base module */
/*&usage begin: base_cancel(S)
 It simplifies {S} by canceling the common factors of 
 denominators and numerators.
 example: base_cancel([(x-1)/(x^2-1), (x-1)/(x^3-1)]); 
end: */
def base_cancel(S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_cancel(S);
}
/*&usage begin: base_choose(L,M)
 It returns the list of the order {M} subsets of L.
 example: base_choose([1,2,3],2);
 example_description:
@tex
It outputs all the order $2$ subsets of the set $\{ 1, 2, 3\}$
@end tex
end: */
def base_choose(L,M) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_choose(L,M);
}
/*&usage begin: base_flatten(S)
 It flattens a nested list {S}.
 example: base_flatten([[1,2,3],4]);
end: */
def base_flatten(S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_flatten(S);
}
/*&usage begin: base_intersection(A,B)
 It returns the intersection of {A} and {B} as a set.
 example: base_intersection([1,2,3],[2,3,5,[6,5]]);
end: */
def base_intersection(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_intersection(A,B);
}

/*&usage begin: base_makelist(Obj,K,B,T)
 base_makelist generate a list from Obj where K runs in [B,T].
 example: base_makelist(k^2,k,1,10);
 example: map(print_input_form,base_makelist(quote(x^2),x,1,10 | qt=1, step=0.5))
 Options: qt=1 (keep quote data), step (step size)
end: */
def base_makelist(Obj,K,B,T) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_makelist(Obj,K,B,T | option_list=getopt());
}

/*&usage begin: base_memberq(A,S)
 It returns 1 if {A} is a member of the set {S} else returns 0.
 example: base_memberq(2,[1,2,3]);
end: */
def base_memberq(A,S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_memberq(A,S);
}
/*&usage begin: base_permutation(L)
 It outputs all permutations of {L}.  BUG; it uses a slow algorithm.
 example: base_permutation([1,2,3,4]);
end: */
def base_permutation(L) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_permutation(L);
}
/*&usage begin: base_position(A,S)
 It returns the position of {A} in {S}.
 example: base_position("cat",["dog","cat","monkey"]);
end: */
def base_position(A,S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_position(A,S);
}

/*&usage begin: base_product(Obj,K,B,T)
 base_product returns the product of Obj where K runs in [B,T].
 example: base_product(k^2,k,1,10);
 example: base_product(quote(x^2),x,1,10 | qt=1, step=0.5);
 Options: qt=1 (keep quote data), step (step size)
end: */
def base_product(Obj,K,B,T) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_product(Obj,K,B,T | option_list=getopt());
}

/*&usage begin: base_prune(A,S)
 It returns a list in which {A} is removed from {S}.
 example: base_prune("cat",["dog","cat","monkey"]);
end: */
def base_prune(A,S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_prune(A,S);
}
/*&usage begin: base_replace(S,Rule)
 It rewrites {S} by using the rule {Rule}
 example: base_replace(x^2+y^2,[[x,a+1],[y,b]]);
 example_description: x is replaced by a+1 and y is replaced by b in
 x^2+y^2.
end: */
def base_replace(S,Rule) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_replace(S,Rule);
}
/*&usage begin: base_replace_n(S,Rule)
 It rewrites {S} by using the rule {Rule}.
 It is used only for specializing variables to numbers and faster than base_replace.
 example: base_replace_n(x^2+y^2,[[x,1/2],[y,2.0+3*@i]]);
 example_description: x is replaced by 1/2 and y is replaced by 2.0+3*@i in
 x^2+y^2.
end: */
def base_replace_n(S,Rule) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_replace_n(S,Rule);
}
/*&usage begin: base_set_minus(A,B)
@tex
$A \setminus B$
@end tex
 example: base_set_minus([1,2,3],[3,4,5]);
end: */
def base_set_minus(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_set_minus(A,B);
}
/*&usage begin: base_set_union(A,B)
@tex
$A \cup B$
@end tex
 example: base_set_union([1,2,3],[3,4,5]);
end: */
def base_set_union(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_set_union(A,B);
}
/*&usage begin: base_subsetq(A,B)
@tex
if $A \subseteq B$, then it returns 1 else 0.
@end tex
 example: base_subsetq([1,2],[1,2,3,4,5]);
end: */
def base_subsetq(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_subsetq(A,B);
}
/*&usage begin: base_subsets_of_size(K,S)
 It outputs all subsets of {S} of the size {K}.
 BUG; it uses a slow algorithm. Do not input a large {S}.
 example: base_subsets_of_size(2,[3,5,3,2]);
end: */
def base_subsets_of_size(K,S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_subsets_of_size(K,S);
}


/*&usage begin: base_sum(Obj,K,B,T)
 base_sum returns the sum of Obj where K runs in [B,T].
 example: base_sum(k^2,k,1,10);
 example: base_sum(quote(x^2),x,1,10 | qt=1, step=0.5);
 Options: qt=1 (keep quote data), step (step size)
end: */
def base_sum(Obj,K,B,T) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_sum(Obj,K,B,T | option_list=getopt());
}

/*&usage begin: base_var_list(Name,B,T)
 base_var_list generate a list of variables Name+Index where Index runs on [B,T].
 example: base_var_list(x,0,10);
 example: base_var_list(x,1,4 | d = 1);
 Options: d=1 (add d before the name).
end: */
def base_var_list(Name,B,T) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_var_list(Name,B,T | option_list=getopt());
}

/* Canonical function names for numbers. cf. Mathematica/Numbers */
/*&usage begin: number_abs(X) example: number_abs(-3); end: */
def number_abs(X)  { return(pari(abs,X)); }
def number_base_form(X,B) { NOT_YET; }
def number_binomial(P,Q) { NOT_YET; }
/*&usage begin: number_ceiling(X) example: number_abs(1.5); end: */
def number_ceiling(X) { return(pari(ceil,X)); }
def number_chop(Exp,Dx) {  NOT_YET; }
/*&usage begin: number_factor(X)  It factors the given integer {X}.
  example: number_factor(20); end: */
def number_factor(X) { return(pari(factorint,X)); }
/*&usage begin: number_float_to_rational(X) 
    example: number_float_to_rational(1.5234); 
             number_float_to_rational(1.5234 | prec=14); 
end: */
def number_float_to_rational(X) { 
  return oh_number.rats(X | option_list=getopt());
}
/*&usage begin: number_floor(X) example: number_floor(1.5); end: */
def number_floor(X) { return(pari(floor,X)); }
/*&usage begin: number_imaginary_part(X) example: number_imaginary_part(1+2*@@i); end: */
def number_imaginary_part(X) { return(taka_base_imaginary_part(X)); }
/*&usage begin: number_is_integer(X) example: number_is_integer(2/3); end: */
def number_is_integer(X) { return(taka_base_is_integer(X)); }
def number_max(X)  { NOT_YET; }
def number_min(X)  { NOT_YET; }
def number_n(Exp)  { NOT_YET; }  /* N [ ], numerical evaluator. */
def number_round(X) { NOT_YET; }
/*&usage begin: number_real_part(X) example: number_real_part(1+2*@@i); end: */
def number_real_part(X) { return(taka_base_real_part(X)); }
def number_sign(X) { NOT_YET; }

/* See longname for basic_ and poly_. Here are some added functions */
/*&usage begin: poly_factor(F)
 It factorizes the polynomial {F}.
 example: poly_factor(x^10-y^10);
end: */
def poly_factor(A) { return(taka_poly_factor(A)); }
/*&usage begin: poly_gcd(F,G)
 It computes the polynomial GCD of {F} and {G}.
 example: poly_gcd(x^10-y^10,x^25-y^25);
end: */
def poly_gcd(A,B)  { return(gcd(A,B)); }

/*&usage begin: poly_elimination_ideal(I,VV|grobner_basis,v,homo,grace,strategy)
 It computes the intersection of the ideal {I} and the subring K[{VV}].
 description:
 If grobner_basis is "yes", I is assumed to be a Grobner basis.
 The optional variable v is a list of variables which defines the ring 
 of polynomials.
 example: poly_elimination_ideal([x^2+y^2-4,x*y-1],[x]);
 example: A = poly_grobner_basis([x^2+y^2-4,x*y-1]|order=2,v=[y,x]);
          poly_elimination_ideal(A,[x]|grobner_basis="yes");
 When strategy=1(default), 
   nd_gr is used when trace=0(defauult),
   nd_gr_trace is used when trace=1.
 ref: gr, hgr, gr_mod, dp_*
end: */
def poly_elimination_ideal(I,VV) { 
  O = getopt(grobner_basis);
  V = getopt(v);
  OL = [["grobner_basis",O],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_elimination_ideal(I,VV|option_list=OL);
}

/*&usage begin: poly_expand(F)
  This is an alias of poly_sort.
  ref: poly_sort
end: */
def poly_expand(F) {
  Opt = getopt();
  return poly_sort(F | option_list=Opt);
}

/*&usage begin: poly_grobner_basis(I|order,v)
 It returns the Grobner basis of {I}.
 description:
 The optional variable v is a list of variables which defines the ring 
 of polynomials.
 example: A = poly_grobner_basis([x^2+y^2-4,x*y-1]|order=2,v=[y,x]);
end: */
def poly_grobner_basis(I) {
  Or = getopt(order);
  V = getopt(v);
  OL = [["order",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_grobner_basis(I|option_list=OL);
}
/*&usage begin: poly_hilbert_polynomial(I|s,v)
 It returns the Hilbert polynomial of the ideal I.
 description:
 The optional variable v is a list of variables.
 example: poly_hilbert_polynomial([x1*y1,x1*y2,x2*y1,x2*y2]|s=k,v=[x1,x2,y1,y2]);
end: */
def poly_hilbert_polynomial(I)  { 
  /* return(subst(hilbert_polynomial(I,V),h,S));  */
  S = getopt(s);
  V = getopt(v);
  OL = [["s",S],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_hilbert_polynomial(I|option_list=OL);
}

/*&usage begin: poly_initial(I|order,v)
 It returns the initial ideal of {I} with respect to the given order.
 description:
 The optional variable v is a list of variables. This function computes 
@tex
${\rm in}_\prec (I)$
@end tex
 example: poly_initial([x^2+y^2-4,x*y-1]|order=0,v=[x,y]);
end: */
def poly_initial(I) {
  Or = getopt(order);
  V = getopt(v);
  OL = [["order",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_initial(I|option_list=OL);
}

/*&usage begin: poly_initial_coefficients(I|order,v)
 It computes the coefficients of the initial ideal of {I} with respect to the given order.
 description:
 The optional variable v is a list of variables. The order is specified by the
 optional variable order
 example: poly_initial_coefficients([x^2+y^2-4,x*y-1]|order=0,v=[x,y]);
end: */
def poly_initial_coefficients(I) {
  Or = getopt(order);
  V = getopt(v);
  OL = [["order",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_initial_coefficients(I | option_list=OL);
}

/*&usage begin: poly_initial_term(F|weight,order,v)
 It returns the initial term of a polynomial {F} 
 with respect to the given weight vector.
 description:
 The weight is given by the optional variable weight w.
 It returns
@tex
${\rm in}_w (F)$
@end tex
 example: poly_initial_term( x^2+y^2-4 |weight=[100,1],v=[x,y]);
end: */
def poly_initial_term(F) {
  Or = getopt(order);
  V = getopt(v);
  Weight = getopt(weight);
  OL = [["order",Or],["v",V],["weight",Weight]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_initial_term(F | option_list=OL);
}

/*&usage begin: poly_degree(F|weight,v)
 It returns the degree of {F} with respect to the given weight vector.
 description:
 The weight is given by the optional variable weight w.
 It returns
@tex
${\rm ord}_w (F)$
@end tex
 example: poly_degree(x^2+y^2-4 |weight=[100,1],v=[x,y]);
end: */
def poly_degree(I) {
  Or = getopt(weight);
  V = getopt(v);
  OL = [["weight",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_degree(I | option_list=OL);
}

def poly_solve(Eqs,V) { NOT_YET; }

/*&usage begin: poly_solve_linear(Eqs,V)
 It solves the system of linear equations {Eqs} with respect to the set of
 variables {V}.
 example: poly_solve_linear([2*x+3*y-z-2, x+y+z-1], [x,y,z]);
end: */
def poly_solve_linear(Eqs,V) { 
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_solve_linear(Eqs,V);
}

/*&usage begin: poly_sort(F|v,w,truncate)
 It expands {F} with a given variables {v}=V and a given weight {w}=W.
 It returns a quote object.
 If {trucate} option is set, the expansion is truncated at the given degree.
 example: poly_sort((x-y-a)^3 | v=[x,y], w=[-1,-1])  
    returns a series expansion in terms of x and y.
end: */
def poly_sort(F) {
  Opt = getopt();
  return taka_quote_sort(F | option_list=Opt);
}

/*&usage begin: poly_weight_to_omatrix(W,V)
 It translates the weight vector {W} into a matrix, which is used to set
 the order in asir Grobner basis functions.
 {V} is a list of variables.
 example: poly_weight_to_omatrix([2,1,0],[x,y,z]);
end: */
def poly_weight_to_omatrix(W,V) { 
  Opt = getopt();
  return taka_poly_weight_vector(W,V | option_list=Opt);
}


/* ---------------------hypergeometric------------------ */
/* Canonical function names for hypergeometric functions of
   one variables. 
*/
/* Experimental. cf. Xm_eval */
def hypergeometric_2f1(A,B,C,X) { 
  return taka_pfp_hypergeometric_2f1(A,B,C,X);
}
def hypergeometric_pfq(A,B,X) { 
  return taka_pfp_hypergeometric_pfq(A,B,X);
}
def hypergeometric_confluent_pfq(P,Q,A,B,X) { NOT_YET; }
def hypergeometric_airy(X) { NOT_YET; }
def hypergeometric_bessel_y(X) { NOT_YET; }
def hypergeometric_bessel_k(X) { NOT_YET; }
def hypergeometric_beta(A,B) { NOT_YET; }
def hypergeometric_gamma(A) { 
  return taka_pfp_gamma(A);
}
def hypergeometric_legendre_p(N,X) { NOT_YET; }
def hypergeometric_legendre_q(N,X) { NOT_YET; }
/*&usage   begin:
  hypergeometric_pochhammer(A,B,N)
  Multi-pochhammer symbol.
  example: hypergeometric_pochhammer([a,b],[c,1],3)
  end:
*/
def hypergeometric_pochhammer(A,B,N) { 
   return taka_pfp_poch1(A,B,N);
}
def hypergeometric_gkz(A,B) { return(sm1.gkz([A,B])); }

/* Canonical function names from Mathematica/Calculus */
def calculus_integrate(F,X) { NOT_YET; }
def calculus_n_integrate(F,X) { NOT_YET; }  /* NIntegrate */

/* Canonical function names for Series. cf. Mathematica/Series */
def series_expand(F,X) { NOT_YET; }  /* Series[ ] */
def series_inverse_series(F,X) { NOT_YET; }  
def series_chop(F,X) { NOT_YET; }    /* Normal[ ] */
def series_logical_expand(Eq) { NOT_YET; }
def series_solve(Eq,A) { NOT_YET; }
def series_limit(F,A) { NOT_YET; }

/* Canonical function names for matrix. cf. Mathematica/LiearAlgebra */
/*&usage begin: matrix_clone(M)
 It generates the clone of the matrix {M}.
 example: matrix_clone(matrix_list_to_matrix([[1,1],[0,1]]));
end: */
def matrix_clone(M) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_clone(M);
}

/*&usage begin: matrix_image(M)
 It computes the image of M.
 Redundant vectors are removed.
 example: matrix_image([[1,2,3],[2,4,6],[1,0,0]]);
 ref: matrix_kernel
end: */
def matrix_image(M) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_image(M);
}

/*&usage begin: matrix_matrix_to_list(M)
 It translates the matrix {M} to a list.
 ref: matrix_list_to_matrix
end: */
def matrix_matrix_to_list(M) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_mtol(M);
}

/*&usage begin: matrix_list_to_matrix(M)
 It translates the list {M} to a matrix.
 example: print_xdvi_form(matrix_list_to_matrix([[1,1],[0,2]]));
 ref: matrix_matrix_to_list
end: */
def matrix_list_to_matrix(M) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_ltom(M);
}

/*&usage begin: matrix_diagonal_matrix(L)
 It returns the diagonal matrix with diagonal entries {L}.
 example: matrix_diagonal_matrix([1,2,3]);
 ref: matrix_list_to_matrix
end: */
def matrix_diagonal_matrix(L) { 
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_diag(L);
}

/*&usage begin: matrix_identity_matrix(N)
 It returns the identity matrix of the size {N}.
 example: matrix_identity_matrix(5);
 ref: matrix_diagonal_matrix
end: */
def matrix_identity_matrix(N) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_1(N);
}

/*&usage begin: matrix_inner_product(A,B)
 It returns the inner product of two vectors {A} and {B}.
 example: matrix_inner_product([1,2],[x,y]);
end: */
def matrix_inner_product(A,B) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_inner_product(A,B);
}

/*&usage begin: matrix_transpose(M)
 It returns the transpose of the matrix {M}.
 ref: matrix_list_to_matrix
end: */
def matrix_transpose(M) {
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_trans(M);
}
def matrix_submatrix(M,R,C) { NOT_YET; } 
def matrix_dimensions(M) { NOT_YET; }

/*&usage begin: matrix_inverse(M)
 It returns the inverse of the matrix {M}.
 example: matrix_inverse([[1,2],[0,1]]);
end: */
def matrix_inverse(M) {  
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_inverse(M);
}

/*&usage begin: matrix_det(M)
 It returns the determinant of the matrix {M}.
 example: poly_factor(matrix_det([[1,x,x^2],[1,y,y^2],[1,z,z^2]]));
end: */
def matrix_det(M) { 
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_det(M);
}
def matrix_minors(M,K) { NOT_YET; }
def matrix_trace(M) { NOT_YET; }

/*&usage begin: matrix_solve_linear(M,X,B)
 It solves the system of linear equations M X = B
 example: matrix_solve_linear([[1,2],[0,1]],[x,y],[1,2]);
end: */
def matrix_solve_linear(M,X,B) {  
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_solve(M,X,B);
}  /* LinearSolve[ ] */
/*&usage begin: matrix_submatrix(M,Ind)
 It returns the submatrix of {M} defined by the index set {Ind}.
 example: matrix_submatrix([[0,1],[2,3],[4,5]],[1,2]);
end: */
def matrix_submatrix(M,Ind) {  
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_submatrix(M,Ind);
}  

/*&usage begin: matrix_kernel(M)
 It returns the basis of the kernel of the matrix {M}.
 example: matrix_kernel([[1,1,1,1],[0,1,3,4]]);
end: */
def matrix_kernel(M) {  
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_kernel(M);
}          /* NullSpace[ ] */

/*&usage begin: matrix_eigenavalues(M)
 It returns the eigenvalues of the matrix {M}.
 example: matrix_eigenvalues([[x,1],[0,y]]);
end: */
def matrix_eigenvalues(M) { 
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_eigenvalues(M);
}
def matrix_eigenvectors(M) { NOT_YET; }

/*&usage begin: matrix_rank(M)
 It returns the rank of the matrix {M}.
 example: matrix_rank([[1,1,1,1],[0,1,3,4]]);
end: */
def matrix_rank(M) { 
  OX_LOADFILE(Loaded_ok_matrix,"ok_matrix.rr");
  return omatrix_rank(M);
}


/* Canonical function names for graphic. cf. Mathematica/Graphic */
def graphic_plot(F,R) { NOT_YET; }
def graphic_plot_3d(F,R) { NOT_YET; }
def graphic_parametric_plot_3d(F,R) { NOT_YET; }

/* Canonical function names for printing. cf. Mathematica/Output */
def print_cmo_xml_form(F) { NOT_YET; }

/*&usage begin: print_em(S)
 It outputs {S} by a font to emphasize it.
 example: print_em(x^2-1);
end: */
def print_em(F) {
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_em(F);
}
/*&usage begin: print_dvi_form(S)
 It outputs {S} to a dvi file.
 example: print_dvi_form(x^2-1);
 ref: print_xdvi_form, print_tex_form 
end: */
def print_dvi_form(F) {
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_dvi_form(F);
}

/*&usage begin: print_gif_form(S|table)
 It outputs {S} to a file of the gif format.
 example: print_gif_form(newmat(2,2,[[x^2,x],[y^2-1,x/(x-1)]]));
 ref: print_tex_form
end: */
def print_gif_form(F) {
  Opt = getopt();
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_gif_form(F,Opt);
}
def print_html_form(F) { NOT_YET; }

/*&usage begin: print_input_form(S)
 It transforms {S} to a string which can be parsed by asir.
 example: print_input_form(quote(x^3-1));
end: */
def print_input_form(F) { 
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  /* Bug */
  if (type(F) == QUOTE || type(F) == STRUCT) 
    return taka_input_form(F);
  else return rtostr(F);
}

/*&usage begin: print_open_math_xml_form(S)
 It transforms {S} to a string which is compliant to OpenMath(1999).
 example: print_open_math_xml_form(x^3-1);
 ref: www.openmath.org
end: */
def print_open_math_xml_form(F) { 
  OX_LOADFILE(Loaded_om,"om.rr");
  return(om_xml(F)); 
}

/*&usage begin: print_ox_rfc100_xml_form(S)
 It transforms {S} to a string which is compliant to OpenXM RFC 100. 
 example: print_ox_rfc100_xml_form(x^3-1);
 ref: www.openxm.org
end: */
def print_ox_rfc100_xml_form(F) { 
  OX_LOADFILE(Loaded_taka_print_cmo100,"taka_print_cmo100.rr");
  return(taka_cmo100_xml_form(F));
}

/*&usage begin: print_png_form(S)
 It transforms {S} to a file of the format png.
 dvipng should be installed.
 example: print_png_form(x^3-1);
 ref: print_tex_form
end: */
def print_png_form(F) {
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_png_form3(F);
 /*   return taka_png_form(F); */
}
def print_png_form2(F) {
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_png_form2(F);
}

/*&usage begin: print_terminal_form(S)
 It transforms {S} to the terminal form???
end: */
def print_terminal_form(F) {  
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_terminal_form(F);
}

/*&usage begin: print_tex_form(S|table,raw)
 It transforms {S} to a string of the LaTeX format.
 description:
 The global variable Print_tex_form_fraction_format
 takes the values "auto", "frac",  or "/".
 The global variable Print_tex_form_no_automatic_subscript
 takes the values 0 or 1.
 BUG; A large input S cannot be translated.
 example: print_tex_form(x*dx+1 | table=[["dx","\\partial_x"]]);
 example_description:
 The optional variable table is used to give a translation
 table of asir symbols and tex symbols.
 when AMSTeX = 1, "begin pmatrix" and "end pmatrix" will be used to output matrix.
 ref: print_xdvi_form
end: */
def print_tex_form(F) {  
  Argv = getopt();
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return taka_tex_form_top(F,Argv);
}

/*&usage begin: print_xdvi_form(S)
 It transforms {S} to a xdvi file and previews the file by xdvi.
 example: print_xdvi_form(newmat(2,2,[[x^2,x],[y^2-1,x/(x-1)]]));
 example: print_xdvi_form(print_tex_form(1/2));
 ref: print_tex_form, print_dvi_form
end: */
def print_xdvi_form(F) { 
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return(taka_xdvi_form(F));
}

/*&usage begin: print_xv_form(S|input,format)
 It transforms {S} to a gif file and previews the file by xv.
 example: print_xv_form(newmat(2,2,[[x^2,x],[y^2-1,x/(x-1)]]));
 example: print_xv_form(x+y | format="png");
 example_description: If the optional variable format="png" is set,
  png format will be used to generate an input for xv.
 ref: print_tex_form, print_gif_form
end: */
def print_xv_form(F) { 
  Argv = getopt();
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  return(taka_xv_form(F,Argv));
}

/*&usage begin: print_tfb_form(S)
 It transforms {S} to the tfb format.
 example: print_tfb_form(x+1);
end: */
def print_tfb_form(F) { 
  OX_LOADFILE(Loaded_taka_print_tfb,"taka_print_tfb.rr");
  return(taka_tfb_form(F));
}


def print_terminal_form_(F) {
  print(print_terminal_form(F),0);
}
def print_input_form_(F) {
  print(print_input_form(F),0);
}
/*&usage begin: print_output(Obj|file, mode)
 It outputs the object {Obj} to a file. 
 If the optional variable {file} is set, then it outputs the {Obj} to the
 specified file, else it outputs it to "asir_output_tmp.txt".
 If the optional variable {mode} is set to "w", 
 then the file is newly created.
 If the optional variable is not set, the {Obj} is appended to the file.
 example: print_output("Hello"|file="test.txt");
 ref: glib_tops()
end: */
def print_output(Obj) { 
  OX_LOADFILE(Loaded_taka_print,"noro_print.rr");
  M = "a"; F = "asir_output_tmp.txt";
  Argv = getopt();
  for (I=0; I<length(Argv); I++) {
    if (Argv[I][0] == "mode") {
      M = Argv[I][1];
    }else if (Argv[I][0] == "file") {
      F = Argv[I][1];
    }else{
      error("Unknown option "+rtostr(Argv[I][0])+" in print_output");
      return;
    }
  }
  return taka_print_output(Obj,F,M);
}

set_print_function("print_input_form_")$

/*&usage begin: print_open_math_tfb_form(S)
 It transforms {S} to a tfb format of OpenMath XML. 
 description: It is experimental. You need to load taka_print_tfb.rr 
 to call it.
 example: print_open_math_tfb_form(quote(f(x,1/(y+1))+2));
end: */
def print_open_math_tfb_form(F) { 
  OX_LOADFILE(Loaded_taka_print_tfb,"taka_print_tfb.rr");
  return("<tfb> "+taka_tfb_form(F)+" </tfb>" );
}

/* -----------------util---------------------- */
/*&usage begin: util_timing(Q)
 Show the timing data to execute {Q}.
 example: util_timing( quote( fctr(x^50-y^50) ));
end: */
def util_timing(Q) { 
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_timing(Q));
}
/*&usage begin: util_load_file_as_a_string(F)
 It reads a file {F} as a string.
end: */
def util_load_file_as_a_string(F) { 
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_load_file_as_a_string(F));
}
/*&usage begin: util_read_file_as_a_string(F)
 It reads a file {F} as a string.
end: */
def util_read_file_as_a_string(F) { 
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_load_file_as_a_string(F));
}
/*&usage begin: util_write_string_to_a_file(Fname,S)
 It writes a string {S} to a file {Fname}.
end: */
def util_write_string_to_a_file(Fname,S) { 
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_write_string_to_a_file(Fname,S));
}
/*&usage begin: util_filter(Command,Input|env)
 It executes the filter program {Command} with the {Input}
 and returns the output of the filter as a string.
 example: util_filter("sort","cat\ndog\ncentipede\n");
end: */
def util_filter(C,Input) { 
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  Env = getopt();
  return(taka_util_filter(C,Input,Env));
}
/*---------- util for strings---------------*/
/*&usage begin: util_find_and_replace(W,S,Wnew)
 It replaces {W} in {S} by {Wnew}.
 Arguments must be a list of ascii codes.
end: */
def util_find_and_replace(W,S,Snew) {
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_find_and_replace(W,S,Snew));
}
/*&usage begin: util_find_substr(W,S)
 It returns the position of {W} in {S}.
 If {W} cannot be found, it returns -1.
 Arguments must be a list of ascii codes.
end: */
def util_find_substr(W,S) {
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_find_substr(W,S));
}
/*&usage begin: util_part(S,P,Q)
 It returns from {P}th element to {Q}th element of {S}.
end: */
def util_part(S,P,Q) {
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_part(S,P,Q));
}
/*&usage begin: util_remove_cr(S)
 It removes cr/lf/tabs from {S}.
 Arguments must be a list of ascii codes.
end: */
def util_remove_cr(S) {
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_remove_cr(S));
}
/* --------- util for poly --------------- */
/*&usage begin: util_index(V)
  It returns the name part and the index part of {V}.
  example: util_index(x_2_3)
  ref: util_v
end: */
def util_index(V) {
  OX_LOADFILE(Loaded_taka_util,"taka_util.rr");
  return(taka_util_index(V));
}

/*&usage begin: util_v(V,L)
  It returns a variable indexed by {L}.
  example: util_v("x",[1,3]);
  ref: util_index
end: */
def util_v(V,L) {
  OX_LOADFILE(Loaded_taka_util,"taka_plucker.rr");
  return(taka_indexed_variable(V,L));
}

/*&usage begin: a_hypergeometric_bfunction(A,V,S)
  It returns the hypergeometric b-function.
  {A} is the defining matrix of the hypergeometric system.
  {V} is an integer, which indicates a direction.
  {S} is a list of variables.
  example: a_hypergeometric_bfunction([[1,1,1],[0,1,2]],0,[s1,s2]);
end: */
def a_hypergeometric_bfunction(A,V,S) {
  OX_LOADFILE(Loaded_taka_ahg,"taka_ahg.rr");
  return( taka_ahg.bb(A,V,S) );
}
end$





