/* $OpenXM: OpenXM/src/asir-contrib/packages/src/names.rr,v 1.31 2001/12/13 09:27:45 takayama Exp $ */
#define NOT_YET   print("It has not yet been implemented.")

/* Include data type declaration. */
load("datatype.rr")$
/* Include a standard library. It should be included
   in a different place in a future. */
load("quote.rr")$  load("misc.rr")$ load("tex_symbols.rr")$
load("xml_basic_symbols.rr")$
load("taka_print_cmo100.rr")$

/* should use load_exec() for demand loading. */
def ox_loadfile(Tag,FileName) {
  if (!Tag) Result=load(FileName); else return(1);
  if (Result == 0) error("File "+FileName+" was not found.");
  return(1);
}
ox_loadfile(Loaded_taka_base,"taka_base.rr") $
ox_loadfile(Loaded_taka_print,"taka_print.rr") $
ox_loadfile(Loaded_om,"om") $
ox_loadfile(Loaded_Matrix,"Matrix") $
ox_loadfile(Loaded_taka_base,"taka_base.rr") $
ox_loadfile(Loaded_taka_poly,"taka_poly.rr") $
/* This file and logname give a list of canonical names of functions.
   Names are classified in categories such as number, matrix, and so on.
   If you implement one of the functions listed below, 
   please call your functions from here.
   Example:
     if your number_chop is implemented by the name
          hoge_chop,
     you should write here as
     def number_chop(Exp,Dx) {  return(hoge_chop(Exp,Dx)); }
*/

#define OX_LOADFILE(A,B)   /* Do nothing. */

/* Function to check OSTYPE (temporary) */
def ox_ostype() {
  if (getenv("OPENXMHOMEWIN") != 0) {
    return(["windows"]);
  }else{
    return(["unix"]);
  }
}

Print_tex_form_fraction_format="auto"$  /* "frac" or "auto" or "/" */
Print_tex_form_no_automatic_subscript=0$ /* 0 or 1 */

/* Base module */
def base_cancel(S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_cancel(S);
}
def base_choose(L,M) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_choose(L,M);
}
def base_flatten(S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_flatten(S);
}
def base_intersection(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_intersection(A,B);
}
def base_memberq(A,S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_memberq(A,S);
}
def base_permutation(L) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_permutation(L);
}
def base_position(A,S) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_position(A,S);
}
def base_prune(A,S) {
  /* Prune A from the set S */
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_prune(A,S);
}
def base_replace(S,Rule) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_replace(S,Rule);
}
def base_set_minus(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_set_minus(A,B);
}
def base_set_union(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_set_union(A,B);
}
def base_subsetq(A,B) {
  OX_LOADFILE(Loaded_taka_base,"taka_base.rr");
  return taka_base_subsetq(A,B);
}

/* Canonical function names for numbers. cf. Mathematica/Numbers */
def number_base_form(X,B) { NOT_YET; }
def number_chop(Exp,Dx) {  NOT_YET; }
def number_round(X) { NOT_YET; }
def number_floor(X) { return(pari(floor,X)); }
def number_ceiling(X) { return(pari(ceil,X)); }
def number_sign(X) { NOT_YET; }
def number_abs(X)  { return(pari(abs,X)); }
def number_max(X)  { NOT_YET; }
def number_min(X)  { NOT_YET; }
def number_n(Exp)  { NOT_YET; }  /* N [ ], numerical evaluator. */
def number_binomial(P,Q) { NOT_YET; }

/* See longname for basic_ and poly_. Here are some added functions */
def poly_elimination_ideal(I,VV) { 
  O = getopt(grobner_basis);
  V = getopt(v);
  OL = [["grobner_basis",O],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_elimination_ideal(I,VV|option_list=OL);
}
def poly_grobner_basis(I) {
  Or = getopt(order);
  V = getopt(v);
  OL = [["order",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_grobner_basis(I|option_list=OL);
}
def poly_hilbert_polynomial(I)  { 
  /* return(subst(hilbert_polynomial(I,V),h,S));  */
  S = getopt(s);
  V = getopt(v);
  OL = [["s",S],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_hilbert_polynomial(I|option_list=OL);
}
def poly_initial(I) {
  Or = getopt(order);
  V = getopt(v);
  OL = [["order",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_initial(I|option_list=OL);
}

def poly_initial_coefficients(I) {
  Or = getopt(order);
  V = getopt(v);
  OL = [["order",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_initial_coefficients(I | option_list=OL);
}
def poly_initial_term(F) {
  Or = getopt(order);
  V = getopt(v);
  Weight = getopt(weight);
  OL = [["order",Or],["v",V],["weight",Weight]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_initial_term(F | option_list=OL);
}
def poly_degree(I) {
  Or = getopt(weight);
  V = getopt(v);
  OL = [["weight",Or],["v",V]];
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_degree(I | option_list=OL);
}

def poly_solve(Eqs,V) { NOT_YET; }
def poly_solve_linear(Eqs,V) { 
  OX_LOADFILE(Loaded_taka_base,"taka_poly.rr");
  return taka_poly_solve_linear(Eqs,V);
}
def poly_weight_vector(W) { NOT_YET; }



/* Canonical function names for hypergeometric functions of
   one variables. 
*/
def hypergeometric_2f1(A,B,C,X) { NOT_YET; }
def hypergeometric_pfp1(A,B,X) { NOT_YET; }
def hypergeometric_confluent_pfp1(P,Q,A,B,X) { NOT_YET; }
def hypergeometric_airy(X) { NOT_YET; }
def hypergeometric_bessel_y(X) { NOT_YET; }
def hypergeometric_bessel_k(X) { NOT_YET; }
def hypergeometric_beta(A,B) { NOT_YET; }
def hypergeometric_gamma(A) { NOT_YET; }
def hypergeometric_legendre_p(N,X) { NOT_YET; }
def hypergeometric_legendre_q(N,X) { NOT_YET; }
def hypergeometric_pochhammer(A,N) { NOT_YET; }
def hypergeometric_gkz(A,B) { return(sm1_gkz([A,B])); }

/* Canonical function names from Mathematica/Calculus */
def calculus_integrate(F,X) { NOT_YET; }
def calculus_n_integrate(F,X) { NOT_YET; }  /* NIntegrate */

/* Canonical function names for Series. cf. Mathematica/Series */
def series_expand(F,X) { NOT_YET; }  /* Series[ ] */
def series_inverse_series(F,X) { NOT_YET; }  
def series_chop(F,X) { NOT_YET; }    /* Normal[ ] */
def series_logical_expand(Eq) { NOT_YET; }
def series_solve(Eq,A) { NOT_YET; }
def series_limit(F,A) { NOT_YET; }

/* Canonical function names for matrix. cf. Mathematica/LiearAlgebra */
def matrix_clone(M) {
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_clone(M);
}
def matrix_matrix_to_list(M) {
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_mtol(M);
}
def matrix_list_to_matrix(M) {
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_ltom(M);
}
def matrix_diagonal_matrix(L) { 
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_diag(L);
}
def matrix_identity_matrix(N) {
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_1(N);
}
def matrix_inner_product(A,B) {
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_inner_product(A,B);
}
def matrix_transpose(M) {
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_trans(M);
}
def matrix_submatrix(M,R,C) { NOT_YET; } 
def matrix_dimensions(M) { NOT_YET; }
def matrix_inverse(M) {  
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_inverse(M);
}
def matrix_det(M) { 
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_det(M);
}
def matrix_minors(M,K) { NOT_YET; }
def matrix_trace(M) { NOT_YET; }
def matrix_solve_linear(M,X,B) {  
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_solve(M,X,B);
}  /* LinearSolve[ ] */
def matrix_kernel(M) {  
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_kernel(M);
}          /* NullSpace[ ] */
def matrix_eigenvalues(M) { 
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_eigenvalues(M);
}
def matrix_eigenvectors(M) { NOT_YET; }
def matrix_rank(M) { 
  OX_LOADFILE(Loaded_Matrix,"Matrix");
  return omatrix_rank(M);
}


/* Canonical function names for graphic. cf. Mathematica/Graphic */
def graphic_plot(F,R) { NOT_YET; }
def graphic_plot_3d(F,R) { NOT_YET; }
def graphic_parametric_plot_3d(F,R) { NOT_YET; }

/* Canonical function names for printing. cf. Mathematica/Output */
def print_cmo_xml_form(F) { NOT_YET; }
def print_dvi_form(F) {
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return taka_dvi_form(F);
}
def print_gif_form(F) {
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return taka_gif_form(F);
}
def print_html_form(F) { NOT_YET; }
def print_input_form(F) { 
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return taka_input_form(F);
}
def print_open_math_xml_form(F) { 
  OX_LOADFILE(Loaded_om,"om");
  return(ox_xml(F)); 
}
def print_ox_rfc100_xml_form(F) { 
  OX_LOADFILE(Loaded_taka_print_cmo100,"taka_print_cmo100.rr");
  return(taka_cmo100_xml_form(F));
}
def print_png_form(F) {
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return taka_png_form(F);
}
def print_terminal_form(F) {  
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return taka_terminal_form(F);
}
def print_tex_form(F) {  
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return taka_tex_form(F);
}
def print_xdvi_form(F) { 
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return(taka_xdvi_form(F));
}
def print_xv_form(F) { 
  OX_LOADFILE(Loaded_taka_print,"taka_print.rr");
  return(taka_xv_form(F));
}


def print_terminal_form_(F) {
  print(print_terminal_form(F),0);
}
def print_input_form_(F) {
  print(print_input_form(F),0);
}
set_print_function("print_input_form_")$
end$





