/* $OpenXM: OpenXM/src/asir-contrib/packages/src/noro_matrix.rr,v 1.4 2004/05/19 01:08:22 noro Exp $ */

/* functions for linear algebra over Q */

/* dense matrix */

module linalg;

localf random_mat,random_smat,subst_mat,mulsub_mat;
localf dup_mat,unit_mat,minipoly_mat,reduce_mat,insert_to_base;
localf mat_to_smat,smat_to_mat,vect_to_svect,random_vect;
localf mulsub_vect,muladd_vect,dup_vect,mul_smat_vect,mul_svect_vect;
localf minipoly_cand_mat,minipoly_cand_smat;
localf reduce_vect,insert_to_sbase,minipoly_check_mat;
localf minipoly_check_smat,ptozp_mat;
localf create_basis,sample_mat,jordan_decomp;
localf random_rmat,minipoly_mat_direct,ptozp_vect;
localf jordan_canonical_form,compute_jordan_block_basis;
localf compute_jordan_block_basis_main,first_element;
localf compute_image,compute_kernel,reduced_form_mat,mat_to_col,zero_vector;
localf zero_mat,extended_euclid2,extended_euclid;

def random_mat(N,Bound)
{
	A = matrix(N,N);
	for ( I = 0; I < N; I++ )
		for ( J = 0; J < N; J++ )
			A[I][J] = (random()%Bound)*(random()%2?-1:1);
	return A;
}

def random_rmat(M,N,Bound)
{
	A = matrix(M,N);
	for ( I = 0; I < M; I++ )
		for ( J = 0; J < N; J++ )
			A[I][J] = (random()%Bound)*(random()%2?-1:1);
	return A;
}

def random_smat(N,Bound,Percent)
{
	R = [];
	for ( I = N-1; I >= 0; I-- ) {
		V = [];
		for ( J = N-1; J >= 0; J-- ) {
			if ( (random()%100) < Percent ) {
				C = (random()%Bound)*(random()%2?-1:1);
				V = cons([J,C],V);
			}
		}
		R = cons([I,V],R);
	}
	return cons([N,N],R);
}

def subst_mat(P,A)
{
	N = size(A)[0];
	if ( type(P) <= 1 )
		return P*unit_mat(N);
	else {
		V = var(P);
		QR = sqr(P,V);
		/* P = Q*V+R */
		return subst_mat(QR[0],A)*A+QR[1]*unit_mat(N);
	}
}

/* A = A*C1-B*C2 */

def mulsub_mat(A,C1,B,C2)
{
	S = size(A); R = S[0]; C = S[1];
	for( I = 0; I < R; I++ )
		for ( J = 0; J < C; J++ )
			A[I][J] = A[I][J]*C1-B[I][J]*C2;
}

def dup_mat(A)
{
	S = size(A); R = S[0]; C = S[1];
	M = matrix(R,C);
	for( I = 0; I < R; I++ )
		for ( J = 0; J < C; J++ )
			M[I][J] = A[I][J];
	return M;
}

def unit_mat(N)
{
	M = matrix(N,N);
	for ( I = 0; I < N; I++ ) M[I][I] = 1;
	return M;
}

/* Base = [[Mat,I,J,Poly],...] */

def minipoly_mat_direct(A)
{
	L = ptozp_mat(A);
	/* A = B/DN */
	B = L[0]; DN = L[1];
	N = size(B)[0];
	E = unit_mat(N);
	Base = [[E,0,0,1]];
	Bk = E;
	for ( K = 1; ; K++ ) {
		Bk *= B;	
		R = reduce_mat(Bk,x^K,Base);
		if ( !R[0] ) {
			P = ptozp(R[3]);
			if ( coef(P,deg(P,x)) < 0 )
				P = -P;
			break;
		} else
			Base = insert_to_base(R,Base);
	}
	/* m_B(x)=P  => m_A(x)=m_B(DN*x) */
	return ptozp(subst(P,x,DN*x));
}

def minipoly_mat(A)
{
	L = ptozp_mat(A);
	/* A = B/DN */
	B = L[0]; DN = L[1];
	while ( 1 ) {
		P = minipoly_cand_mat(B);
		if ( minipoly_check_mat(B,P) ) break;
	}
	/* m_B(x)=P  => m_A(x)=m_B(DN*x) */
	return ptozp(subst(P,x,DN*x));
}

def reduce_mat(M,P,Base)
{
	N = size(M)[0];
	M = dup_mat(M);
	for ( T = Base; T != []; T = cdr(T) ) {	
		B = car(T);
		BM = B[0]; I = B[1]; J = B[2]; BP = B[3];
		if ( M[I][J] ) {
			/* M <- M*BM[I][J]-M[I][J]*BM */
			/* P <- P*BM[I][J]-M[I][J]*BP */
			C1 = BM[I][J]; C2 = M[I][J];
			G = igcd(C1,C2);
			C1 = idiv(C1,G);
			C2 = idiv(C2,G);
			mulsub_mat(M,C1,BM,C2);
			P = P*C1-BP*C2;
		}
	}
	for ( I = 0; I < N; I++ )
		for ( J = 0; J < N; J++ )
			if ( M[I][J] ) return [M,I,J,P];
	return [0,-1,-1,P];
}

def insert_to_base(R,Base)
{
	if ( Base == [] )
		return [R];
	Top = car(Base);
	if ( R[1] < Top[1] || (R[1] == Top[1] && R[2] < Top[2]) )
		return cons(R,Base);
	else
		return cons(Top,insert_to_base(R,cdr(Base)));
}

/* sparse matrix */

def mat_to_smat(A)
{
	N = size(A)[0];
	R = [];
	for ( I = N-1; I >= 0; I-- ) {
		V = vect_to_svect(A[I]);
		R = cons([I,V],R);
	}
	return cons(size(A),R);
}

def smat_to_mat(A)
{
	Size = A[0];
	R = matrix(Size[0],Size[1]);
	for ( T = cdr(A); T != []; T = cdr(T) ) {
		P = car(T);
		I = P[0]; V = P[1];
		for ( S = V; S != []; S = cdr(S) ) {
			P = car(S);
			R[I][P[0]] = P[1];
		}
	}
	return R;
}

def vect_to_svect(V)
{
	N = size(V)[0];
	R = [];
	for ( I = N-1; I >= 0; I-- )
		if ( V[I] )
			R = cons([I,V[I]],R);
	return R;
}

def random_vect(N,Bound)
{
	A = vector(N);
	for ( I = 0; I < N; I++ )
		A[I] = (random()%Bound)*(random()%2?-1:1);
	return A;
}

/* A = A*C1-B*C2 */

def mulsub_vect(A,C1,B,C2)
{
	S = size(A); R = S[0];
	for( I = 0; I < R; I++ )
		A[I] = A[I]*C1-B[I]*C2;
}

/* A += B*C */

def muladd_vect(A,B,C)
{
	S = size(A); R = S[0];
	for( I = 0; I < R; I++ )
		A[I] += B[I]*C;
}

def dup_vect(A)
{
	S = size(A); R = S[0];
	M = vector(R);
	for( I = 0; I < R; I++ )
		M[I] = A[I];
	return M;
}

/* A = [[R,C],[I,[[J,AIJ],...]],...] */

def mul_smat_vect(A,V)
{
	N = size(V)[0];
	Row = A[0][0];
	R = vector(Row);
	for ( T = cdr(A), I = 0; T != []; T = cdr(T), I++ )
		R[I] = mul_svect_vect(car(T)[1],V);
	return R;
}

/* A = [[J,AIJ],...] */

def mul_svect_vect(A,V)
{
	R = 0;
	for ( T = A; T != []; T = cdr(T) ) {
		S = car(T);
		R += S[1]*V[S[0]];
	}
	return R;
}

/* Base = [[Vect,I,Poly],...] */
def minipoly_cand_mat(A)
{
	N = size(A)[0];
	V = random_vect(N,50);
	Base = [[V,0,1]];
	AkV = V;
	for ( K = 1; ; K++ ) {
		AkV = A*AkV;
			R = reduce_vect(AkV,x^K,Base);
			if ( !R[0] ) {
				P = ptozp(R[2]);
				if ( coef(P,deg(P,x)) < 0 )
					P = -P;
				return P;
			} else
			Base = insert_to_sbase(R,Base);
	}
}

/* Base = [[Vect,I,Poly],...] */
def minipoly_cand_smat(A)
{
	N = A[0][0];
	V = random_vect(N,50);
	Base = [[V,0,1]];
	AkV = V;
	for ( K = 1; ; K++ ) {
		AkV = mul_smat_vect(A,AkV);
		R = reduce_vect(AkV,x^K,Base);
		if ( !R[0] ) {
			P = ptozp(R[2]);
			if ( coef(P,deg(P,x)) < 0 )
				P = -P;
			return P;
		} else
			Base = insert_to_sbase(R,Base);
	}
}

/* reduce a vector M by a sorted base Base.
   P is a symbol representing M.
   returns [M',Head,P'], where Head is the
   position of the leftmost nonzero element in M',
   M' is the reduced vector, P' represents M'.
*/

def reduce_vect(M,P,Base)
{
	N = size(M)[0];
	M = dup_vect(M);
	for ( T = Base; T != []; T = cdr(T) ) {	
		B = car(T);
		BM = B[0]; I = B[1]; BP = B[2];
		if ( M[I] ) {
			/* M <- M*BM[I]-M[I]*BM */
			/* P <- P*BM[I]-M[I]*BP */
			C1 = BM[I]; C2 = M[I];
			G = igcd(C1,C2);
			C1 = idiv(C1,G);
			C2 = idiv(C2,G);
			mulsub_vect(M,C1,BM,C2);
			P = P*C1-BP*C2;
		}
	}
	for ( I = 0; I < N; I++ )
		if ( M[I] ) return [M,I,P];
	return [0,-1,P];
}

def insert_to_sbase(R,Base)
{
	if ( Base == [] )
		return [R];
	Top = car(Base);
	if ( R[1] < Top[1] )
		return cons(R,Base);
	else
		return cons(Top,insert_to_sbase(R,cdr(Base)));
}

def minipoly_check_mat(S,P)
{
#if 0
	Size = size(S);
	N = Size[0];
	V = vector(N);
	X = var(P);
	D = deg(P,X);
	C = vector(D+1);
	for ( I = 0; I <= D; I++ )
		C[I] = coef(P,I,X);
	for ( I = 0; I < N; I++ ) {
		for ( J = 0; J < N; J++ )
			V[J] = J==I?1:0;
		AkV = dup_vect(V);
		V *= C[0];
		for ( K = 1; K <= D; K++ ) {
			AkV = S*AkV;
			muladd_vect(V,AkV,C[K]);
		}
		for ( J = 0; J < N; J++ )
			if ( V[J] ) break;
		if ( J < N ) return 0;
	}
	return 1;
#else
	B = subst_mat(P,S);
	for ( I = 0; I < N; I++ )
		for ( J = 0; J < N; J++ )
			if ( B[I][J] ) return 0;
	return 1;
#endif
}

def minipoly_check_smat(S,P)
{
	Size = S[0];
	N = Size[0];
	V = vector(N);
	X = var(P);
	D = deg(P,X);
	C = vector(D+1);
	for ( I = 0; I <= D; I++ )
		C[I] = coef(P,I,X);
	for ( I = 0; I < N; I++ ) {
		for ( J = 0; J < N; J++ )
			V[J] = J==I?1:0;
		AkV = dup_vect(V);
		V *= C[0];
		for ( K = 1; K <= D; K++ ) {
			AkV = mul_smat_vect(S,AkV);
			muladd_vect(V,AkV,C[K]);
		}
		for ( J = 0; J < N; J++ )
			if ( V[J] ) break;
		if ( J < N ) return 0;
	}
	return 1;
}

/* A = 1/D*B => return [B,D] */

def ptozp_mat(A)
{
	Size = size(A);
	M = Size[0]; N = Size[1];
	D = 0; K = 0;
	for ( I = 0; I < M; I++ )
		for ( J = 0; J < N; J++ ) {
			D += A[I][J]*<<K>>; K++;
		}
	if ( !D ) {
		B = matrix(M,N);
		return [B,1];
	} else {
		E = dp_ptozp(D);
		C = dp_hc(E)/dp_hc(D);
		return [C*A,C];
	}
}

def ptozp_vect(A)
{
	M = size(A)[0];
	D = 0; K = 0;
	for ( I = 0; I < M; I++ ) {
		D += A[I]*<<K>>; K++;
	}
	if ( !D ) {
		B = vector(M);
		return [B,1];
	} else {
		E = dp_ptozp(D);
		C = dp_hc(E)/dp_hc(D);
		return [C*A,C];
	}
}

def create_basis(B)
{
	N = length(B);
	Base = [];
	for ( K = 0; K < N; K++ ) {
		AkV = ptozp_vect(B[K])[0];
		R = reduce_vect(AkV,<<K>>,Base);
		if ( R[0] )
			Base = insert_to_sbase(R,Base);
	}
	return Base;
}

def sample_mat(Data)
{
	Asis = getopt(asis);
	/* Data = [[Alpha,M],...] */
	N = 0;
	for ( T = Data; T != []; T = cdr(T) )
		N += car(T)[1];
	A = matrix(N,N);
	for ( T = Data, I = 0; T != []; T = cdr(T) ) {
		B = car(T);
		Alpha = B[0];
		M = B[1];
		for ( J = 0; J < M; J++ ) A[I+J][I+J] = Alpha;
		for ( J = 1; J < M; J++ ) A[I+J-1][I+J] = 1;
		I += M;
	}
	if ( type(Asis) != -1 )
		return A;

	P = matrix(N,N);
	while ( 1 ) {
		for ( I = 0; I < N; I++ )
			for ( J = 0; J < N; J++ )
				if ( (random()%100) > 80 )
					P[I][J] = 1;
				else
					P[I][J] = 0;
		if ( det(P) ) {
			Z = invmat(P);
			return (Z[0]*A*P)/Z[1];			
		}
	}
}

def jordan_decomp(A)
{
	N = size(A)[0];
	M = minipoly_mat(A);
	FM = fctr(M);
	/* skip const */
	FM = cdr(FM);
	L = length(FM);

	/* extracting roots and multiplicities */
	Alpha = vector(L);
	E = vector(L);
	for ( I = 0; I < L; I++ )
		if ( deg(F=FM[I][0],x) != 1 ) 
			error("irrational eigenvalue : not implemented yet");
		else {
			Alpha[I] = -coef(F,0,x)/coef(F,1,x);
			E[I] = FM[I][1];
		}
	F = vector(L);
	M = sdiv(M,coef(M,deg(M,x)));
	for ( I = 0; I < L; I++ )
		F[I] = sdiv(M,(x-Alpha[I])^E[I]);

	/* computation of coefficient polys */
	T = extended_euclid(F);
	G = T[0]; GCD = T[1];
	G /= GCD;
	for ( I = 0; I < L; I++ )
		G[I] = srem(G[I],(x-Alpha[I])^E[I]);

	/* projection operators */
	P = vector(L);
	for ( I = 0; I < L; I++ )
		P[I] = subst_mat(G[I]*F[I],A);
#if 0
	/* for checking projection operators */
	for ( T = P[0], I = 1; I < L; I++ )
		T += P[I];
	print(T);
	for ( I = 0; I < L; I++ )
		for ( J = 0; J < L; J++ ) {
			if ( I == J ) {
				if ( !zero_mat(P[I]^2-P[I]) )
				error("cfo");
			} else if ( !zero_mat(P[I]*P[J])) 
				error("dfo");
		}
#endif
	/* computation of S, N */
	S = matrix(N,N);
	for ( I = 0; I < N; I++ )
		for ( J = 0; J < N; J++ ) {
			for ( T = 0, K = 0; K < L; K++ )
				T += Alpha[K]*P[K][I][J];
			S[I][J] = T;
		 }
	return [S,A-S];
}

def jordan_canonical_form(A)
{
	N = size(A)[0];
	M = minipoly_mat(A);
	FM = fctr(M);
	/* skip const */
	FM = cdr(FM);
	L = length(FM);

	/* extracting roots and multiplicities */
	Alpha = vector(L);
	E = vector(L);
	for ( I = 0; I < L; I++ )
		if ( deg(F=FM[I][0],x) != 1 ) 
			error("irrational eigenvalue : not implemented yet");
		else {
			Alpha[I] = -coef(F,0,x)/coef(F,1,x);
			E[I] = FM[I][1];
		}
	M = sdiv(M,coef(M,deg(M,x)));

	/* (A-Alpha[I])^E[I] */
	P = vector(L);
	for ( I = 0; I < L; I++ )
		P[I] = subst_mat((x-Alpha[I])^E[I],A);
	/* computation of Vi */
	Q = matrix(N,N);
	for ( K = 0, J = 0; K < L; K++ ) {
		BK = compute_kernel(P[K]);
		JBK = compute_jordan_block_basis(A,Alpha[K],E[K],BK);
		for ( T = JBK; T != []; T = cdr(T), J++ ) {
			V = car(T);
			for ( I = 0; I < N; I++ )
				Q[I][J] = V[I];
		}
	}
#if 1
	QI = invmat(Q);
	return [QI[0]*A*Q/QI[1],Q];
#else
	return Q;
#endif
}

/* Span(Base) = Ker((A-Alpha*E)^E) */
/* Base = [[V1,Pos1],[V2,Pos2],...] (Pos1 > Pos2 > ...) */

def compute_jordan_block_basis(A,Alpha,E,Base)
{
	/* S = dim(V) */
	S = size(A)[0];
	/* D = dim(Span(Base)) */
	D = length(Base);
	N = A-Alpha*unit_mat(S);
	/* represent N wrt Base */
	Mat = matrix(D,D);
	for ( J = 0; J < D; J++ ) {
		/* N*ej = sum_i mij*ei */
		Nej = N*Base[J][0];
		for ( I = 0; I < D; I++ ) {
			K = Base[I][1];
			if ( Nej[K] ) {
				Mat[I][J] = Nej[K]/Base[I][0][K];
				Nej -= Mat[I][J]*Base[I][0];	
			}
		}
		if ( !zero_vector(Nej) )
			error("afo");
	}
	JB = compute_jordan_block_basis_main(Mat,E);
#if 0
	/* check */
	P = matrix(D,D);
	for ( J = 0; J < D; J++ ) {
		V = JB[J];
		for ( I = 0; I < D; I++ )
			P[I][J] = V[I];
	}
	Pinv = invmat(P);
	print(Pinv[0]*Mat*P/Pinv[1]);
#endif
	/* create a matrix whose columns are vectors in Base */
	BMat = matrix(S,D);
	for ( J = 0; J < D; J++ ) {
		V = Base[J][0];
		for ( I = 0; I < S; I++ )
			BMat[I][J] = V[I];
	}
	JB1 = [];
	for ( T = JB; T != []; T = cdr(T) ) {
		JB1 = cons(BMat*car(T),JB1);
	}
	return reverse(JB1);
}

/* N : nilpotent; N^(E-1) neq 0, N^E = 0 */

def compute_jordan_block_basis_main(N,E)
{
	Np = vector(E+1);
	D = size(N)[0];
	Np[0] = unit_mat(D);
	for ( I = 1; I <= E; I++ )
		Np[I] = Np[I-1]*N;
	Ker = vector(E+1);
	R = vector(E+1);
	for ( I = 0; I <= E; I++ ) {
		Ker[I] = map(first_element,compute_kernel(Np[I]));
		R[I] = length(Ker[I]);
	}

	PW = [];
	AllBase = [];
	for ( I = E-1; I >= 0; I-- ) {
		/* NPW = N*PW */
		for ( T = PW, S = []; T != []; T = cdr(T) )
			S = cons(N*car(T),S);
		NPW = reverse(S);
		/* number of elements to be added */
		DW = R[I+1]-R[I]-length(NPW);
		Base = create_basis(append(Ker[I],NPW));
		W = [];
		for ( T = Ker[I+1]; T != []; T = cdr(T), L++ ) {
			Red = reduce_vect(car(T),0,Base);
			if ( Red[0] ) {
				Base = insert_to_sbase(Red,Base);
				for ( K = I; K >= 0; K-- )
					AllBase = cons(Np[K]*car(T),AllBase);
			}
		}
		PW = map(first_element,Base);
	}
	return reverse(AllBase);
}

def first_element(L)
{
	return car(L);
}

def compute_image(A)
{
	B = mat_to_col(A);
	return create_basis(B);
}

def compute_kernel(A)
{
	S = size(A);
	M = S[0];
	N = S[1];
	B = matrix(M,N);
	for ( I = 0; I < M; I++ )
		for ( J = 0; J < N; J++ )
			B[I][N-J-1] = A[I][J];
	B = ptozp_mat(B)[0];
	Index = vector(M);
	Tl = reduced_form_mat(B,Index,M,N); L = car(Tl); D = car(cdr(Tl));
	if ( L < 0 )
		return [];

	R = [];
	Head = vector(N);
	for ( I = 0; I < L; I++ ) Head[Index[I]] = 1;

	for ( I = 0; I < N; I++ ) {
		if ( Head[I] ) continue;
		S = vector(N);
		S[N-I-1] = 1;
		for ( J = K = 0; J < I; J++ )
			if ( Head[J] ) {
				S[N-J-1] = -B[K][I]/B[K][Index[K]];
				K++;
			} else
				S[N-J-1] = 0;
		R = cons([ptozp_vect(S)[0],N-I-1],R);
	}
	return R;
}

/* 
 *	Mat : matrix of size MxN
 *	Index : vector of length M
 *  Index[I] = head position of Mat[I]
 */

def reduced_form_mat(Mat,Index,M,N) 
{
	for ( J = 0, L = 0, D = 1; J < N; J++ ) {
		for ( I = L; I < M && !Mat[I][J]; I++ );
		if ( I == M )
			continue;
		Index[L] = J;
		for ( K = 0; K < N; K++ ) {
			T = Mat[I][K]; Mat[I][K] = Mat[L][K]; Mat[L][K] = T;
		}
		for ( I = L + 1, V = Mat[L][J]; I < M; I++ )
			for ( K = J, U = Mat[I][J]; K < N; K++ )
				Mat[I][K] = sdiv(Mat[I][K]*V-Mat[L][K]*U,D);
		D = V; L++;
	}
	for ( I = L; I < M; I++ )
		for ( J = 0; J < N; J++ )
			if ( Mat[I][J] )
				return [-1,0];
	for ( I = L - 2, W = vector(N); I >= 0; I-- ) {
		for ( J = 0; J < N; J++ ) W[J] = 0;
		for ( G = I + 1; G < L; G++ )
			for ( H = Index[G], U = Mat[I][H]; H < N; H++ )
				W[H] += Mat[G][H]*U;
		for ( J = Index[I], U = Mat[I][J]; J < N; J++ )
			Mat[I][J] = sdiv(Mat[I][J]*D-W[J],U);
	}
	return [L,D];
}

def mat_to_col(A)
{
	R = [];
	N = size(A)[0];
	for ( J = N-1; J >= 0; J-- ) {
		T = vector(N);
		for ( I = 0; I < N; I++ )
			T[I] = A[I][J];
		R = cons(T,R);
	}
	return R;
}

def zero_vector(A)
{
	S = size(A);
	M = S[0];
	for ( I = 0; I < M; I++ )
		if ( A[I] ) return 0;
	return 1;
}

def zero_mat(A)
{
	S = size(A);
	M = S[0]; N = S[1];
	for ( I = 0; I < M; I++ )
		for ( J = 0; J < N; J++ )
			if ( A[I][J] ) return 0;
	return 1;
}

def extended_euclid2(F,G)
{
	F1 = F; F2 = G;
	A1 = 1; A2 = 0;
	B1 = 0; B2 = 1;
	while ( 1 ) {
		Q = sdiv(F1,F2);
		F3 = F1-Q*F2;
		if ( !F3 ) {
			return [A2,B2,F2];
		}
		A3 = A1-Q*A2;
		B3 = B1-Q*B2;
		F1 = F2; F2 = F3;
		A1 = A2; A2 = A3;
		B1 = B2; B2 = B3;
	}
}

def extended_euclid(F)
{
	N = size(F)[0];
	G = vector(N);
	GCD = F[N-1];
	G[N-1]=1;
	for ( I = N-2; I >= 0; I-- ) {
		/* G[I+1]*F[I+1]+...+G[N-1]*F[N-1]=GCD */
		/* C[0]*F[I]+C[1]*GCD=C[2] */
		C = extended_euclid2(F[I],GCD);
		if ( C[0]*F[I]+C[1]*GCD-C[2] )
			error("afo");
		/* C[0]*F[I]+C[1]*G[I+1]*F[I+1]+...+C[1]*G[N-1]*F[N-1]=C[2] */
		G[I] = C[0];
		for ( J = I+1; J < N; J++ )
			G[J] *= C[1];
		GCD = C[2];

		for ( K = I, T = 0; K < N; K++ )
			T += G[K]*F[K];
		if ( T != GCD )
			error("bfo");
	}
	return [G,GCD];
}

endmodule$
end$
