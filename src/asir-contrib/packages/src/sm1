/*$OpenXM: OpenXM/src/asir-contrib/packages/src/sm1,v 1.2 1999/12/10 01:58:04 takayama Exp $ */

ord([dx,dy,dz,dt,ds,x,y,z,t,s])$ 
Sm1_proc = -1$

#define SM1_FIND_PROC(P)  P = getopt(proc);\
                          if (type(P) == -1) {\
                             P = sm1_find_proc();\
                          }\

/* Search : oxPrintMessage, see cmoDebugCMO, too. */
/************** end of configure *******************************/
/*&C-texi
@c DO NOT EDIT THIS FILE   oxphc.texi
*/
/*&jp-texi
@node SM1 函数,,, Top
@chapter SM1 函数

この節では sm1 の ox サーバ @code{ox_sm1_forAsir}
とのインタフェース関数を解説する.
これらの関数はファイル  @file{sm1} で定義されている.
@file{sm1} は @file{$(OpenXM_HOME)/lib/asir/contrib/packages/src} にある.
システム @code{sm1} は微分作用素環で計算するためのシステムである.
計算代数幾何のいろいろな不変量の計算が微分作用素の計算に帰着する.
@code{sm1} についての文書は @code{src/kan96xx/Doc} で make することにより
得られる.

@tex
空間
$X:={\bf C} \setminus \{ 0, 1 \} = {\bf C} \setminus V(x(x-1))$
のドラームコホモロジ群達の次元を計算してみよう.
$X$ は平面に二つの穴をあけた空間であるので, 点 $x=0$, $x=1$ のまわりを
まわる二つのループが1次元のホモロジー群の空間をはる.
したがって, 1次元ドラームコホモロジ群の次元は $2$ である.
@code{sm1} は $0$ 次元のコホモロジ群の次元および $1$ 次元のコホモロジ群の
次元を答える.
@end tex
*/
/*&eg-texi
@node SM1 Functions,,, Top
@chapter SM1 Functions

This chapter describes  interface functions for
sm1 ox server @code{ox_sm1_forAsir}.
These interface functions are defined in the file @file{sm1}.
The file @file{sm1} is @*
at @file{$(OpenXM_HOME)/lib/asir/contrib/packages/src}.
The system @code{sm1} is a system to compute in the ring of differential
operators.
Many constructions of invariants 
in the computational algebraic geometry reduce
to constructions in the ring of differential operators.
Documents on @code{sm1} can be obtained by @code{make} in the
directory @code{src/kan96xx/Doc}.

@tex
Let us evaluate the dimensions of the de Rham cohomology groups
of 
$X:={\bf C} \setminus \{ 0, 1 \} = {\bf C} \setminus V(x(x-1))$.
The space $X$ is a two punctured plane, so two loops that encircles the
points $x=0$ and $x=1$ respectively spans the first homology group.
Hence, the dimension of the first de Rham cohomology group is $2$.
@code{sm1} answers the dimensions of the 0th and the first
cohomology groups.
@end tex
*/
/*&C-texi
@example
[155] load("xm");
1
xm Version 19991118. ox_help(0); ox_help("keyword"); for help message 
[255] sm1_start();
0
[256] sm1_deRham(0,[x*(x-1),[x]]);
[1,2]
@end example
*/
/*&C-texi
@noindent
The author of @code{sm1} : Nobuki Takayama, @code{takayama@@math.sci.kobe-u.ac.jp} @*
The author of sm1 packages : Toshinori Oaku, @code{oaku@@twcu.ac.jp} @*
Reference: Saito, M., Sturmfels, B., Takayama, N., 
Grobner Deformations of Hypergeometric Differential Equations,
1999, Springer.
See the appendix.
*/
/*&jp-texi
@section @code{ox_sm1_forAsir} サーバ
*/ 
/*&eg-texi
@section @code{ox_sm1_forAsir} Server
*/ 

/*&eg-texi
@menu
* ox_sm1_forAsir::
@end menu
@node ox_sm1_forAsir,,, Top
@subsection @code{ox_sm1_forAsir}
@findex ox_sm1_forAsir
@table @t
@item ox_sm1_forAsir
::  @code{sm1} server for @code{asir}.
@end table
@itemize @bullet
@item
   @code{ox_sm1_forAsir} is the @code{sm1} server started from asir
    by the command @code{sm1_start}.
    In the standard setting,  @*
    @code{ox_sm1_forAsir} =
         @file{$(OpenXM_HOME)/lib/sm1/bin/ox_sm1}
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1.sm1}   (macro file) @* 
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1b.sm1}  (macro file) @*
   The macro files @file{callsm1.sm1} and @file{callsm1b.sm1} 
   are searched from
   current directory, @code{$(LOAD_SM1_PATH)}, 
   @code{$(OpenXM_HOME)/lib/sm1},
   @code{/usr/local/lib/sm1}
   in this order.
@item Note for programmers:  See the files
    @file{$(OpenXM_HOME)/src/kxx/oxserver00.c},
    @file{$(OpenXM_HOME)/src/kxx/sm1stackmachine.c}
to build your own server by reading @code{sm1} macros.
@end itemize
*/
/*&jp-texi
@menu
* ox_sm1_forAsir::
@end menu
@node ox_sm1_forAsir,,, Top
@subsection @code{ox_sm1_forAsir}
@findex ox_sm1_forAsir
@table @t
@item ox_sm1_forAsir
::  @code{asir} のための @code{sm1} サーバ.
@end table
@itemize @bullet
@item
   サーバ @code{ox_sm1_forAsir} は @code{asir} よりコマンド
    @code{sm1_start} で起動される @code{sm1} サーバである.

    標準的設定では, @*
    @code{ox_sm1_forAsir} =
         @file{$(OpenXM_HOME)/lib/sm1/bin/ox_sm1}
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1.sm1}   (macro file) @* 
       +
         @file{$(OpenXM_HOME)/lib/sm1/callsm1b.sm1}  (macro file) @*
  であり, これらのマクロファイルは, 一般には
   current directory, @code{$(LOAD_SM1_PATH)}, 
   @code{$(OpenXM_HOME)/lib/sm1},
   @code{/usr/local/lib/sm1}
    の順番でさがされる.
@item プログラマーのためのノート: 
@code{sm1} マクロを読み込んで自分独自のサーバを作るには
    次のファイルも見よ
    @file{$(OpenXM_HOME)/src/kxx/oxserver00.c},
    @file{$(OpenXM_HOME)/src/kxx/sm1stackmachine.c}
@end itemize
*/

def sm1_check_server(P) {
  M=ox_get_serverinfo(P);
  if (M == []) {
    return(sm1_start());
  }
  if (M[0][1] != "Ox_system=ox_sm1_ox_sm1_forAsir") {
    print("Warning: the server number ",0)$
    print(P,0)$
    print(" is not ox_sm1_forAsir server.")$
    print("Starting ox_sm1_forAsir server on the localhost.")$
    return(sm1_start());
  }
  return(P);
}

/*&jp-texi
@section 函数一覧
*/ 
/*&eg-texi
@section Functions
*/ 

/*&eg-texi
@menu
* sm1_start::
@end menu
@node sm1_start,,, SM1 Functions
@subsection @code{sm1_start}
@findex sm1_start
@table @t
@item sm1_start()
::  Start  @code{ox_sm1_forAsir} on the localhost.
@end table

@table @var
@item return
Integer
@end table

@itemize @bullet
@item Start @code{ox_sm1_forAsir} on the localhost.
    It returns the descriptor of @code{ox_sm1_forAsir}.
@item Set @code{Xm_nox = 1} to start @code{ox_sm1_forAsir} 
without a debug window.
@item You should set suitable orders of variable by the command
@code{ord}.  For example, 
when you are working in the
ring of differential operators on the variable @code{x} and @code{dx}
(@code{dx} stands for 
@tex $\partial/\partial x$ 
@end tex 
),
@code{sm1} server assumes that
the variable @code{dx} is collected to the right and the variable
@code{x} is collected to the left in the printed expression.
In the example below, you  must not use the variable @code{c}
for computation in @code{sm1}.
@end itemize
*/
/*&jp-texi
@menu
* sm1_start::
@end menu
@node sm1_start,,, SM1 函数
@subsection @code{sm1_start}
@findex sm1_start
@table @t
@item sm1_start()
::  localhost で  @code{ox_sm1_forAsir} をスタートする.
@end table

@table @var
@item return
整数
@end table

@itemize @bullet
@item localhost で @code{ox_sm1_forAsir} をスタートする.
サーバ @code{ox_sm1_forAsir} の識別番号を戻す.
@item @code{Xm_nox = 1} とおくとサーバ @code{ox_sm1_forAsir} をデバッグ用の
ウィンドウなしに起動できる.
@item コマンド @code{ord} を用いて変数順序を正しく設定しておく必要が
ある.
たとえば,
変数 @code{x} と @code{dx} 上の微分作用素環
(@code{dx} は 
@tex $\partial/\partial x$ 
@end tex 
に対応)
で計算しているとき,
@code{sm1} サーバは式を印刷したとき,
変数 @code{dx} は右側に集めれ変数
@code{x} は左側にあつめられていると仮定している.
次の例では, 変数 @code{c} を @code{sm1} での計算のために用いてはいけない.
@end itemize
*/
/*&C-texi
@example
[260] ord([da,a,db,b]);
[da,a,db,b,dx,dy,dz,x,y,z,dt,ds,t,s,u,v,w, 
......... omit ..................
]
[261] a*da;
a*da
[262] c*dc;
dc*c
[263] sm1_mul(0,da,a,[a]);     
a*da+1                  
[264] sm1_mul(0,a,da,[a]);
a*da
@end example
*/
/*&eg-texi
@table @t
@item Reference
    @code{ox_launch}, @code{sm1_push_int0}, @code{sm1_push_poly0},
    @code{ord}
@end table
*/
/*&jp-texi
@table @t
@item 参照
    @code{ox_launch}, @code{sm1_push_int0}, @code{sm1_push_poly0},
    @code{ord}
@end table
*/


def sm1_start() {
 extern Sm1_lib;
 extern Xm_noX;
 extern Sm1_proc;
 if (Xm_noX) {
   P = ox_launch_nox(0,Sm1_lib+"/bin/ox_sm1_forAsir");
 }else{
   P = ox_launch(0,Sm1_lib+"/bin/ox_sm1_forAsir");
 }
 if (Xm_noX) {
   sm1(P," oxNoX ");
 }
 ox_check_errors(P);
 Sm1_proc = P;
 return(P);
}


/*   ox_sm1  */
/* P is the process number */
def sm1flush(P) {
  ox_execute_string(P,"[(flush)] extension pop");
}

def sm1push(P,F) {
  G = ox_ptod(F);
  ox_push_cmo(P,G);  
}

/*&eg-texi
@menu
* sm1::
@end menu
@node sm1,,, SM1 Functions
@subsection @code{sm1}
@findex sm1
@table @t
@item sm1(@var{p},@var{s})
::  ask the @code{sm1} server to execute the command string @var{s}.
@end table

@table @var
@item return
Void
@item p
Number
@item s
String
@end table

@itemize @bullet
@item  It asks the @code{sm1} server of the descriptor number @var{p}
to execute the command string @var{s}.
@end itemize
*/
/*&jp-texi
@menu
* sm1::
@end menu
@node sm1,,, SM1 函数
@subsection @code{sm1}
@findex sm1
@table @t
@item sm1(@var{p},@var{s})
::  サーバ @code{sm1} にコマンド列 @var{s} を実行してくれるようにたのむ.
@end table

@table @var
@item return
なし
@item p
数
@item s
文字列
@end table

@itemize @bullet
@item  識別番号 @var{p} の @code{sm1} サーバに
コマンド列 @var{s} を実行してくれるように頼む.
@end itemize
*/
/*&C-texi
@example
[261] sm1(0," ( (x-1)^2 ) . ");
0
[262] ox_pop_string(0);
x^2-2*x+1
[263] sm1(0," [(x*(x-1))  [(x)]] deRham ");
0
[264] ox_pop_string(0);
[1 , 2]
@end example
*/
def sm1(P,F) {
  ox_execute_string(P,F);
  sm1flush(P);
}
/*&jp-texi
@table @t
@item 参照
    @code{sm1_start}, @code{ox_push_int0}, @code{sm1_push_poly0}. 
@end table
*/
/*&eg-texi
@table @t
@item Reference
    @code{sm1_start}, @code{ox_push_int0}, @code{sm1_push_poly0}. 
@end table
*/

def sm1pop(P) {
  return(ox_pop_cmo(P));
}

def sm1_to_asir_form(V) { return(toAsirForm(V)); }
def toAsirForm(V) {
  extern ToAsirForm_V; /* for debug */
  if (type(V) == 4) { /* list */
    if((length(V) == 3) && (V[0] == "sm1_dp")) {
       /* For debugging. */
       if (ToAsir_Debug != 0) {
         ToAsirForm_V = V;
         print(map(type,V[1]));
         print(V);
       }
       /*  */
       Vlist = map(strtov,V[1]);
       return(dp_dtop(V[2],Vlist));
    } else {
       return(map(toAsirForm,V));
    }
  }else{
    return(V);
  }
}


def sm1_push_poly0_R(A,P,Vlist) {
  return(sm1_push_poly0(P,A,Vlist));
}
def sm1_push_poly0(P,A,Vlist) {
  if (type(Vlist[0]) == 4) {
      Vlist = Vlist[2];   
  }
  /* if Vlist=[[e,x,y,H,E,Dx,Dy,h],[e,x,y,hH,eE,dx,dy,h],[e,x,y,hH,eE,dx,dy,h]]
                list of str (sm1)   list of str (asir)    list of var (asir)
     then we execute the code above.
  */
 if (type(A) == 2 || type(A) == 1) { /* recursive poly  or number*/
   A = dp_ptod(A,Vlist);
   ox_push_cmo(P,A);
   return;
 }
 if (type(A) == 0) { /* zero */
   sm1(P," (0). ");
   return;
 }
 if (type(A) == 4) { /* list */
   ox_execute_string(P," [ ");
   map(sm1_push_poly0_R,A,P,Vlist);
   ox_execute_string(P," ] ");
   return;
 }
 ox_push_cmo(P,A);
 ox_check_errors2(P);
 return;
}
/* sm1_push_poly0(0,[0,1,x+y,["Hello",y^3]],[x,y]); */

def sm1_pop_poly0(P,Vlist) {
  if (type(Vlist[0]) == 4) {
      Vlist = Vlist[2];   
  }
  A = ox_pop_cmo(P);
  return(sm1_pop_poly0_0(P,A,Vlist));
}
def sm1_pop_poly0_0_R(A,P,Vlist) {
  return(sm1_pop_poly0_0(P,A,Vlist));
}
def sm1_pop_poly0_0(P,A,Vlist) {
  if (type(A) == 4) {
    return(map(sm1_pop_poly0_0_R,A,P,Vlist));
  }
  if (type(A)== 9) {return(dp_dtop(A,Vlist));}
  return(A);
}

def sm1_push_int0_R(A,P) {
  return(sm1_push_int0(P,A));
}

/*&eg-texi
@menu
* sm1_push_int0::
@end menu
@node sm1_push_int0,,, SM1 Functions
@subsection @code{sm1_push_int0}
@findex sm1_push_int0
@table @t
@item sm1_push_int0(@var{p},@var{f})
::   push the object @var{f} to the server with the descriptor number @var{p}.
@end table

@table @var
@item return
Void
@item p
Number
@item f
Object
@end table

@itemize @bullet
@item When @code{type(@var{f})} is 2 (recursive polynomial),
    @var{f} is converted to a string (type == 7) 
    and is sent to the server by @code{ox_push_cmo}.
@item When @code{type(@var{f})} is 0 (zero), 
     it is translated to the 32 bit integer zero
    on the server.  
    Note that @code{ox_push_cmo(@var{p},0)} sends @code{CMO_NULL} to the server.
In other words, the server does not get the 32 bit integer 0 nor
the bignum 0.
@item  @code{sm1} integers are classfied into the 32 bit integer and
the bignum.
When @code{type(@var{f})} is 1 (number), it is translated to the
32 bit integer on the server.
Note that @code{ox_push_cmo(@var{p},1234)} send the bignum 1234 to the
@code{sm1} server.
@item In other cases,  @code{ox_push_cmo} is called without data conversion.
@end itemize
*/
/*&jp-texi
@menu
* sm1_push_int0::
@end menu
@node sm1_push_int0,,, SM1 函数
@subsection @code{sm1_push_int0}
@findex sm1_push_int0
@table @t
@item sm1_push_int0(@var{p},@var{f})
::   オブジェクト @var{f} を識別子 @var{p} のサーバへ送る.
@end table

@table @var
@item return
なし
@item p
数
@item f
オブジェクト
@end table

@itemize @bullet
@item @code{type(@var{f})} が 2 (再帰多項式) のとき,
    @var{f} は文字列 (type == 7) に変換されて,
    @code{ox_push_cmo} を用いてサーバへ送られる.
@item @code{type(@var{f})} が 0 (zero) のときは, 
    サーバ上では, 32 bit 整数と解釈される.
    なお @code{ox_push_cmo(P,0)} はサーバに対して @code{CMO_NULL}
をおくるので, サーバ側では, 32 bit 整数を受け取るわけではない.
@item  @code{sm1} の整数は, 32 bit 整数と bignum にわけることができる.
@code{type(@var{f})} が 1 (数)のとき, この関数は 32 bit integer をサーバに
おくる.
@code{ox_push_cmo(@var{p},1234)} は bignum の 1234 を
@code{sm1} サーバにおくることに注意しよう.
@item その他の場合には  @code{ox_push_cmo} をデータ型の変換なしに呼び出す.
@end itemize
*/
/*&C
@example
[219] P=sm1_start();
0
[220] sm1_push_int0(P,x*dx+1);
0
[221] A=ox_pop_cmo(P);
x*dx+1
[223] type(A);
7   (string)
@end example

@example
[271] sm1_push_int0(0,[x*(x-1),[x]]);
0
[272] ox_execute_string(0," deRham ");
0
[273] ox_pop_cmo(0);
[1,2]
@end example
*/
/*&eg-texi
@table @t
@item Reference
    @code{ox_push_cmo}
@end table
*/
/*&jp-texi
@table @t
@item Reference
    @code{ox_push_cmo}
@end table
*/


def sm1_push_int0(P,A) {
 if (type(A) == 1 || type(A) == 0) { 
   /* recursive poly  or number or 0*/
   A = rtostr(A);
   ox_push_cmo(P,A);
   sm1(P," . (integer) dc ");
   return;
 }
 if (type(A) == 2) {
   A = rtostr(A); ox_push_cmo(P,A);
   return;
 }
 if (type(A) == 4) { /* list */
   ox_execute_string(P," [ ");
   map(sm1_push_int0_R,A,P);
   ox_execute_string(P," ] ");
   return;
 }
 ox_push_cmo(P,A);
 return;
}

def sm1_push_0_R(A,P) {
  return(sm1_push_0(P,A));
}
def sm1_push_0(P,A) {
 if (type(A) == 0) { 
   /* 0 */
   A = rtostr(A);
   ox_push_cmo(P,A);
   sm1(P," .. ");
   return;
 }
 if (type(A) == 2) {
   /* Vlist = vars(A); One should check Vlist is a subset of Vlist3. */
   Vlist2 = sm1_vlist(P);
   Vlist3 = map(strtov,Vlist2[1]);
   B = dp_ptod(A,Vlist3);
   ox_push_cmo(P,B);
   return;
 }
 if (type(A) == 4) { /* list */
   ox_execute_string(P," [ ");
   map(sm1_push_0_R,A,P);
   ox_execute_string(P," ] ");
   return;
 }
 ox_push_cmo(P,A);
 return;
}

def sm1_push(P,A) {
  sm1_push_0(P,A);
}


def sm1_pop(P) {
  extern V_sm1_pop;
  sm1(P," toAsirForm ");
  V_sm1_pop = ox_pop_cmo(P);
  return(toAsirForm(V_sm1_pop));
}

def sm1_check_arg_gb(A,Fname) {
  /* A = [[x^2+y^2-1,x*y],[x,y],[[x,-1,y,-1]]] */
  if (type(A) != 4) {
     error(Fname+" : argument should be a list.");
  }
  if (length(A) < 2) {
     error(Fname+" : argument should be a list of 2 or 3 elements.");
  }
  if (type(A[0]) != 4) {
     error(Fname+" : example: [[dx^2+dy^2-4,dx*dy-1]<== it should be a list,[x,y]]");
  }
  if (!sm1_isListOfPoly(A[0])) {
     error(Fname+" : example: [[dx^2+dy^2-4,dx*dy-1]<== it should be a list of polynomials or strings,[x,y]]");
  }
  if (!sm1_isListOfVar(A[1])) {
     error(Fname+" : example: [[dx^2+dy^2-4,dx*dy-1],[x,y]<== list of variables or \"x,y\"]");
  }
  if (length(A) >= 3) {
    if (type(A[2]) != 4) {
      error(Fname+" : example:[[dx^2+dy^2-4,dx*dy-1],[x,y],[[x,-1,dx,1]]<== a list of weights]");
    }
    if (type(A[2][0]) != 4) {
      error(Fname+" : example:[[dx^2+dy^2-4,dx*dy-1],[x,y],[[x,-1,dx,1],[dy,1]]<== a list of lists of weight]");
    }
  }
  return(1);
}

def sm1_isListOfPoly(A) {
  if (type(A) !=4 ) return(0);
  N = length(A);
  for (I=0; I<N; I++) {
    if (!(type(A[I]) == 0 || type(A[I]) == 1 || type(A[I]) == 2 ||
          type(A[I]) == 7 || type(A[I]) == 9)) {
      return(0);
    }
  }
  return(1);
}

def sm1_isListOfVar(A) {
  if (type(A) == 7) return(1); /* "x,y" */
  if (type(A) != 4) return(0);
  N = length(A);
  for (I=0; I<N; I++) {
    if (!(type(A[I]) == 2 ||  type(A[I]) == 7 )) {
      return(0);
    }
  }
  return(1);
}

/*&eg-texi
@menu
* sm1_gb::
@end menu
@node sm1_gb,,, SM1 Functions
@node sm1_gb_d,,, SM1 Functions
@subsection @code{sm1_gb}
@findex sm1_gb
@findex sm1_gb_d
@table @t
@item sm1_gb(@var{p},[@var{f},@var{v},@var{w}])
::  computes the Grobner basis of @var{f} in the ring of differential
operators with the variable @var{v}.
@item sm1_gb_d(@var{p},[@var{f},@var{v},@var{w}])
::  computes the Grobner basis of @var{f} in the ring of differential
operators with the variable @var{v}. 
The result will be returned as a list of distributed polynomials.
@end table

@table @var
@item return
List
@item p
Number
@item f, v, w
List
@end table

@itemize @bullet
@item
   It returns the Grobner basis of the set of polynomials @var{f} 
   in the ring of deferential operators with the variables @var{v}.
@item
   The weight vectors are given by @var{w}, which can be omitted.
    If @var{w} is not given, 
    the graded reverse lexicographic order will be used to compute Grobner basis.   
@item
   The return value of @code{sm1_gb}
    is the list of the Grobner basis of @var{f} and the initial
    terms (when @var{w} is not given) or initial ideal (when @var{w} is given).
@item
   @code{sm1_gb_d} returns the results by a list of distributed polynomials.
    Monomials in each distributed polynomial are ordered in the given order.
    The return value consists of
    [variable names, order matrix, grobner basis in districuted polynomials,
     initial monomials or initial polynomials].
@item
   When a non-term order is given, the Grobner basis is computed in 
   the homogenized Weyl algebra  (See Section 1.2 of the book of SST).
   The homogenization variable h is automatically added.
@end itemize
*/
/*&jp-texi
@menu
* sm1_gb::
@end menu
@node sm1_gb,,, SM1 函数
@node sm1_gb_d,,, SM1 函数
@subsection @code{sm1_gb}
@findex sm1_gb
@findex sm1_gb_d
@table @t
@item sm1_gb(@var{p},[@var{f},@var{v},@var{w}])
::  @var{v} 上の微分作用素環において @var{f} のグレブナ基底を計算する.
@item sm1_gb_d(@var{p},[@var{f},@var{v},@var{w}])
::  @var{v} 上の微分作用素環において @var{f} のグレブナ基底を計算する. 結果を分散多項式のリストで戻す.
@end table

@table @var
@item return
リスト
@item p
数
@item f, v, w
リスト
@end table

@itemize @bullet
@item
   @var{v} 上の微分作用素環において @var{f} のグレブナ基底を計算する.
@item
   Weight ベクトル @var{w} は省略してよい.
   省略した場合, graded reverse lexicographic order をつかって
   ブレブナ基底を計算する.
@item
   @code{sm1_gb} の戻り値は @var{f} のグレブナ基底およびイニシャルモノミアル
  ( @var{w} がないとき ) または イニシァル多項式 ( @var{w} が与えらたとき)
  のリストである.
@item
   @code{sm1_gb_d} は結果を分散多項式のリストで戻す.
    多項式の中に現れるモノミアルはグレブナ基底を計算するときに与えらた順序でソートされている.
   戻り値は
    [変数名のリスト, 順序をきめる行列, グレブナ基底, イニシャルモノミアルまたはイニシァル多項式]
   である.
@item
   Term order でない順序が与えられた場合は, 同次化ワイル代数でグレブナ基底が計算される (SST の本の Section 1.2 を見よ).
同次化変数 @code{h} が結果に加わる.
@end itemize
*/
/*&C-texi
@example
[293] sm1_gb(0,[[x*dx+y*dy-1,x*y*dx*dy-2],[x,y]]);
[[x*dx+y*dy-1,y^2*dy^2+2],[x*dx,y^2*dy^2]]
@end example
*/
/*&eg-texi
In the example above,
@tex the set $\{ x \partial_x + y \partial_y -1,
                 y^2 \partial_y^2+2\}$ 
is the Gr\"obner basis of the input with respect to the 
graded reverse lexicographic order such that
$ 1 \leq \partial_y \leq \partial_x \leq y \leq x \leq \cdots$.
The set $\{x \partial_x, y^2 \partial_y\}$ is the leading monomials
(the initial monominals) of the Gr\"obner basis.
@end tex
*/
/*&jp-texi
上の例において,
@tex 集合 $\{ x \partial_x + y \partial_y -1,
                 y^2 \partial_y^2+2\}$ 
は
$ 1 \leq \partial_y \leq \partial_x \leq y \leq x \leq \cdots$
であるような
graded reverse lexicographic order に関するグレブナ基底である.
集合 $\{x \partial_x, y^2 \partial_y\}$ はグレブナ基底の各元に
対する leading monomial (initial monomial) である.
@end tex
*/
/*&C-texi
@example
[294] sm1_gb(0,[[dx^2+dy^2-4,dx*dy-1],[x,y],[[dx,50,dy,2,x,1]]]);
[[dx+dy^3-4*dy,-dy^4+4*dy^2-1],[dx,-dy^4+4*dy^2-1]]
@end example
*/
/*&eg-texi
In the example above, two monomials 
@tex
$m = x^a y^b \partial_x^c \partial_y^d$ and 
$m' = x^{a'} y^{b'} \partial_x^{c'} \partial_y^{d'}$
are firstly compared by the weight vector 
{\tt (dx,dy,x,y) = (50,2,1,0)}
(i.e., $m$ is larger than $m'$ if $50c+2d+a > 50c'+2d'+a'$)
and when the comparison is tie, then these are 
compared by the reverse lexicographic order
(i.e., if $50c+2d+a = 50c'+2d'+a'$, then use the reverse lexicogrpahic order).
@end tex
*/
/*&jp-texi
上の例において二つのモノミアル
@tex
$m = x^a y^b \partial_x^c \partial_y^d$ および
$m' = x^{a'} y^{b'} \partial_x^{c'} \partial_y^{d'}$
は最初に weight vector
{\tt (dx,dy,x,y) = (50,2,1,0)} を用いて比較される
(つまり $m$ は $50c+2d+a > 50c'+2d'+a'$ のとき
 $m'$ より大きい )
次にこの比較で勝負がつかないときは reverse lexicographic order で比較される
(つまり $50c+2d+a = 50c'+2d'+a'$ のとき reverse lexicographic order で比較
される).
@end tex
*/
/*&C-texi
@example
[595]
   sm1_gb(0,[["dx*(x*dx +y*dy-2)-1","dy*(x*dx + y*dy -2)-1"],
             [x,y],[[dx,1,x,-1],[dy,1]]]);

[[x*dx^2+(y*dy-h^2)*dx-h^3,x*dy*dx+y*dy^2-h^2*dy-h^3,h^3*dx-h^3*dy],
 [x*dx^2+(y*dy-h^2)*dx,x*dy*dx+y*dy^2-h^2*dy-h^3,h^3*dx]]

[596]
   sm1_gb_d(0,[["dx (x dx +y dy-2)-1","dy (x dx + y dy -2)-1"],
             "x,y",[[dx,1,x,-1],[dy,1]]]);
[[[e0,x,y,H,E,dx,dy,h],
 [[0,-1,0,0,0,1,0,0],[0,0,0,0,0,0,1,0],[1,0,0,0,0,0,0,0],
  [0,1,1,1,1,1,1,0],[0,0,0,0,0,0,-1,0],[0,0,0,0,0,-1,0,0],
  [0,0,0,0,-1,0,0,0],[0,0,0,-1,0,0,0,0],[0,0,-1,0,0,0,0,0],
  [0,0,0,0,0,0,0,1]]],
[[(1)*<<0,0,1,0,0,1,1,0>>+(1)*<<0,1,0,0,0,2,0,0>>+(-1)*<<0,0,0,0,0,1,0,2>>+(-1)*
<<0,0,0,0,0,0,0,3>>,(1)*<<0,0,1,0,0,0,2,0>>+(1)*<<0,1,0,0,0,1,1,0>>+(-1)*<<0,0,0
,0,0,0,1,2>>+(-1)*<<0,0,0,0,0,0,0,3>>,(1)*<<0,0,0,0,0,1,0,3>>+(-1)*<<0,0,0,0,0,0
,1,3>>],
 [(1)*<<0,0,1,0,0,1,1,0>>+(1)*<<0,1,0,0,0,2,0,0>>+(-1)*<<0,0,0,0,0,1,0,2>>,(1)*<
<0,0,1,0,0,0,2,0>>+(1)*<<0,1,0,0,0,1,1,0>>+(-1)*<<0,0,0,0,0,0,1,2>>+(-1)*<<0,0,0
,0,0,0,0,3>>,(1)*<<0,0,0,0,0,1,0,3>>]]]
@end example
*/

def sm1_gb(P,A) {
  P = sm1_check_server(P);
  sm1_check_arg_gb(A,"Error in sm1_gb");
  sm1_push_int0(P,A);
  sm1(P," gb ");
  return(sm1_pop(P));
}
def sm1_gb_d(P,A) {
  P = sm1_check_server(P);
  sm1_check_arg_gb(A,"Error in sm1_gb_d");
  sm1_push_int0(P,A);
  sm1(P," gb /gb.tmp1 set ");
  sm1(P," gb.tmp1 getOrderMatrix {{(universalNumber) dc} map } map /gb.tmp2 set ");
  sm1(P," gb.tmp1 0 get 0 get getvNamesCR { [(class) (indeterminate)] dc } map /gb.tmp3 set ");
  sm1(P," gb.tmp1 getRing ring_def "); /* Change the current ring! */
  sm1(P,"[[ gb.tmp3 gb.tmp2] gb.tmp1] ");
  return(ox_pop_cmo(P));
}
def sm1_pgb(P,A) {
  P = sm1_check_server(P);
  sm1_check_arg_gb(A,"Error in sm1_pgb");
  sm1(P," set_timer ");
  sm1_push_int0(P,A);
  sm1(P," pgb ");
  B = sm1_pop(P);
  sm1(P," set_timer ");
  return(B);
}

/*&eg-texi
@menu
* sm1_deRham::
@end menu
@node sm1_deRham,,, SM1 Functions
@subsection @code{sm1_deRham}
@findex sm1_deRham
@table @t
@item sm1_deRham(@var{p},[@var{f},@var{v}])
::  ask the server to evaluate the dimensions of the de Rham cohomology  groups
of C^n - (the zero set of @var{f}=0).
@end table

@table @var
@item return
List
@item p
Number
@item f
String or polynomial
@item v
List
@end table

@itemize @bullet
@item  It returns the dimensions of the de Rham cohomology groups
    of X = C^n \ V(@var{f}).
   In other words,  it returns
      [dim H^0(X,C), dim H^1(X,C), dim H^2(X,C), ..., dim H^n(X,C)].
@item   @var{v} is a list of variables. n = @code{length(@var{v})}.
@item
   @code{sm1_deRham} requires huge computer resources.
    For example, @code{sm1_deRham(0,[x*y*z*(x+y+z-1)*(x-y),[x,y,z]])}
    is already very hard.
@item
 To efficiently analyze the roots of b-function, @code{ox_asir} should be used 
  from @code{ox_sm1_forAsir}.
    It is recommended to load the communication module for @code{ox_asir}
    by the command @*
   @code{sm1(0,"[(parse) (oxasir.sm1) pushfile] extension");}
@end itemize
*/
/*&jp-texi
@c template1.texi
@menu
* sm1_deRham::
@end menu
@node sm1_deRham,,, SM1 函数
@subsection @code{sm1_deRham}
@findex sm1_deRham
@table @t
@item sm1_deRham(@var{p},[@var{f},@var{v}])
::  空間 C^n - (the zero set of @var{f}=0) のドラームコホモロジ群の次元を計算してくれるようにサーバに頼む.
@end table

@table @var
@item return
リスト
@item p
数
@item f
文字列 または 多項式
@item v
リスト
@end table

@itemize @bullet
@item この函数は空間 X = C^n \ V(@var{f}) のドラームコホモロジ群の次元を計算する.
   すなわち,
   [dim H^0(X,C), dim H^1(X,C), dim H^2(X,C), ..., dim H^n(X,C)]
   を戻す.
@item   @var{v} は変数のリスト. n = @code{length(@var{v})} である.
@item
   @code{sm1_deRham} は計算機の資源を大量に使用する.
    たとえば @code{sm1_deRham(0,[x*y*z*(x+y+z-1)*(x-y),[x,y,z]])}
   の計算すらすでに非常に大変である.
@item
  b-関数の根を効率よく解析するには, @code{ox_asir} が @code{ox_sm1_forAsir}
  より使用されるべきである.  コマンド @*
   @code{sm1(0,"[(parse) (oxasir.sm1) pushfile] extension");}
   を用いて, @code{ox_asir} との通信モジュールをあらかじめロードしておくことをおすすめする.
@end itemize
*/
/*&C-texi
@example
[332] sm1_deRham(0,[x^3-y^2,[x,y]]);
[1,1,0]
[333] sm1_deRham(0,[x*(x-1),[x]]);
[1,2]
@end example
*/
/*&eg-texi
@table @t
@item Reference
    @code{sm1_start}, @code{deRham} (sm1 command)
@item Reference paper
    Oaku, Takayama, An algorithm for de Rham cohomology groups of the
    complement of an affine variety via D-module computation, 
    Journal of pure and applied algebra 139 (1999), 201--233.
@end table
*/
/*&jp-texi
@table @t
@item 参照
    @code{sm1_start}, @code{deRham} (sm1 command)
@item 参考論文
    Oaku, Takayama, An algorithm for de Rham cohomology groups of the
    complement of an affine variety via D-module computation, 
    Journal of pure and applied algebra 139 (1999), 201--233.
@end table
*/


def sm1_deRham(P,A) {
  P = sm1_check_server(P);
  sm1(P," set_timer ");
  sm1_push_int0(P,A);
  sm1(P," deRham ");
  B = sm1_pop(P);
  sm1(P," set_timer ");
  ox_check_errors2(P);
  return(B);
}

def sm1_vlist(P) {
  sm1(P," getvNamesC ");
  B=ox_pop_cmo(P);
  sm1(P," getvNamesC toAsirVar ");
  C=ox_pop_cmo(P);
  return([B,C,map(strtov,C)]);
}
/* [ sm1 names(string), asir names(string),  asir names(var)] */
/* Vlist = sm1_vlist(P);
   sm1_push_poly0( x + 20*x, Vlist[2]); 
   sm1_pop_poly0(Vlist[2]);
*/

def sm1_demo1() {
 print("sm1_ringD(P,V,W), sm1_gb0(P,L), sm1_expand(P,F), sm1_mul(P,F,G), ")$
 print("sm1_dehomogenize(P,A), sm1_homogenize(P,A), sm1_groebner(P,A), ")$
 print("sm1_reduction(P,F,G), sm1_reduction_noH(P,F,G), ")$
 print("sm1_wbf(P,[F,V,W], sm1_wbfRoots(P,[F,V,W], ")$
}
/* ring of Differential operators */
def sm1_ringD(P,V,W) {
  sm1(P," [ ");
  if (type(V) == 7) { /* string */
    ox_push_cmo(P,V);
  }else  if (type(V) == 4) {/* list */
    V = map(rtostr,V);
    ox_push_cmo(P,V);
    sm1(P," from_records ");
  }else { printf("Error: sm1_ringD"); return(-1); }
  sm1(P," ring_of_differential_operators ");
  if (type(W) != 0) {
    sm1_push_int0(P,W);  sm1(P," weight_vector ");
  }
  sm1(P," pstack ");
  sm1(P," 0 ] define_ring getOrderMatrix {{(universalNumber) dc}map}map ");
  ox_check_errors2(P);
  M = ox_pop_cmo(P);
  return([sm1_vlist(P)[2],M]);
}    

def sm1_expand_d(P,F) {
  ox_push_cmo(P,F);
  sm1(P, " expand ");
  return(ox_pop_cmo(P));
}  

def sm1_mul_d(P,A,B) {
  ox_push_cmo(P,A);
  ox_push_cmo(P,B);
  sm1(P," mul ");
  return(ox_pop_cmo(P));
}

def sm1_dehomogenize_d(P,A) {
  ox_push_cmo(P,A);
  sm1(P," dehomogenize ");
  return(ox_pop_cmo(P));
}

def sm1_homogenize_d(P,A) {
  ox_push_cmo(P,A);
  sm1(P," homogenize ");
  return(ox_pop_cmo(P));
}

def sm1_groebner_d(P,A) {
  ox_push_cmo(P,A);
  sm1(P," groebner ");
  return(ox_pop_cmo(P));
}

def sm1_reduction_d(P,F,G) {
  ox_push_cmo(P,F);
  ox_push_cmo(P,G);
  sm1(P," reduction ");
  return(ox_pop_cmo(P));
}

def sm1_reduction_noH_d(P,F,G) {
  ox_push_cmo(P,F);
  ox_push_cmo(P,G);
  sm1(P," reduction-noH ");
  return(ox_pop_cmo(P));
}


/*&eg-texi
@c template1.texi
@menu
* sm1_hilbert::
@end menu
@node sm1_hilbert,,, SM1 Functions
@subsection @code{sm1_hilbert}
@findex sm1_hilbert
@table @t
@item sm1_hilbert(@var{p},[@var{f},@var{v}])
::  ask the server to compute the Hilbert polynomial for the set of polynomials @var{f}.
@end table

@table @var
@item return
Polynomial
@item p
Number
@item f, v
List
@end table

@itemize @bullet
@item  It returns the Hilbert polynomial h(k) of the set of polynomials 
    @var{f}
    with respect to the set of variables @var{v}.
@item
    h(k) = dim_Q F_k/I \cap F_k  where F_k the set of polynomials of which
    degree is less than or equal to k and I is the ideal generated by the
    set of polynomials @var{f}.
@item
   For an efficient computation, it is preferable that 
   the set of polynomials @var{f} is a set of monomials.
   In fact, this function firstly compute a Grobner basis of @var{f}, and then
   compute the Hilbert polynomial of the initial monomials of the basis. 
   If the input @var{f} is already a Grobner
   basis, a Grobner basis is recomputed in this function, 
   which is a waste of time and Grobner basis computation in the ring of
   polynomials in @code{sm1} is  slower than in @code{asir}.
@end itemize
*/
/*&jp-texi
@c template1.texi
@menu
* sm1_hilbert::
@end menu
@node sm1_hilbert,,, SM1 函数
@subsection @code{sm1_hilbert}
@findex sm1_hilbert
@table @t
@item sm1_hilbert(@var{p},[@var{f},@var{v}])
:: 多項式の集合 @var{f} のヒルベルト多項式を計算する.
@end table

@table @var
@item return
多項式
@item p
数
@item f, v
リスト
@end table

@itemize @bullet
@item  多項式の集合 @var{f} の変数 @var{v} にかんするヒルベルト多項式 h(k)
   を計算する.
@item
    h(k) = dim_Q F_k/I \cap F_k  ここで F_k は次数が k 以下であるような
    多項式の集合である. I は多項式の集合 @var{f} で生成されるイデアルである.
@item
   効率よく計算するには @var{f} はモノミアルの集合にした方がいい.
   実際, この函数はまず @var{f} のグレブナ基底を計算し, それからその initial 
   monomial 達のヒルベルト多項式を計算する. 
  したがって, 入力 @var{f} がすでにグレブナ基底だとこの函数のなかでもう一度
   グレブナ基底の計算がおこなわれる. これは時間の無駄であるし, @code{sm1} の
  多項式グレブナ基底計算は @code{asir} より遅い.
@end itemize
*/

/*&C-texi
@example
[279] load("katsura")$
[280] A=gr(katsura(5),[u0,u1,u2,u3,u4,u5],0)$
[281] dp_ord();
0
[282] B=map(dp_ht,map(dp_ptod,A,[u0,u1,u2,u3,u4,u5]));
[(1)*<<1,0,0,0,0,0>>,(1)*<<0,0,0,2,0,0>>,(1)*<<0,0,1,1,0,0>>,(1)*<<0,0,2,0,0,0>>,
 (1)*<<0,1,1,0,0,0>>,(1)*<<0,2,0,0,0,0>>,(1)*<<0,0,0,1,1,1>>,(1)*<<0,0,0,1,2,0>>,
 (1)*<<0,0,1,0,2,0>>,(1)*<<0,1,0,0,2,0>>,(1)*<<0,1,0,1,1,0>>,(1)*<<0,0,0,0,2,2>>,
  (1)*<<0,0,1,0,1,2>>,(1)*<<0,1,0,0,1,2>>,(1)*<<0,1,0,1,0,2>>,(1)*<<0,0,0,0,3,1>>,
  (1)*<<0,0,0,0,4,0>>,(1)*<<0,0,0,0,1,4>>,(1)*<<0,0,0,1,0,4>>,(1)*<<0,0,1,0,0,4>>,
 (1)*<<0,1,0,0,0,4>>,(1)*<<0,0,0,0,0,6>>]
[283] C=map(dp_dtop,B,[u0,u1,u2,u3,u4,u5]);
[u0,u3^2,u3*u2,u2^2,u2*u1,u1^2,u5*u4*u3,u4^2*u3,u4^2*u2,u4^2*u1,u4*u3*u1,
 u5^2*u4^2,u5^2*u4*u2,u5^2*u4*u1,u5^2*u3*u1,u5*u4^3,u4^4,u5^4*u4,u5^4*u3,
 u5^4*u2,u5^4*u1,u5^6]
[284] sm1_start();
0
[285] sm1_hilbert(0,[C,[u0,u1,u2,u3,u4,u5]]);
32
@end example
*/

/*&eg-texi
@table @t
@item Reference
    @code{sm1_start}, @code{sm1_gb}
@end table
*/
/*&jp-texi
@table @t
@item 参照
    @code{sm1_start}, @code{sm1_gb}
@end table
*/

def sm1_hilbert(P,A) {
  P = sm1_check_server(P);
  sm1(P,"[ ");
  sm1_push_int0(P,A[0]);
  sm1_push_int0(P,A[1]);
  sm1(P," ] pgb /sm1_hilbert.gb set ");
  sm1(P," sm1_hilbert.gb 0 get { init toString } map ");
  sm1_push_int0(P,A[1]);
  sm1(P, " hilbert ");
  B = sm1_pop(P);
  return(B[1]/fac(B[0]));
}

/*&eg-texi
@menu
* sm1_genericAnn::
@end menu
@node sm1_genericAnn,,, SM1 Functions
@subsection @code{sm1_genericAnn}
@findex sm1_genericAnn
@table @t
@item sm1_genericAnn(@var{p},[@var{f},@var{v}])
::  It computes  the annihilating ideal for @var{f}^s.
    @var{v} is the list of variables.  Here, s is @var{v}[0] and
    @var{f} is a polynomial in the variables @code{rest}(@var{v}).
@end table

@table @var
@item return
List
@item p
Number
@item f
Polynomial
@item v
List
@end table

@itemize @bullet
@item  This function computes  the annihilating ideal for @var{f}^s.
    @var{v} is the list of variables.  Here, s is @var{v}[0] and
    @var{f} is a polynomial in the variables @code{rest}(@var{v}).
@end itemize
*/
/*&jp-texi
@menu
* sm1_genericAnn::
@end menu
@node sm1_genericAnn,,, SM1 函数
@subsection @code{sm1_genericAnn}
@findex sm1_genericAnn
@table @t
@item sm1_genericAnn(@var{p},[@var{f},@var{v}])
::  @var{f}^s のみたす微分方程式全体をもとめる.
    @var{v} は変数のリストである.  ここで, s は @var{v}[0] であり,
    @var{f} は変数 @code{rest}(@var{v}) 上の多項式である.
@end table

@table @var
@item return
リスト
@item p
数
@item f
多項式
@item v
リスト
@end table

@itemize @bullet
@item この函数は,
  @var{f}^s のみたす微分方程式全体をもとめる.
    @var{v} は変数のリストである.  ここで, s は @var{v}[0] であり,
    @var{f} は変数 @code{rest}(@var{v}) 上の多項式である.
@end itemize
*/
/*&C-texi
@example
[595] sm1_genericAnn(0,[x^3+y^3+z^3,[s,x,y,z]]);
[-x*dx-y*dy-z*dz+3*s,z^2*dy-y^2*dz,z^2*dx-x^2*dz,y^2*dx-x^2*dy]
@end example
*/
/*&eg-texi
@table @t
@item Reference
    @code{sm1_start}
@end table
*/
/*&jp-texi
@table @t
@item 参照
    @code{sm1_start}
@end table
*/


def sm1_genericAnn(P,F) {
  sm1_push_int0(P,F[0]);
  sm1_push_int0(P,F[1]);
  sm1(P, " genericAnn ");
  B = sm1_pop(P);
  return(B);
}

def sm1_tensor0(P,F) {
  sm1_push_int0(P,F);
  sm1(P, " tensor0 ");
  B = sm1_pop(P);
  return(B);
}

/*&eg-texi
@menu
* sm1_wTensor0::
@end menu
@node sm1_wTensor0,,, SM1 Functions
@subsection @code{sm1_wTensor0}
@findex sm1_wTensor0
@table @t
@item sm1_wTensor0(@var{p},[@var{f},@var{g},@var{v},@var{w}])
::   It computes the D-module theoretic 0-th tensor product
    of @var{f} and @var{g}.
@end table

@table @var
@item return
List
@item p
Number
@item f, g, v, w
List
@end table

@itemize @bullet
@item 
   It returns the D-module theoretic 0-th tensor product
   of @var{f} and @var{g}.
@item
  @var{v} is a list of variables.
  @var{w} is a list of weights.  The integer @var{w}[i] is
  the weight of the variable @var{v}[i].
@item 
   @code{sm1_wTensor0} calls @code{wRestriction0} of @code{ox_sm1}, 
   which requires a generic weight
    vector @var{w} to compute the restriction.
    If @var{w} is not generic, the computation fails.
@item Let F and G be solutions of @var{f} and @var{g} respectively.
Intuitively speaking, the 0-th tensor product is a system of
differential equations which annihilates the function FG.
@item The answer is a submodule of a free module D^r in general even if
the inputs @var{f} and @var{g} are left ideals of D.
@end itemize
*/

/*&jp-texi
@menu
* sm1_wTensor0::
@end menu
@node sm1_wTensor0,,, SM1 函数
@subsection @code{sm1_wTensor0}
@findex sm1_wTensor0
@table @t
@item sm1_wTensor0(@var{p},[@var{f},@var{g},@var{v},@var{w}])
::   @var{f} と @var{g} の D-module としての 0 次テンソル積を
計算する.
@end table

@table @var
@item return
リスト
@item p
数
@item f, g, v, w
リスト
@end table

@itemize @bullet
@item 
   @var{f} と @var{g} の
   D-加群としての 0 次テンソル積を計算する.
@item
  @var{v} は変数のリストである.
  @var{w} は weight のリストである.  
  整数 @var{w}[i] は変数 @var{v}[i] の weight である.
@item 
   @code{sm1_wTensor0} は @code{ox_sm1} の @code{wRestriction0}
   をよんでいる.
  @code{wRestriction0} は, generic な weight ベクトル @var{w}
  をもとにして制限を計算している.
  Weight ベクトル @var{w} が generic でないと計算がエラーで停止する.
@item F および G を @var{f} と  @var{g} それぞれの解とする.
直観的にいえば, 0 次のテンソル積は 関数 FG のみたす微分方程式系である.
@item 入力 @var{f}, @var{g} が D の左イデアルであっても,
一般に, 出力は自由加群 D^r の部分加群である.
@end itemize
*/
/*&C-texi
@example
[258]  sm1_wTensor0(0,[[x*dx -1, y*dy -4],[dx+dy,dx-dy^2],[x,y],[1,2]]);
[[-y*x*dx-y*x*dy+4*x+y],[5*x*dx^2+5*x*dx+2*y*dy^2+(-2*y-6)*dy+3],
 [-25*x*dx+(-5*y*x-2*y^2)*dy^2+((5*y+15)*x+2*y^2+16*y)*dy-20*x-8*y-15],
 [y^2*dy^2+(-y^2-8*y)*dy+4*y+20]]
@end example
*/


def sm1_wTensor0(P,F) {
  sm1_push_int0(P,F);
  sm1(P, " wTensor0 ");
  B = sm1_pop(P);
  return(B);
}


def sm1_find_proc() {
  extern Sm1_proc;
  if (Sm1_proc == -1) {
     A = ox_get_serverinfo();
     /* Look for ox_sm1. Not yet written */
     /* Start sm1 automatically if there is not ox_sm1 */
     Sm1_proc = sm1_start();
  }
  return(Sm1_proc);
}

/*&eg-texi
@menu
* sm1_reduction::
@end menu
@node sm1_reduction,,, SM1 Functions
@subsection @code{sm1_reduction}
@findex sm1_reduction
@table @t
@item sm1_reduction([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
::  
@end table

@table @var
@item return
List
@item f
Polynomial
@item g, v, w
List
@item p
Number  (the process number of ox_sm1)
@end table

@itemize @bullet
@item  It reduces @var{f} by the set of polynomial @var{g}
in the homogenized Weyl algebra; it applies the
division algorithm to @var{f}. The set of variables is @var{v} and
@var{w} is weight vectors to determine the order, which can be ommited.
@item The return value is of the form
[r,c0,[c1,...,cm],[g1,...gm]] where @var{g}=[g1, ..., gm] and
r/c0 + c1 g1 + ... + cm gm = 0.
r/c0 is the normal form.
@item The function reduction reduces reducible terms that appear
in lower order terms.
@item  The functions 
sm1_reduction_d(P,F,G) and sm1_reduction_noH_d(P,F,G)
are for distributed polynomials.
@end itemize
*/
/*&jp-texi
@menu
* sm1_reduction::
@end menu
@node sm1_reduction,,, SM1 函数
@subsection @code{sm1_reduction}
@findex sm1_reduction
@table @t
@item sm1_reduction([@var{f},@var{g},@var{v},@var{w}]|proc=@var{p})
::  
@end table

@table @var
@item return
リスト
@item f
多項式
@item g, v, w
リスト
@item p
数  (ox_sm1 のプロセス番号)
@end table

@itemize @bullet
@item  この函数は @var{f} を homogenized ワイル代数において,
多項式集合 @var{g} で簡単化 (reduce) する; つまり,
この函数は, @var{f} に割算アルゴリズムを適用する.
変数集合は @var{v} で指定する.
@var{w} は順序を指定するための ウエイトベクトルであり,
省略してもよい.
@item 戻り値は次の形をしている:
[r,c0,[c1,...,cm],[g1,...gm]] ここで @var{g}=[g1, ..., gm] であり,
r/c0 + c1 g1 + ... + cm gm = 0
がなりたつ.
r/c0 が normal form である.
@item この函数は, 低次項にあらわれる reducible な項も簡単化する.
@item  函数
sm1_reduction_d(P,F,G) および sm1_reduction_noH_d(P,F,G)
は, 分散多項式用である.
@end itemize
*/
/*&C-texi
@example
[259] sm1_reduction([x^2+y^2-4,[y^4-4*y^2+1,x+y^3-4*y],[x,y]]);
[x^2+y^2-4,1,[0,0],[x+y^3-4*y,y^4-4*y^2+1]]
[260] sm1_reduction([x^2+y^2-4,[y^4-4*y^2+1,x+y^3-4*y],[x,y],[[x,1]]]);
[0,1,[-y^2+4,-x+y^3-4*y],[x+y^3-4*y,y^4-4*y^2+1]]
@end example
*/
/*&eg-texi
@table @t
@item Reference
    @code{sm1_start}, @code{sm1_find_proc}, @code{d_true_nf}
@end table
*/
/*&jp-texi
@table @t
@item 参照
    @code{sm1_start}, @code{sm1_find_proc}, @code{d_true_nf}
@end table
*/

def sm1_reduction(A) {
  /* Example: sm1_reduction(A|proc=10) */
  SM1_FIND_PROC(P);
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_reduction(A|proc=p): A must be a list.");
  }
  sm1(P," /reduction*.noH 0 def ");
  sm1_push_int0(P,A);
  sm1(P," reduction* ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}



def sm1_wbf(P,A) {
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_wbf(P,A): A must be a list.");
  }
  if (length(A) != 3) {
   error("sm1_wbf(P,A): A must be a list of the length 3.");
  }
  if (type(A[0]) != 4 || type(A[1]) != 4 || type(A[2]) != 4) {
   error("sm1_wbf(P,[A,B,C]): A, B, C must be a list.");
  }
  if (! (type(A[2][0]) == 7 || type(A[2][0]) == 2)) {
   error("sm1_wbf(P,[A,B,C]): C must be of a form [v-name, v-weight, ...]");
  }
  sm1_push_int0(P,A);
  sm1(P," wbf ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}
def sm1_wbfRoots(P,A) {
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_wbfRoots(P,A): A must be a list.");
  }
  if (length(A) != 3) {
   error("sm1_wbfRoots(P,A): A must be a list of the length 3.");
  }
  if (type(A[0]) != 4 || type(A[1]) != 4 || type(A[2]) != 4) {
   error("sm1_wbfRoots(P,[A,B,C]): A, B, C must be a list.");
  }
  if (! (type(A[2][0]) == 7 || type(A[2][0]) == 2)) {
   error("sm1_wbfRoots(P,[A,B,C]): C must be of a form [v-name, v-weight, ...]");
  }
  sm1_push_int0(P,A);
  sm1(P," wbfRoots ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_res_div(P,A) {
  sm1_push_int0(P,[[A[0],A[1]],A[2]]);
  sm1(P," res*div ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_syz(P,A) {
  sm1_push_int0(P,A);
  sm1(P," syz ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_res_solv(P,A) {
  sm1_push_int0(P,[[A[0],A[1]],A[2]]);
  sm1(P," res*solv ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_res_solv_h(P,A) {
  sm1_push_int0(P,[[A[0],A[1]],A[2]]);
  sm1(P," res*solv*h ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_mul(P,A,B,V) {
  sm1_push_int0(P,[[A,B],V]);
  sm1(P," res*mul ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}
 
def sm1_mul_h(P,A,B,V) {
  sm1_push_int0(P,[[A,B],V]);
  sm1(P," res*mul*h ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_adjoint(P,A,V) {
  sm1_push_int0(P,[A,V]);
  sm1(P," res*adjoint ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}
 
def transpose(A) {
  if (type(A) == 4) {
    N = length(A); M = length(A[0]);
    B = newmat(N,M,A);
    C = newmat(M,N);
    for (I=0; I<N; I++) {
      for (J=0; J<M; J++) {
        C[J][I] = B[I][J];
      }
    }
    D = newvect(M);
    for (J=0; J<M; J++) {
      D[J] = C[J];
    }
    return(map(vtol,vtol(D)));
  }else{
    print(A)$
    error("tranpose: traspose for this argument has not been implemented.");
  }
}

def sm1_resol1(P,A) {
  sm1_push_int0(P,A);
  sm1(P," res*resol1 ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_gcd_aux(A,B) {
  if (type(A) == 1 && type(B) == 1) return(igcd(A,B));
  else return(gcd(A,B));
}

def sm1_lcm_aux(V) {  /* sm1_lcm_aux([3,5,6]); */
  N = length(V);
  if (N == 0) return(0);
  if (N == 1) return(V[0]);
  L = V[0];
  for (I=1; I<N; I++) {
    L = red(L*V[I]/sm1_gcd_aux(L,V[I]));
  } 
  return(L);
}

def sm1_mul_v(V,S) {
  if (type(V) == 4) {
    return(map(sm1_mul_v,V,S));
  } else {
    return(V*S);
  }
}

def sm1_div_v(V,S) {
  if (type(V) == 4) {
    return(map(sm1_div_v,V,S));
  } else {
    return(V/S);
  }
}


def sm1_rat_to_p_aux(T) {  /* cf. sm1_rat2plist2 */
  T = red(T);
  T1 = nm(T); T1a = ptozp(T1); 
  T1b = red(T1a/T1);
  T2 = dn(T); 
  return([T1a*dn(T1b),T2*nm(T1b)]);
}

def sm1_denom_aux0(A) {
  return(A[1]);
}
def sm1_num_aux0(P) {
  return(P[0]);
}

def sm1_rat_to_p(T) {
  if (type(T) == 4) {
     A = map(sm1_rat_to_p,T);
     D = map(sm1_denom_aux0,A);
     N = map(sm1_num_aux0,A);
     L = sm1_lcm_aux(D); 
     B = newvect(length(N));
     for (I=0; I<length(N); I++) {
       B[I] = sm1_mul_v(N[I],L/D[I]);
     }
     return([vtol(B),L]);
  }else{
     return(sm1_rat_to_p_aux(T));
  }
}


end$

