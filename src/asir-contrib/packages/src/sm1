/*$OpenXM: OpenXM/src/asir-contrib/packages/src/sm1,v 1.28 2001/07/10 13:41:27 takayama Exp $ */

Sm1_ord_list = [ dz20, dz19, dz18, dz17, dz16, dz15, dz14, dz13, dz12, dz11, dz10, dz9, dz8, dz7, dz6, dz5, dz4, dz3, dz2, dz1, dz0, dy20, dy19, dy18, dy17, dy16, dy15, dy14, dy13, dy12, dy11, dy10, dy9, dy8, dy7, dy6, dy5, dy4, dy3, dy2, dy1, dy0, dx20, dx19, dx18, dx17, dx16, dx15, dx14, dx13, dx12, dx11, dx10, dx9, dx8, dx7, dx6, dx5, dx4, dx3, dx2, dx1, dx0, 
dz, dy, dx, dw, dv, du, dt, ds, dr, dq, dp, dn, dm, dl, dk, dj, di, dh, dg, df, de, dc, db, da, 
z20, z19, z18, z17, z16, z15, z14, z13, z12, z11, z10, z9, z8, z7, z6, z5, z4, z3, z2, z1, z0, y20, y19, y18, y17, y16, y15, y14, y13, y12, y11, y10, y9, y8, y7, y6, y5, y4, y3, y2, y1, y0, x20, x19, x18, x17, x16, x15, x14, x13, x12, x11, x10, x9, x8, x7, x6, x5, x4, x3, x2, x1, x0, 
z, y, x, w, v, u, t, s, r, q, p, n, m, l, k, j, i, h, g, f, e, c, b, a, 
 hoge ]$

ord(Sm1_ord_list)$
Sm1_proc = -1$

#define SM1_FIND_PROC(P)  P = getopt(proc);\
                          if (type(P) == -1) {\
                             P = sm1_find_proc();\
                          }

def sm1_find_proc() {
  extern Sm1_proc;
  if (Sm1_proc == -1) {
     A = ox_get_serverinfo();
     /* Look for ox_sm1. Not yet written */
     /* Start sm1 automatically if there is not ox_sm1 */
     Sm1_proc = sm1_start();
  }
  return(Sm1_proc);
}
/* Search : oxPrintMessage, see cmoDebugCMO, too. */
/************** end of configure *******************************/

def sm1_check_server(P) {
  M=ox_get_serverinfo(P);
  if (M == []) {
    return(sm1_start());
  }
  if (M[0][1] != "Ox_system=ox_sm1_ox_sm1_forAsir") {
    print("Warning: the server number ",0)$
    print(P,0)$
    print(" is not ox_sm1_forAsir server.")$
    print("Starting ox_sm1_forAsir server on the localhost.")$
    return(sm1_start());
  }
  return(P);
}



def sm1_start() {
 extern Sm1_lib;
 extern Xm_noX;
 extern Sm1_proc;
 if (Xm_noX) {
   P = ox_launch_nox(0,Sm1_lib+"/bin/ox_sm1_forAsir");
 }else{
   P = ox_launch(0,Sm1_lib+"/bin/ox_sm1_forAsir");
 }
 if (Xm_noX) {
   sm1(P," oxNoX ");
 }
 ox_check_errors(P);
 Sm1_proc = P;
 return(P);
}


/*   ox_sm1  */
/* P is the process number */
def sm1flush(P) {
  ox_execute_string(P,"[(flush)] extension pop");
}

def sm1push(P,F) {
  G = ox_ptod(F);
  ox_push_cmo(P,G);  
}

def sm1(P,F) {
  ox_execute_string(P,F);
  sm1flush(P);
}


def sm1pop(P) {
  return(ox_pop_cmo(P));
}

def sm1_to_asir_form(V) { return(toAsirForm(V)); }
def toAsirForm(V) {
  extern ToAsirForm_V; /* for debug */
  if (type(V) == 4) { /* list */
    if((length(V) == 3) && (V[0] == "sm1_dp")) {
       /* For debugging. */
       if (ToAsir_Debug != 0) {
         ToAsirForm_V = V;
         print(map(type,V[1]));
         print(V);
       }
       /*  */
       Vlist = map(strtov,V[1]);
       return(dp_dtop(V[2],Vlist));
    } else {
       return(map(toAsirForm,V));
    }
  }else{
    return(V);
  }
}

def sm1_toOrdered(V) {
  if (type(V) == 4) { /* list */
    if((length(V) == 3) && (V[0] == "sm1_dp")) {
       Vlist = map(strtov,V[1]);
       Ans = "";
       F = V[2];
       while (F != 0) {
          G = dp_hm(F);
          F = dp_rest(F);
          if (dp_hc(G)>0) {
            Ans += "+";
          }
          Ans += rtostr(dp_dtop(G,Vlist));
       }
       return Ans; 
    } else {
       return(map(sm1_toOrdered,V));
    }
  }else{
    return(V);
  }
}


def sm1_push_poly0_R(A,P,Vlist) {
  return(sm1_push_poly0(P,A,Vlist));
}
def sm1_push_poly0(P,A,Vlist) {
  if (type(Vlist[0]) == 4) {
      Vlist = Vlist[2];   
  }
  /* if Vlist=[[e,x,y,H,E,Dx,Dy,h],[e,x,y,hH,eE,dx,dy,h],[e,x,y,hH,eE,dx,dy,h]]
                list of str (sm1)   list of str (asir)    list of var (asir)
     then we execute the code above.
  */
 if (type(A) == 2 || type(A) == 1) { /* recursive poly  or number*/
   A = dp_ptod(A,Vlist);
   ox_push_cmo(P,A);
   return;
 }
 if (type(A) == 0) { /* zero */
   sm1(P," (0). ");
   return;
 }
 if (type(A) == 4) { /* list */
   ox_execute_string(P," [ ");
   map(sm1_push_poly0_R,A,P,Vlist);
   ox_execute_string(P," ] ");
   return;
 }
 ox_push_cmo(P,A);
 ox_check_errors2(P);
 return;
}
/* sm1_push_poly0(0,[0,1,x+y,["Hello",y^3]],[x,y]); */

def sm1_pop_poly0(P,Vlist) {
  if (type(Vlist[0]) == 4) {
      Vlist = Vlist[2];   
  }
  A = ox_pop_cmo(P);
  return(sm1_pop_poly0_0(P,A,Vlist));
}
def sm1_pop_poly0_0_R(A,P,Vlist) {
  return(sm1_pop_poly0_0(P,A,Vlist));
}
def sm1_pop_poly0_0(P,A,Vlist) {
  if (type(A) == 4) {
    return(map(sm1_pop_poly0_0_R,A,P,Vlist));
  }
  if (type(A)== 9) {return(dp_dtop(A,Vlist));}
  return(A);
}

def sm1_push_int0_R(A,P) {
  return(sm1_push_int0(P,A));
}



def sm1_push_int0(P,A) {
 if (type(A) == 1 || type(A) == 0) { 
   /* recursive poly  or number or 0*/
   A = rtostr(A);
   ox_push_cmo(P,A);
   sm1(P," . (integer) dc ");
   return;
 }
 if (type(A) == 2) {
   A = rtostr(A); ox_push_cmo(P,A);
   return;
 }
 if (type(A) == 4) { /* list */
   ox_execute_string(P," [ ");
   map(sm1_push_int0_R,A,P);
   ox_execute_string(P," ] ");
   return;
 }
 ox_push_cmo(P,A);
 return;
}

def sm1_push_0_R(A,P) {
  return(sm1_push_0(P,A));
}
def sm1_push_0(P,A) {
 if (type(A) == 0) { 
   /* 0 */
   A = rtostr(A);
   ox_push_cmo(P,A);
   sm1(P," .. ");
   return;
 }
 if (type(A) == 2) {
   /* Vlist = vars(A); One should check Vlist is a subset of Vlist3. */
   Vlist2 = sm1_vlist(P);
   Vlist3 = map(strtov,Vlist2[1]);
   B = dp_ptod(A,Vlist3);
   ox_push_cmo(P,B);
   return;
 }
 if (type(A) == 4) { /* list */
   ox_execute_string(P," [ ");
   map(sm1_push_0_R,A,P);
   ox_execute_string(P," ] ");
   return;
 }
 ox_push_cmo(P,A);
 return;
}

def sm1_push(P,A) {
  sm1_push_0(P,A);
}


def sm1_pop(P) {
  extern V_sm1_pop;
  sm1(P," toAsirForm ");
  V_sm1_pop = ox_pop_cmo(P);
  return(toAsirForm(V_sm1_pop));
}

def sm1_pop2(P) {
  extern V_sm1_pop;
  sm1(P," toAsirForm ");
  V_sm1_pop = ox_pop_cmo(P);
  return([toAsirForm(V_sm1_pop),V_sm1_pop]);
}

def sm1_check_arg_gb(A,Fname) {
  /* A = [[x^2+y^2-1,x*y],[x,y],[[x,-1,y,-1]]] */
  if (type(A) != 4) {
     error(Fname+" : argument should be a list.");
  }
  if (length(A) < 2) {
     error(Fname+" : argument should be a list of 2 or 3 elements.");
  }
  if (type(A[0]) != 4) {
     error(Fname+" : example: [[dx^2+dy^2-4,dx*dy-1]<== it should be a list,[x,y]]");
  }
  if (!sm1_isListOfPoly(A[0])) {
     error(Fname+" : example: [[dx^2+dy^2-4,dx*dy-1]<== it should be a list of polynomials or strings,[x,y]]");
  }
  if (!sm1_isListOfVar(A[1])) {
     error(Fname+" : example: [[dx^2+dy^2-4,dx*dy-1],[x,y]<== list of variables or \"x,y\"]");
  }
  if (length(A) >= 3) {
    if (type(A[2]) != 4) {
      error(Fname+" : example:[[dx^2+dy^2-4,dx*dy-1],[x,y],[[x,-1,dx,1]]<== a list of weights]");
    }
    if (type(A[2][0]) != 4) {
      error(Fname+" : example:[[dx^2+dy^2-4,dx*dy-1],[x,y],[[x,-1,dx,1],[dy,1]]<== a list of lists of weight]");
    }
  }
  return(1);
}

def sm1_isListOfPoly(A) {
  if (type(A) !=4 ) return(0);
  N = length(A);
  for (I=0; I<N; I++) {
    if (!(type(A[I]) == 0 || type(A[I]) == 1 || type(A[I]) == 2 ||
          type(A[I]) == 7 || type(A[I]) == 9)) {
      return(0);
    }
  }
  return(1);
}

def sm1_isListOfVar(A) {
  if (type(A) == 7) return(1); /* "x,y" */
  if (type(A) != 4) return(0);
  N = length(A);
  for (I=0; I<N; I++) {
    if (!(type(A[I]) == 2 ||  type(A[I]) == 7 )) {
      return(0);
    }
  }
  return(1);
}



def sm1_gb(A) {
  SM1_FIND_PROC(P);
  Sorted = getopt(sorted);
  if (type(Sorted) == -1) {
    Sorted = 0;
  }else{
    Sorted = 1;
  }
  P = sm1_check_server(P);
  sm1_check_arg_gb(A,"Error in sm1_gb");
  sm1_push_int0(P,A);
  sm1(P," gb ");
  if (Sorted) {
    T = sm1_pop2(P);
    return(append(T[0],[sm1_toOrdered(T[1])]));
  }else{
    return(sm1_pop(P));
  }
}
def sm1_gb_d(A) {
  SM1_FIND_PROC(P);
  P = sm1_check_server(P);
  sm1_check_arg_gb(A,"Error in sm1_gb_d");
  sm1_push_int0(P,A);
  sm1(P," gb /gb.tmp1 set ");
  sm1(P," gb.tmp1 getOrderMatrix {{(universalNumber) dc} map } map /gb.tmp2 set ");
  sm1(P," gb.tmp1 0 get 0 get getvNamesCR { [(class) (indeterminate)] dc } map /gb.tmp3 set ");
  sm1(P," gb.tmp1 getRing ring_def "); /* Change the current ring! */
  sm1(P,"[[ gb.tmp3 gb.tmp2] gb.tmp1] ");
  return(ox_pop_cmo(P));
}

def sm1_pgb(A) {
  SM1_FIND_PROC(P);
  P = sm1_check_server(P);
  sm1_check_arg_gb(A,"Error in sm1_pgb");
  sm1(P," set_timer ");
  sm1_push_int0(P,A);
  sm1(P," pgb ");
  B = sm1_pop(P);
  sm1(P," set_timer ");
  return(B);
}



def sm1_deRham(A) {
  SM1_FIND_PROC(P);
  P = sm1_check_server(P);
  sm1(P," set_timer ");
  sm1_push_int0(P,A);
  sm1(P," deRham ");
  B = sm1_pop(P);
  sm1(P," set_timer ");
  ox_check_errors2(P);
  return(B);
}

def sm1_vlist(P) {
  sm1(P," getvNamesC ");
  B=ox_pop_cmo(P);
  sm1(P," getvNamesC toAsirVar ");
  C=ox_pop_cmo(P);
  return([B,C,map(strtov,C)]);
}
/* [ sm1 names(string), asir names(string),  asir names(var)] */
/* Vlist = sm1_vlist(P);
   sm1_push_poly0( x + 20*x, Vlist[2]); 
   sm1_pop_poly0(Vlist[2]);
*/

/* ring of Differential operators */
def sm1_ringD(V,W) {
  SM1_FIND_PROC(P);
  sm1(P," [ ");
  if (type(V) == 7) { /* string */
    ox_push_cmo(P,V);
  }else  if (type(V) == 4) {/* list */
    V = map(rtostr,V);
    ox_push_cmo(P,V);
    sm1(P," from_records ");
  }else { printf("Error: sm1_ringD"); return(-1); }
  sm1(P," ring_of_differential_operators ");
  if (type(W) != 0) {
    sm1_push_int0(P,W);  sm1(P," weight_vector ");
  }
  sm1(P," pstack ");
  sm1(P," 0 ] define_ring getOrderMatrix {{(universalNumber) dc}map}map ");
  ox_check_errors2(P);
  M = ox_pop_cmo(P);
  return([sm1_vlist(P)[2],M]);
}    

def sm1_expand_d(F) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,F);
  sm1(P, " expand ");
  return(ox_pop_cmo(P));
}  

def sm1_mul_d(A,B) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,A);
  ox_push_cmo(P,B);
  sm1(P," mul ");
  return(ox_pop_cmo(P));
}

def sm1_dehomogenize_d(A) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,A);
  sm1(P," dehomogenize ");
  return(ox_pop_cmo(P));
}

def sm1_homogenize_d(A) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,A);
  sm1(P," homogenize ");
  return(ox_pop_cmo(P));
}

def sm1_groebner_d(A) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,A);
  sm1(P," groebner ");
  return(ox_pop_cmo(P));
}

def sm1_reduction_d(F,G) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,F);
  ox_push_cmo(P,G);
  sm1(P," reduction ");
  return(ox_pop_cmo(P));
}

def sm1_reduction_noH_d(F,G) {
  SM1_FIND_PROC(P);
  ox_push_cmo(P,F);
  ox_push_cmo(P,G);
  sm1(P," reduction-noH ");
  return(ox_pop_cmo(P));
}



def sm1_hilbert(A) {
  SM1_FIND_PROC(P);
  P = sm1_check_server(P);
  sm1(P,"[ ");
  sm1_push_int0(P,A[0]);
  sm1_push_int0(P,A[1]);
  sm1(P," ] pgb /sm1_hilbert.gb set ");
  sm1(P," sm1_hilbert.gb 0 get { init toString } map ");
  sm1_push_int0(P,A[1]);
  sm1(P, " hilbert ");
  B = sm1_pop(P);
  return(B[1]/fac(B[0]));
}



def sm1_genericAnn(F) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,F[0]);
  sm1_push_int0(P,F[1]);
  sm1(P, " genericAnn ");
  B = sm1_pop(P);
  return(B);
}

def sm1_tensor0(F) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,F);
  sm1(P, " tensor0 ");
  B = sm1_pop(P);
  return(B);
}



def sm1_wTensor0(F) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,F);
  sm1(P, " wTensor0 ");
  B = sm1_pop(P);
  return(B);
}



def sm1_reduction(A) {
  /* Example: sm1_reduction(A|proc=10) */
  SM1_FIND_PROC(P);
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_reduction(A|proc=p): A must be a list.");
  }
  AA = [rtostr(A[0])];
  AA = append(AA,[ map(rtostr,A[1]) ]);
  AA = append(AA, cdr(cdr(A)));
  sm1(P," /reduction*.noH 0 def ");
  sm1_push_int0(P,AA);
  sm1(P," reduction* ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_reduction_noH(A) {
  /* Example: sm1_reduction(A|proc=10) */
  SM1_FIND_PROC(P);
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_reduction_noH(A|proc=p): A must be a list.");
  }
  AA = [rtostr(A[0])];
  AA = append(AA,[ map(rtostr,A[1]) ]);
  AA = append(AA, cdr(cdr(A)));
  sm1(P," /reduction*.noH 1 def ");
  sm1_push_int0(P,AA);
  sm1(P," reduction* ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_xml_tree_to_prefix_string(A) {
  SM1_FIND_PROC(P);
  /* check the arguments */
  if (type(A) != 7) {
   error("sm1_xml_tree_to_prefix_string(A|proc=p): A must be a string.");
  }
  ox_push_cmo(P,A);
  sm1(P," xml_tree_to_prefix_string ");
  ox_check_errors2(P);
  return(ox_pop_cmo(P));
}


def sm1_wbf(A) {
  SM1_FIND_PROC(P);
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_wbf(A): A must be a list.");
  }
  if (length(A) != 3) {
   error("sm1_wbf(A): A must be a list of the length 3.");
  }
  if (type(A[0]) != 4 || type(A[1]) != 4 || type(A[2]) != 4) {
   error("sm1_wbf([A,B,C]): A, B, C must be a list.");
  }
  if (! (type(A[2][0]) == 7 || type(A[2][0]) == 2)) {
   error("sm1_wbf([A,B,C]): C must be of a form [v-name, v-weight, ...]");
  }
  sm1_push_int0(P,A);
  sm1(P," wbf ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}
def sm1_wbfRoots(A) {
  SM1_FIND_PROC(P);
  /* check the arguments */
  if (type(A) != 4) {
   error("sm1_wbfRoots(A): A must be a list.");
  }
  if (length(A) != 3) {
   error("sm1_wbfRoots(A): A must be a list of the length 3.");
  }
  if (type(A[0]) != 4 || type(A[1]) != 4 || type(A[2]) != 4) {
   error("sm1_wbfRoots([A,B,C]): A, B, C must be a list.");
  }
  if (! (type(A[2][0]) == 7 || type(A[2][0]) == 2)) {
   error("sm1_wbfRoots([A,B,C]): C must be of a form [v-name, v-weight, ...]");
  }
  sm1_push_int0(P,A);
  sm1(P," wbfRoots ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_res_div(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,[[A[0],A[1]],A[2]]);
  sm1(P," res*div ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}




def sm1_syz(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,A);
  sm1(P," syz ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_res_solv(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,[[A[0],A[1]],A[2]]);
  sm1(P," res*solv ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_res_solv_h(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,[[A[0],A[1]],A[2]]);
  sm1(P," res*solv*h ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_mul(A,B,V) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,[[A,B],V]);
  sm1(P," res*mul ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

 
def sm1_mul_h(A,B,V) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,[[A,B],V]);
  sm1(P," res*mul*h ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}

def sm1_adjoint(A,V) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,[A,V]);
  sm1(P," res*adjoint ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}
 
def transpose(A) {
  if (type(A) == 4) {
    N = length(A); M = length(A[0]);
    B = newmat(N,M,A);
    C = newmat(M,N);
    for (I=0; I<N; I++) {
      for (J=0; J<M; J++) {
        C[J][I] = B[I][J];
      }
    }
    D = newvect(M);
    for (J=0; J<M; J++) {
      D[J] = C[J];
    }
    return(map(vtol,vtol(D)));
  }else{
    print(A)$
    error("tranpose: traspose for this argument has not been implemented.");
  }
}

def sm1_resol1(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,A);
  sm1(P," res*resol1 ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


def sm1_gcd_aux(A,B) {
  if (type(A) == 1 && type(B) == 1) return(igcd(A,B));
  else return(gcd(A,B));
}

def sm1_lcm_aux(V) {  /* sm1_lcm_aux([3,5,6]); */
  N = length(V);
  if (N == 0) return(0);
  if (N == 1) return(V[0]);
  L = V[0];
  for (I=1; I<N; I++) {
    L = red(L*V[I]/sm1_gcd_aux(L,V[I]));
  } 
  return(L);
}

def sm1_mul_v(V,S) {
  if (type(V) == 4) {
    return(map(sm1_mul_v,V,S));
  } else {
    return(V*S);
  }
}

def sm1_div_v(V,S) {
  if (type(V) == 4) {
    return(map(sm1_div_v,V,S));
  } else {
    return(V/S);
  }
}


def sm1_rat_to_p_aux(T) {  /* cf. sm1_rat2plist2 */
  T = red(T);
  T1 = nm(T); T1a = ptozp(T1); 
  T1b = red(T1a/T1);
  T2 = dn(T); 
  return([T1a*dn(T1b),T2*nm(T1b)]);
}

def sm1_denom_aux0(A) {
  return(A[1]);
}
def sm1_num_aux0(P) {
  return(P[0]);
}

def sm1_rat_to_p(T) {
  if (type(T) == 4) {
     A = map(sm1_rat_to_p,T);
     D = map(sm1_denom_aux0,A);
     N = map(sm1_num_aux0,A);
     L = sm1_lcm_aux(D); 
     B = newvect(length(N));
     for (I=0; I<length(N); I++) {
       B[I] = sm1_mul_v(N[I],L/D[I]);
     }
     return([vtol(B),L]);
  }else{
     return(sm1_rat_to_p_aux(T));
  }
}



/* ---------------------------------------------- */
def sm1_distraction(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,A);
  sm1(P," distraction2* ");
  ox_check_errors2(P);
  return(sm1_pop(P));
}


/* Temporary functions */
/* Use this function for a while to wait a fix of asir. */
def sm1_ntoint32(I) {   /* Fixed */
  SM1_FIND_PROC(P);
  if (I >= 0) return(ntoint32(I));
  sm1(P," "+rtostr(I)+" ");
  return(ox_pop_cmo(P));
}
def sm1_to_ascii_array(S) {  /* Use strtoascii */
  SM1_FIND_PROC(P);
  ox_push_cmo(P,S);
  sm1(P," (array) dc { (universalNumber) dc } map ");
  return(ox_pop_cmo(P));
}
def sm1_from_ascii_array(S) {  /* Use asciitostr */
  SM1_FIND_PROC(P);
  ox_push_cmo(P,S);
  sm1(P," { (integer) dc (string) dc } map cat ");
  return(ox_pop_cmo(P));
}

/*
[288]  sm1_to_ascii_array("Hello");
[72,101,108,108,111]
[289] sm1_from_ascii_array(@@);
Hello
*/

/* end of temporary functions */

def sm1_gkz(S) {
  SM1_FIND_PROC(P);
  A = S[0];
  B = S[1];
  AA = [ ];
  BB = [ ];
  for (I=0; I<length(A); I++) {
    AA = append(AA,[map(ntoint32,A[I])]);
    BB = append(BB,[ntoint32(0)]);
  }
  sm1(P,"[ ");
  sm1_push_int0(P,AA);
  sm1_push_int0(P,BB);
  sm1(P," ] gkz ");
  ox_check_errors2(P);
  R = sm1_pop(P);
  RR0 = map(eval_str,R[0]);
  RR1 = map(eval_str,R[1]);
  RR3 = [ ];
  for (I=0; I<length(B); I++) {
    RR3 = append(RR3,[ sm1_rat_to_p(RR0[I]-B[I])[0] ]);
  }
  for (I=length(B); I<length(RR0); I++) {
    RR3 = append(RR3,[RR0[I]]);
  }
  return([RR3,RR1]);
}



def sm1_appell1(S) {
  N = length(S)-2;
  B = cdr(cdr(S));
  A = S[0];
  C = S[1];
  V = [ ];
  for (I=0; I<N; I++) {
    V = append(V,[sm1aux_x(I+1)]); 
  }
  Ans = [ ];
  Euler = 0;
  for (I=0; I<N; I++) {
    Euler = sm1aux_x(I+1)*sm1aux_dx(I+1) + Euler;
  }
  for (I=0; I<N; I++) {
    T = sm1_mul(sm1aux_dx(I+1), Euler+C-1,V)-
        sm1_mul(Euler+A, sm1aux_x(I+1)*sm1aux_dx(I+1)+B[I],V);
    /* Tmp=sm1_rat_to_p(T);
    print(Tmp[0]/Tmp[1]-T)$ */
    T = sm1_rat_to_p(T)[0];
    Ans = append(Ans,[T]);
  }
  for (I=0; I<N; I++) {
    for (J=I+1; J<N; J++) {
      T = (sm1aux_x(I+1)-sm1aux_x(J+1))*sm1aux_dx(I+1)*sm1aux_dx(J+1)
         - B[J]*sm1aux_dx(I+1) + B[I]*sm1aux_dx(J+1);
      /* Tmp=sm1_rat_to_p(T);
      print(Tmp[0]/Tmp[1]-T)$ */
      T = sm1_rat_to_p(T)[0];
      Ans = append(Ans,[T]);
    }
  }
  return([Ans,V]);
}


def sm1aux_dx(I) {
  return(strtov("dx"+rtostr(I)));
}
def sm1aux_x(I) {
  return(strtov("x"+rtostr(I)));
}



def sm1_appell4(S) {
  N = length(S)-2;
  B = cdr(cdr(S));
  A = S[0];
  C = S[1];
  V = [ ];
  for (I=0; I<N; I++) {
    V = append(V,[sm1aux_x(I+1)]); 
  }
  Ans = [ ];
  Euler = 0;
  for (I=0; I<N; I++) {
    Euler = sm1aux_x(I+1)*sm1aux_dx(I+1) + Euler;
  }
  for (I=0; I<N; I++) {
    T = sm1_mul(sm1aux_dx(I+1), sm1aux_x(I+1)*sm1aux_dx(I+1)+B[I]-1,V)-
        sm1_mul(Euler+A,Euler+C,V);
    /* Tmp=sm1_rat_to_p(T);
    print(Tmp[0]/Tmp[1]-T)$ */
    T = sm1_rat_to_p(T)[0];
    Ans = append(Ans,[T]);
  }
  return([Ans,V]);
}



def sm1_rank(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,A);
  sm1(P," rank toString .. ");
  ox_check_errors2(P);
  R = sm1_pop(P);
  return(R);
}

def sm1_rrank(A) {
  SM1_FIND_PROC(P);
  sm1_push_int0(P,A);
  sm1(P," rrank toString .. ");
  ox_check_errors2(P);
  R = sm1_pop(P);
  return(R);
}



def sm1_auto_reduce(T) {
  SM1_FIND_PROC(P);
  sm1(P,"[(AutoReduce) "+rtostr(T)+" ] system_variable ");
  ox_check_errors2(P);
  R = sm1_pop(P);
  return(R);
}


  
def sm1_slope(II,V,FF,VF) {
  SM1_FIND_PROC(P);
  A =[II,V,FF,VF];
  sm1_push_int0(P,A);
  sm1(P," slope toString ");
  ox_check_errors2(P);
  R = eval_str(sm1_pop(P));
  return(R);
}




end$

