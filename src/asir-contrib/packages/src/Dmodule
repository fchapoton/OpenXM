/* $OpenXM$ */

/*----------------------*/
/* package for D-module */
/*----------------------*/

#define _DEBUG_Dmodule_ 0

Dmodule_sm1_PID = -1$
Dmodule_Euler2D = [[1],[0,1],[0,1,1]]$

def dmod_sm1_start() {
  extern Dmodule_sm1_PID;
  if (Dmodule_sm1_PID < 0) {
#if _DEBUG_Dmodule_
    print("starting ox_sm1_forAsir ...");
#endif
    Dmodule_sm1_PID = sm1_start();
#if _DEBUG_Dmodule_
    print("sm1 process number: ", 0); print(Dmodule_sm1_PID);
#endif
  }
  return Dmodule_sm1_PID;
}

def dmod_sm1_restart() {
  extern Dmodule_sm1_PID;
  Dmodule_sm1_PID = sm1_start();
  return Dmodule_sm1_PID;
}

/* [x1,x2,...] -> [dx1,dx2,...] */
def dmod_make_dv(V) {
  if (type(V) != 4) {
    error("parameter type error.");
  }
  Dv = [];
  for (I = 0; I < length(V); I++) {
    Dv = append(Dv, [strtov("d" + rtostr(V[I]))]);
  }
  return Dv;
}

/* [x1,x2,...] -> [tx1,tx2,...] */
def dmod_make_tv(V) {
  if (type(V) != 4) {
    error("parameter type error.");
  }
  Tv = [];
  for (I = 0; I < length(V); I++) {
    Tv = append(Tv, [strtov("t" + rtostr(V[I]))]);
  }
  return Tv;
}

def dmod_p_dn(Poly) {
#if _DEBUG_Dmodule_
  print("polynomial: ", 0); print(Poly);
  print("variables: ", 0); print(vars(Poly));
#endif
  if (type(Poly) > 2) {
    error("parameter type error.");
  }
  if (Poly == 0) {
    return 1;
  }
  Vars = vars(Poly);
  Dpoly = dp_ptod(Poly, Vars);
  Dn_list = [];
  while (Dpoly != 0) {
#if _DEBUG_Dmodule_
    print("Dpoly: ", 0); print(Dpoly);
#endif
    Hc = dp_hc(Dpoly);
#if _DEBUG_Dmodule_
    print("Hc (number): ", 0); print(Hc);
#endif
    Dn_list = append(Dn_list, [dn(Hc)]);
    Dpoly -= dp_hm(Dpoly);
  }
  Gcd = Lcm = Dn_list[0];
  for (I = 1; I < length(Dn_list); I++) {
    Gcd = igcd(Lcm, Dn_list[I]);
    Lcm = (Lcm/Gcd)*(Dn_list[I]/Gcd)*Gcd;
  }
  return Lcm;
}

def dmod_p_nm(Poly) {
  return Poly*dmod_p_dn(Poly);
}

def dmod_d_op_dn(L_list, V) {
  L_list_asir = dmod_d_op_toasir(L_list, V);
  V = append(V, dmod_make_dv(V));
  Dn_list = [];
  for (I = 0; I < length(L_list_asir); I++) {
    Dn_list = append(Dn_list, [dmod_p_dn(L_list_asir[I])]);
  }
  Gcd = Lcm = Dn_list[0];
  for (I = 1; I < length(Dn_list); I++) {
    Gcd = igcd(Lcm, Dn_list[I]);
    Lcm = (Lcm/Gcd)*(Dn_list[I]/Gcd)*Gcd;
  }
  return Lcm;
}

def dmod_d_op_nm(L_list, V) {
  Dn = dmod_d_op_dn(L_list, V);
  L_nm_list = [];
  for (I = 0; I < length(L_list); I++) {
    L_nm = [];
    for (J = 0; J < length(L_list[I]); J++) {
      L_nm = append(L_nm, [[L_list[I][J][0]*Dn, L_list[I][J][1]]]);
    }
    L_nm_list = append(L_nm_list, [L_nm]);
  }
  return L_nm_list;
}

/* [x1,x2,...] -> "x1,x2,..." */
def dmod_var_tosm1(V) {
  if (type(V) != 4) {
    error("parameter type error.");
  }
  if (V == []) {
    return "";
  }
  V_str = rtostr(V[0]);
  for (I = 1; I < length(V); I++) {
    V_str += "," + rtostr(V[I]);
  }
#if _DEBUG_Dmodule_
  print("variables (sm1 format): ", 0); print(V_str);
#endif
  return V_str;
}

/* asir polynomial -> sm1 string */
def dmod_p_tosm1(Poly, V) {
  if (type(Poly) > 2 || type(V) != 4) {
    error("parameter type error.");
  }

  if (Poly == 0) {
    return "0";
  }

  Dpoly = dp_ptod(Poly, V);

  Str_poly = "";
  do {
    Hc = dp_hc(Dpoly);
    Ht = dp_ht(Dpoly);
    HtV = dp_etov(Ht);
#if _DEBUG_Dmodule_
    print("Dpoly: ", 0); print(Dpoly);
    print("Hc: ", 0); print(Hc);
    print("Ht: ", 0); print(Ht);
    print("HtV: ", 0); print(HtV);
    print("size(HtV): ", 0); print(size(HtV));
#endif

    /* coefficient */
    if (type(Hc) < 2) {
      Str_poly += " + (" + rtostr(Hc) + ")";
    }
    else {
#if _DEBUG_Dmodule_
      print("Hc is polynomial.");
#endif
      Str_poly += " + (" + dmod_p_tosm1(Hc, vars(Hc)) + ")";
    }
#if _DEBUG_Dmodule_
    print("coefficient OK.");
#endif

    /* power product */
    Str_mono = "";
    for (J = 0; J < size(HtV)[0]; J++) {
      if (HtV[J] != 0) {
	Str_mono += " " + rtostr(V[J]^HtV[J]);
      }
    }
    Str_poly += Str_mono;
#if _DEBUG_Dmodule_
    print("power product OK.");
#endif

    Dpoly -= dp_hm(Dpoly);
  } while (Dpoly != 0);

  return Str_poly;
}

/* differential operators with polynomial coefficients -> sm1 string */
/* L_list: [ [[fa(V),[a1,...,an]],...], ... ], coefficient must be polynomial. */
def dmod_d_op_tosm1(L_list, V) {
  L_list = dmod_d_op_nm(L_list, V);
  L_str_list = [];
  for (I = 0; I < length(L_list); I++) {
    L_str = "";
    for (J = 0; J < length(L_list[I]); J++) {
      Poly = red(L_list[I][J][0]);
      if (Poly != 0) {
	Str_Poly = "(" + dmod_p_tosm1(Poly, V) + ")";
	Str_D = "";
	Index = L_list[I][J][1];
	for (K = 0; K < length(Index); K++) {
	  if (Index[K] != 0) {
	    Str_D += " d" + rtostr(V[K]^Index[K]);
	  }
	}
	L_str += " + " + Str_Poly + Str_D;
      }
    }
#if _DEBUG_Dmodule_
    print("L_str: ", 0); print(L_str);
#endif
    if (L_str == "") {
      L_str_list = append(L_str_list, ["0"]);
    }
    else {
      L_str_list = append(L_str_list, [L_str]);
    }
  }
  return L_str_list;
}

def dmod_d_op_toasir(L_list, V) {
  Dv = dmod_make_dv(V);
  L_list_asir = [];
  for (I = 0; I < length(L_list); I++) {
    L = L_list[I];
    L_asir = 0;
    for (J = 0; J < length(L); J++) {
      D = 1;
      for (K = 0; K < length(L[J][1]); K++) {
	D *= Dv[K]^L[J][1][K];
      }
      L_asir += L[J][0]*D;
    }
    L_list_asir = append(L_list_asir, [L_asir]);
  }
  return L_list_asir;
}

def dmod_d_op_fromasir(D_list, V) {
  Dv = dmod_make_dv(V);
  L_list = [];
  for (I = 0; I < length(D_list); I++) {
    D = dp_ptod(D_list[I], Dv);
    L = [];
    if (D == 0) {
      L = append(L, [[0,[0,0]]]);
    }
    else {
      while (D != 0) {
	L = append(L, [[dp_hc(D),vtol(dp_etov(dp_ht(D)))]]);
	D -= dp_hm(D);
      }
    }
    L_list = append(L_list, [L]);
  }
  return L_list;
}

def dmod_filt(V, W) {
  if (type(V) != 4 || type(W) != 4) {
    error("parameter type error.");
  }
  if (2*length(V) != length(W)) {
    error("a length of list is no match.");
  }
  V = append(V, dmod_make_dv(V));
  Filt = [];
  for (I = 0; I < length(V); I++) {
    Filt = append(Filt, [V[I], W[I]]);
  }
  return Filt;
}

/* weight (0,...,0,1,...,1) */
def dmod_order_filt(V) {
  OrderX = []; OrderD = [];
  for (I = 0; I < length(V); I++) {
    OrderX = append(OrderX, [V[I], 0]);
    OrderD = append(OrderD, [strtov("d" + rtostr(V[I])), 1]);
  }
  Order = append(OrderX, OrderD);
#if _DEBUG_Dmodule_
  print("order filtration: ", 0); print(Order);
#endif
  return Order;
}

/* weight (1,...,1,1,...,1) */
def dmod_bernstein_filt(V) {
  OrderX = []; OrderD = [];
  for (I = 0; I < length(V); I++) {
    OrderX = append(OrderX, [V[I], 1]);
    OrderD = append(OrderD, [strtov("d" + rtostr(V[I])), 1]);
  }
  Order = append(OrderX, OrderD);
#if _DEBUG_Dmodule_
  print("bernstein filtration: ", 0); print(Order);
#endif
}

/* D_ideal: ["...", "...",...], string is sm1 format. */
/* V: [x1,x2,...] */
def dmod_ch_ideal(D_ideal, V) {
  Gb = sm1_gb(dmod_sm1_start(), [D_ideal, dmod_var_tosm1(V), [dmod_order_filt(V)]]);
#if _DEBUG_Dmodule_
  print("sm1_gb: ", 0); print(Gb);
#endif
  return Gb[1];
}

def dmod_ch_ideal_appell1(A, B1, B2, C, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell1(A, B1, B2, C, V), V);
  return dmod_ch_ideal(D_ideal_str, V, Rest);
}

def dmod_ch_ideal_appell2(A, B1, B2, C1, C2, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell2(A, B1, B2, C1, C2, V), V);
  return dmod_ch_ideal(D_ideal_str, V, Rest);
}

def dmod_ch_ideal_appell3(A1, A2, B1, B2, C, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell3(A1, A2, B1, B2, C, V), V);
  return dmod_ch_ideal(D_ideal_str, V, Rest);
}

def dmod_ch_ideal_appell4(A, B, C1, C2, V) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell4(A, B, C1, C2, V), V);
  return dmod_ch_ideal(D_ideal_str, V);
}

def dmod_ch_ideal_selberg2(A, B, C, S, V) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_selberg2(A, B, C, S, V), V);
  return dmod_ch_ideal(D_ideal_str, V);
}

def dmod_ch_ideal_selberg2_1(A, B, K1, K2, V) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_selberg2_1(A, B, K1, K2, V), V);
  return dmod_ch_ideal(D_ideal_str, V);
}

def dmod_ch_ideal_gkz(A, B, V) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_gkz(A, B, V), V);
  return dmod_ch_ideal(D_ideal_str, V);
}

/* def dmod_proj(D_ideal, V) {
  Dv = dmod_make_dv(V);
  Ch = gr(dmod_ch_ideal(D_ideal, V), append(Dv, V), 2);
  Proj = [];
  for (I = 0; I < length(Ch); I++) {
    P = Ch[I];
    for (J = 0; J < length(Dv); J++) {
      P = subst(P, Dv[J], 0);
    }
    if (P != 0) {
      Proj = append(Proj, [P]);
    }
  }
  return Proj;
} */

/* def dmod_proj_appell4(A, B, C1, C2, V) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell4(A, B, C1, C2, V), V);
  return dmod_proj(D_ideal_str, V);
} */

/* def dmod_holonomic_rank(D_ideal, V) {
  ChI = dmod_ch_ideal(D_ideal, V);
  Gb = gr(ChI, dmod_make_dv(V), 2);
} */

/* restriction to {t1=0,t2=0,...} */
/* D_ideal: ["...", "...",...], string is sm1 format. */
/* Rest: [t1,t2,...] */
/* V: [x1,x2,...] */
def dmod_restriction(D_ideal, V, Rest) {
  D_ideal_str = "";
  for (I = 0; I < length(D_ideal); I++) {
    D_ideal_str += " (" + D_ideal[I] + ") ";
  }
  Rest_str = "";
  for (I = 0; I < length(Rest); I++) {
    Rest_str += " (" + rtostr(Rest[I]) + ") ";
  }
  V_str = "";
  for (I = 0; I < length(V); I++) {
    V_str += " (" + rtostr(V[I]) + ") ";
  }
  Cmd_str = "[ [" + D_ideal_str + "] [" + Rest_str + "] [[" + V_str + "] [ ]] 0 ] restriction";
#if _DEBUG_Dmodule_
  print("sm1 command string: ", 0); print(Cmd_str);
#endif
  sm1(dmod_sm1_start(), Cmd_str);
  return sm1_pop(dmod_sm1_start());
}

def dmod_restriction_appell1(A, B1, B2, C, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell1(A, B1, B2, C, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_restriction_appell2(A, B1, B2, C1, C2, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell2(A, B1, B2, C1, C2, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_restriction_appell3(A1, A2, B1, B2, C, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell3(A1, A2, B1, B2, C, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_restriction_appell4(A, B, C1, C2, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell4(A, B, C1, C2, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_restriction_selberg2(A, B, C, S, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_selberg2(A, B, C, S, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_restriction_selberg2_1(A, B, K1, K2, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_selberg2_1(A, B, K1, K2, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_restriction_gkz(A, B, V, Rest) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_gkz(A, B, V), V);
  return dmod_restriction(D_ideal_str, V, Rest);
}

def dmod_lookup(X, List) {
  if (type(List) != 4) {
    error("parameter type error.");
  }
  for (I = 0; I < length(List); I++) {
    if (X == List[I]) {
      return 1;
    }
  }
  return 0;
}

def dmod_assign0(Rat, V0) {
  if (type(Rat) > 3 || type(V0) != 4) {
    error("parameter type error.");
  }
  for (I = 0; I < length(V0); I++) {
    Rat = subst(Rat, V0[I], 0);
  }
  return Rat;
}

def dmod_elimination_order(V, Elim) {
  if (type(V) != 4 || type(Elim) != 4) {
    error("parameter type error.");
  }
  Dv = dmod_make_dv(V);
  VarOrderX = Elim;  
  VarOrderD = dmod_make_dv(Elim);
  for (I = 0; I < length(V); I++) {
    if (!dmod_lookup(V[I], Elim)) {
      VarOrderX = append(VarOrderX, [V[I]]);
      VarOrderD = append(VarOrderD, [Dv[I]]);
    }
  }
  VarOrder = append(VarOrderD, VarOrderX);
  ElimOrder = [];
  for (I = 0; I < length(VarOrder); I++) {
    Filt = [];
    for (J = 0; J < length(VarOrder); J++) {
      if (J == I) {
	Filt = append(Filt, [VarOrder[J], 1]);
      }
      else {
	Filt = append(Filt, [VarOrder[J], 0]);
      }
    }
    ElimOrder = append(ElimOrder, [Filt]);
  }
#if _DEBUG_Dmodule_
  print("elimination order :", 0); print(ElimOrder);
#endif
  return ElimOrder;
}

/* D_ideal: ["sm1 string format",...] */
/* Elim: eliminated variables */
def dmod_elimination(D_ideal, V, Elim) {
#if _DEBUG_Dmodule_
  print("D-idal: ", 0); print(D_ideal);
#endif
  Gb1 = sm1_gb(dmod_sm1_start(), [D_ideal, dmod_var_tosm1(V), dmod_elimination_order(V, Elim)]);
#if _DEBUG_Dmodule_
  print("Gb1: ", 0); print(Gb1);
#endif
  Gb2 = [];
  D_Elim = dmod_make_dv(Elim);
  for (I = 0; I < length(Gb1[0]); I++) {
    Vars = vars(Gb1[0][I]);
    Flag = 0;
    for (J = 0; J < length(D_Elim); J++) {
      if (dmod_lookup(D_Elim[J], Vars)) {
	Flag = 1;
	break;
      }
    }
    if (Flag == 0) {
      Gb2 = append(Gb2, [Gb1[0][I]]);
    }
  }
#if _DEBUG_Dmodule_
  print("Gb2: ", 0); print(Gb2);
#endif
  R_Gb = [];
  for (I = 0; I < length(Gb2); I++) {
    if ((Poly = dmod_assign0(Gb2[I], Elim)) != 0) {
      R_Gb = append(R_Gb, [Poly]);
    }
  }
#if _DEBUG_Dmodule_
  print("elimination D-ideal: ", 0); print(R_Gb);
#endif
  if (R_GB == []) {
    return [0];
  }
  else {
    return R_Gb;
  }
}

def dmod_elimination_appell1(A, B1, B2, C, V, Elim) {
  D_idal = dmod_d_op_tosm1(diff_op_appell1(A, B1, B2, C, V), V);
  return dmod_elimination(D_ideal, V, Elim);
}

def dmod_elimination_appell2(A, B1, B2, C1, C2, V, Elim) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell2(A, B1, B2, C1, C2, V), V);
  return dmod_elimination(D_ideal_str, V, Elim);
}

def dmod_elimination_appell3(A1, A2, B1, B2, C, V, Elim) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell3(A1, A2, B1, B2, C, V), V);
  return dmod_elimination(D_ideal_str, V, Elim);
}

def dmod_elimination_appell4(A, B, C1, C2, V, Elim) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_appell4(A, B, C1, C2, V), V);
  return dmod_elimination(D_ideal_str, V, Elim);
}

def dmod_elimination_selberg2(A, B, C, S, V, Elim) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_selberg2(A, B, C, S, V), V);
  return dmod_elimination(D_ideal_str, V, Elim);
}

def dmod_elimination_selberg2_1(A, B, K1, K2, V, Elim) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_selberg2_1(A, B, K1, K2, V), V);
  return dmod_elimination(D_ideal_str, V, Elim);
}

def dmod_elimination_gkz(A, B, V, Elim) {
  D_ideal_str = dmod_d_op_tosm1(diff_op_gkz(A, B, V), V);
  return dmod_elimination(D_ideal_str, V, Elim);
}

/* (V[0] dV[0])^N -> V[0]^N dV[0]^N + ... */
def dmod_euler2d(N, V) {
  extern Dmodule_Euler2D;
  if (N < 0) {
    error("parameter range error.");
  }

  if (N >= length(Dmodule_Euler2D)) {
    for (I = length(Dmodule_Euler2D); I <= N; I++) {
      List = [0];
      for (J = 1; J < I; J++) {
	List = append(List, [Dmodule_Euler2D[I-1][J-1]+J*Dmodule_Euler2D[I-1][J]]);
      }
      List = append(List, [Dmodule_Euler2D[I-1][I-1]]);
      Dmodule_Euler2D = append(Dmodule_Euler2D, [List]);
    }
  }

  Coef = Dmodule_Euler2D[N];
  Dv = dmod_make_dv(V);
  D = 0;
  for (I = 0; I < length(Coef); I++) {
    D += Coef[I]*V[0]^I*Dv[0]^I;
  }
  return D;
}

/* a -> a+n, b -> b+n, c1 -> c1+n, c2 -> c2+n */
/* Param: List, [a,b,c1,c2] */
/* Ns: List, [na,nb,nc1,nc2] */
def dmod_contiguity_appell4(Param, Ns, F, V) {
  if (length(V) != 2) {
    error("a length of List V is wrong.");
  }
  if (Ns[0] < 0 || Ns[1] < 0 || Ns[2] > 0 || Ns[3] > 0) {
    error("this case is undefined.");
  }

  Tx = uc(); Ty = uc();
  L = 1;
  for (I = 0; I < Ns[0]; I++) {
    L *= Tx + Ty + Param[0] + I;
  }
  for (I = 0; I < Ns[1]; I++) {
    L *= Tx + Ty + Param[1] + I;
  }
  for (I = 0; I < -Ns[2]; I++) {
    L *= Tx + Param[2] - I - 1;
  }
  for (I = 0; I < -Ns[3]; I++) {
    L *= Ty + Param[3] - I - 1;
  }

  Dp_L = dp_ptod(L, [Tx,Ty]);
  L = 0;
  while (Dp_L != 0) {
    Hm = dp_hm(Dp_L);
    He = vtol(dp_etov(Hm));
    L += dp_hc(Hm)*dmod_euler2d(He[0], [V[0]])*dmod_euler2d(He[1], [V[1]]);
    Dp_L -= Hm;
  }

  L_list = dmod_d_op_fromasir([L], V);
  return diff_act(L_list[0], F, V);
}

end$
