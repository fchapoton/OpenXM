diff -urN gnuplot-4.0.0.orig/configure.in gnuplot-4.0.0/configure.in
--- gnuplot-4.0.0.orig/configure.in	Sun Apr 11 00:55:14 2004
+++ gnuplot-4.0.0/configure.in	Wed Dec 15 11:07:49 2004
@@ -827,6 +827,10 @@
            tutorial/Makefile],
           [test -z "$CONFIG_HEADERS" || echo timestamp >stamp-h])
 
+dnl for Solaris 2.x
+AC_CHECK_FUNC(socket, , [AC_CHECK_LIB(socket,socket)])
+AC_CHECK_FUNC(gethostbyname, , [AC_CHECK_LIB(nsl,gethostbyname)])
+
 dnl Report configuration
 AC_MSG_RESULT([
 ** Configuration summary for $PACKAGE $VERSION:
diff -urN gnuplot-4.0.0.orig/src/plot.c gnuplot-4.0.0/src/plot.c
--- gnuplot-4.0.0.orig/src/plot.c	Thu Apr 15 00:26:21 2004
+++ gnuplot-4.0.0/src/plot.c	Wed Dec 15 11:08:39 2004
@@ -53,6 +53,23 @@
 #include <signal.h>
 #include <setjmp.h>
 
+/* TAKAYAMA Nobuki */
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <netinet/in.h>
+#include <netdb.h>
+
+FILE *openTCP     __P((char *));
+
+int socketConnect __P((char *, int));
+int socketOpen        __P((char *, int));
+int socketAccept  __P((int));
+
+int oxSocketSelect0   __P((int, int));
+int oxSocketMultiSelect   __P((int *, int, int, int *));
+/* END */
+
 #ifdef OS2 /* os2.h required for gpexecute.h */
 # define INCL_DOS
 # define INCL_REXXSAA
@@ -618,8 +635,11 @@
 
 /* interactive = FALSE; */ /* should this be here? */
 
-	    } else
-		load_file(loadpath_fopen(*argv, "r"), *argv, FALSE);
+	    } else {
+		load_file(openTCP(*argv), *argv, FALSE);
+		fprintf(stderr, "gnuplot : EOF or there was an error"
+				"in the input stream.\n");
+	    }
 	}
 #ifdef _Windows
 	if (noend) {
@@ -950,3 +970,307 @@
 #endif
 }
 #endif /* HAVE_LIBREADLINE && GNUPLOT_HISTORY */
+
+/*
+ * TAKAYAMA Nobuki
+ */
+FILE *
+openTCP(name)
+	char *name;
+{
+	FILE *fp;
+	int fd, port, reverse = 0;
+
+	fprintf(stderr, "openTCP port number : %s\n", name);
+
+	if (name[0] == 'r') {
+		fprintf(stderr, "openTCP : trying to reverse connetion.\n");
+		reverse = 1;
+		sscanf(&name[1], "%d", &port);
+	} else {
+		sscanf(name, "%d", &port);
+	}
+
+	if (reverse) {
+		fd = socketConnect("localhost", port);
+		fprintf(stderr, "socketConnect is succeded: fd = %d.", fd);
+	} else {
+		fprintf(stderr, "Port number is %d.\n", port);
+		fd = socketOpen("localhost", port);
+		fprintf(stderr, "socketOpen is succeded: fd = %d.", fd);
+		fd = socketAccept(fd);
+	}
+
+	fprintf(stderr, "\n Port %d : Connected.\n", port);
+	fp = fdopen(fd, "r");
+
+	return(fp);
+}
+
+#define	READBUFSIZE	10000
+
+int OpenedSocket = 0, Quiet = 0;
+
+int
+socketConnect(serverName, portNumber)
+	char *serverName;
+	int portNumber;
+{
+	struct hostent *servhost;
+	struct sockaddr_in serv;
+	int socketid, on;
+
+	if ((servhost = gethostbyname(serverName)) == NULL) {
+		fprintf(stderr, "Bad server name.\n\n");
+		return (-1);
+	}
+
+	bzero((void *)&serv, sizeof(serv));
+	serv.sin_family = AF_INET;
+	serv.sin_port = htons(portNumber);
+	bcopy(servhost->h_addr, (void *)&serv.sin_addr, servhost->h_length);
+
+	if ((socketid = socket(AF_INET, SOCK_STREAM, 0)) <0) {
+		fprintf(stderr, "Socket allocation is failed.\n\n");
+		return (-1);
+	}
+
+#if 0 /* XXX */
+	on = 1;
+	setsockopt(socketid, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
+#endif
+
+	if (!Quiet) {
+		fprintf(stderr, "Trying to connect port %d, ip=%x\n",
+			ntohs(serv.sin_port), serv.sin_addr);
+	}
+
+	if (connect(socketid, (struct sockaddr *)&serv, sizeof(serv)) == -1) {
+		fprintf(stderr, "cannot connect\n");
+		return (-1);
+	}
+
+	if (!Quiet)
+		fprintf(stderr, "connected.\n");
+
+	return(socketid);
+}
+
+int
+socketOpen(serverName, portNumber)
+	char *serverName;
+	int portNumber;
+{
+	static struct hostent *servhost;
+	static struct sockaddr_in serv;
+	static int s_wait;
+	static int on;
+	extern int errno;
+	int tt;
+
+	fprintf(stderr, "Hello from open. serverName is %s "
+			    "and portNumber is %d\n", serverName, portNumber);
+
+	if ((servhost = gethostbyname(serverName)) == NULL) {
+		fprintf(stderr, "Bad server name.\n");
+		return (-1);
+	}
+
+	bzero((void *)&serv, sizeof(serv));
+	serv.sin_family = AF_INET;
+	serv.sin_port = htons(portNumber);
+	bcopy(servhost->h_addr, &serv.sin_addr, servhost->h_length);
+
+	if ((s_wait = socket(AF_INET,SOCK_STREAM, 0)) < 0) {
+		fprintf(stderr, "Socket allocation is failed.\n");
+		return (-1);
+	}
+
+	on = 1;
+	setsockopt(s_wait, SOL_SOCKET,SO_REUSEADDR, &on, sizeof(on));
+
+	/* important */
+	if ((tt = bind(s_wait, (struct sockaddr *)&serv, sizeof(serv))) == -1) {
+		fprintf(stderr, "bind error. Error no is %d. "
+				    "See /usr/include/sys/errno.h. "
+				    "(asm/errno.h)\n", errno);
+		fprintf(stderr, "cannot bind\n");
+		return (-1);
+	}
+
+#if 0 /* XXX */
+	printf("bind returns %d\n", tt);
+#endif
+
+	tt = sizeof(serv);
+	if (getsockname(s_wait, (struct sockaddr *)&serv, &tt) < 0) {
+		fprintf(stderr, "getsockname error. Error no is %d. "
+				    "See /usr/include/sys/errno.h "
+				    "(asm/errno.h).\n", errno);
+		fprintf(stderr, "cannot getsockname\n");
+		return (-1);
+	}
+
+	if (listen(s_wait, 1) < 0) {
+		fprintf(stderr, "Listen failed\n");
+		return (-1);
+	}
+
+	fprintf(stderr, "Done the initialization. "
+			    "port =%d\n", ntohs(serv.sin_port));
+	OpenedSocket = ntohs(serv.sin_port);
+
+	return (s_wait);
+}
+
+int
+socketAccept(snum)
+	int snum;
+{
+	int s, news;
+
+	s = snum;
+
+	fprintf(stderr, "Trying to accept... ");
+	fflush(stderr);
+
+	if ((news = accept(s, NULL, NULL)) < 0) {
+		fprintf(stderr, "Error in accept.\n");
+		return (-1);
+	}
+
+	fprintf(stderr, "Accepted.\n");
+	fflush(stderr);
+
+	if (close(s) < 0) {
+		fprintf(stderr, "Error in closing the old socket.\n");
+		return (-1);
+	}
+
+	return(news);
+}
+
+int
+oxSocketSelect0(fd, t)
+	int fd, t;
+{
+	fd_set readfds;
+	struct timeval timeout;
+	int debug = 0;
+	extern int errno;
+
+	FD_ZERO(&readfds);
+	FD_SET(fd, &readfds);
+	timeout.tv_sec = 0;
+	timeout.tv_usec = (long)t;
+
+	if (t >= 0) {
+		if (debug) {
+			printf("select t >= 0 for fd = %d\n", fd);
+			fflush(NULL);
+		}
+
+		/* It must be fd + 1!, Not fd. */
+		if (select(fd + 1, &readfds, NULL, NULL, &timeout) < 0) {
+			fprintf(stderr, "select (non-block) error. "
+					    "Error no is %d. "
+					    "See /usr/include/sys/errno.h "
+					    "(asm/errno.h).\n", errno);
+			fprintf(stderr, "oxSocketSelect0() : select failed.\n");
+			return (0);
+		}
+
+		if (debug) {
+			printf("Return from select t >= 0 for fd = %d\n", fd);
+			fflush(NULL);
+		}
+	} else {
+		/* block */
+		if (select(fd + 1, &readfds, NULL, NULL, NULL) < 0) {
+			fprintf(stderr, "select (block) error. "
+					    "Error no is %d. "
+					    "See /usr/include/sys/errno.h "
+					    "(asm/errno.h).\n", errno);
+			fprintf(stderr, "socketSelect0() : select failed.\n");
+			return (0);
+		}
+	}
+
+	if (FD_ISSET(fd, &readfds)) {
+		return(1);
+	} else {
+		return(0);
+	}
+}
+
+int
+oxSocketMultiSelect(sid, size, t, result)
+	int sid[], size, t, result[];
+{
+	fd_set readfds;
+	struct timeval timeout;
+	int i, fd, p, isdata = 0;
+	extern int errno;
+
+	FD_ZERO(&readfds);
+	timeout.tv_sec = 0;
+	timeout.tv_usec = (long)t;
+
+	fd = 0;
+
+	for (i = 0 ; i < size ; i++) {
+		if (sid[i] >= 0) {
+			p = sid[i];
+			if (p > fd)
+				fd = p;
+			FD_SET(p,&readfds);
+#if 0 /* XXX */
+			printf("p = %d, fd=%d", p, fd);
+#endif
+		}
+	}
+
+#if 0 /* XXX */
+	printf("MultiSelect..\n");
+	fflush(NULL);
+#endif
+
+	if (t >= 0) {
+		/* It must be fd + 1!, Not fd. */
+		if (select(fd + 1, &readfds, NULL, NULL, &timeout) < 0) {
+			fprintf(stderr, "Select error. Error no is %d. "
+					    "See /usr/include/sys/errno.h "
+					    "(asm/errno.h).\n", errno);
+			fprintf(stderr, "oxSocketMultiSelect() : "
+					"select failed.\n");
+			return (0);
+		}
+	} else {
+		/* block */
+		if (select(fd + 1, &readfds, NULL, NULL, NULL) < 0) {
+			fprintf(stderr, "Select error. Error no is %d. "
+					    "See /usr/include/sys/errno.h "
+					    "(asm/errno.h).\n", errno);
+			fprintf(stderr, "oxSocketMultiSelect() : "
+					"(block) select failed.\n");
+			return (0);
+		}
+	}
+
+#if 0 /* XXX */
+	printf("Done. MultiSelect.\n");
+	fflush(NULL);
+#endif
+
+	for (i = 0 ; i < size ; i++) {
+		p = sid[i];
+		if ((sid[i] >= 0) && FD_ISSET(p, &readfds)) {
+			result[i] = 1;
+			isdata = 1;
+		} else {
+			result[i] = 0;
+		}
+	}
+
+	return (isdata);
+}
