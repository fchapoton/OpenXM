%%$OpenXM$
%% "make oxshell-ja.tex" to get the platex source.
//&ja \documentclass{jarticle}
//&en \documentclass{article}

//&ja \title{Oxshell の設計と実装}
//&en \title{The design and implementation of oxshell}
//&C \author{Nobuki Takayama}
//&C \date{December 5, 2003}
//&C \newtheorem{example}{Example}
\usepackage{html}

\begin{document}
\maketitle

/*&ja
OpenXM プロジェクトでは OX RFC 100 を用いて種々の数学ソフトウエアシステムの統合化を試みている.
新しい OX RFC 100 準拠のサーバを作る場合には
ターゲットとする数学ソフトウエアシステムのソースコードに OX RFC 100 対応部分
を加える作業をしないといけない.
この作業はソースコードの理解とかなりの手間を要する.
一方, 多くの数学ソフトウエアシステムはあらかじめファイルにコマンドやデータを書き出しておくことにより
unix の shell や Windows のコマンドプロンプトから利用可能なように作られている.
このような数学ソフトウエアをバッチ処理対応アプリケーションとこの文書ではよぶ.

Oxshell は上記のようなバッチ処理対応アプリケーションをソースコードの改変なく 
OX RFC 100 準拠にするためのいわゆるラッパー型の OX サーバを書くための補助機能を
提供する sm1 への組み込み関数である.
*/

//&ja Oxshell を用いて OX サーバを実現するのが適切な数学ソフトウエアは以下のような特徴をもつものであろう.
/*&ja
\begin{enumerate}
\item バッチ処理対応アプリケーションである.
\item ソースコードの変更ができないか困難.
\item サーバとの通信が頻繁におきない.
\item サーバの計算を中断して, 再度開始するなどの必要がない.
\item Windows でも unix でも動かしたい.
\end{enumerate}
*/
//&ja このような特徴を幾つかもつソフトウエアシステムとしてたとえば, {\tt polymake} がある
//&C (\htmladdnormallink{{\tt http://www.math.tu-berlin.de/polymake}}{http://www.math.tu-berlin.de/polymake}).
/*&ja
Polymake は多面体の facet の数え挙げなど多面体の種々の構成と計算をおこなうためのソフトウエアである.
Polymake はバッチ処理対応アプリケーションであり, また C++ で書かれたソースは先端的な C++ の機能を
利用しておりコンパイルが容易でない.
サーバとの通信の頻度は問題によるがある程度大きい計算の場合は通信時間は無視できる.
Polymake は対話的利用は想定しておらずサーバの計算を中断して, 再度開始するなどの必要がない.
この文章ではこの {\tt polymake} を例にとって, oxshell の設計と実装を述べる.
*/

//&ja \section{ox polymake サーバ入門}
//&en \section{Introduction to ox polymake server}

/*&ja
oxshell の設計と実装を述べるまえに, {\tt polymake} がどのようなソフトウエアか,
ox polymake がどのように動作するか実例をあげて説明しよう.
*/

//&C \begin{example} \rm
/*&ja
点 $(1,0,0)$, $(1,1,0)$, $(1,0,1)$, $(1,1,1)$ 上の cone の facet を求めよ. \\
{\tt polymake} ではつぎような入力ファイル {\tt square.poly} をまず作成する.
*/
/*&C
{\footnotesize \begin{verbatim}
POINTS
1 0 0
1 1 0
1 0 1
1 1 1
 
\end{verbatim} }
*/
//&ja \noindent そして次のコマンドを shell から実行する.
//&C  \ \\ \verb@ polymake square.poly FACETS @ \\
//&ja {\tt Polymake} は次のように結果を戻す.
/*&C
{\footnotesize \begin{verbatim}
FACETS
0 0 1
0 1 0
1 0 -1
1 -1 0
\end{verbatim} }
*/
//&C \end{example}


//&C \begin{example} \rm
/*&ja
同じ例を {\tt sm1/oxshell} を用いて解くと次のようになる.
*/
//&ja 次のコマンドを {\tt ox\_sm1} に実行させる.  こたえはスタックマシンの変数 {\tt rr} に入る.
/*&C
{\footnotesize \begin{verbatim}
 [(FACETS) (polymake.data(polymake.POINTS([[1,0,0],[1,1,0],[1,0,1],[1,1,1]])))]
         doPolymake /rr set ;
\end{verbatim} }
*/
//&ja {\tt rr} にはつぎような値がはいっている.
/*&C
{\footnotesize \begin{verbatim}
[ $polymake.data(polymake.POINTS([[1,0,0],[1,1,0],[1,0,1],[1,1,1]]),
   polymake.FACETS([[0,0,1],[0,1,0],[1,0,-1],[1,-1,0]]),
   polymake.AFFINE_HULL())$
  CMO tree expression of the data above
  Outputs to stdout and stderr ]
\end{verbatim} }
*/
//&C \end{example}


//&ja \section{doPolymake の処理の流れ}

//&ja  {\bf 以下はとりあえず要点のみ.}

/*&ja
\begin{enumerate}
\item  (CMO tree を tfb/2 形式へ.)
\item  tfb/2 表現のデータを polymake の入力形式へ.
\item  polymake を {\tt oxshell} で呼び出す.
\item  うけとった polymake 形式のデータを tfb/2 形式へ (polymake2tfb).
\item  (tfb/2 形式を CMO tree へ.)
\end{enumerate}

{\tt doPolymake} のソースは {\tt kan96xx/trans/polymake.sm1} にある.
*/

//&ja \section{{\tt Oxshell} の特徴}

//&ja  {\bf 以下はとりあえず要点のみ.}

/*&ja
\noindent OX RFC 100 にはファイルの概念がない. したがって, \\
\verb@ polymake ファイル名 動作 @ \\
みたいなプログラムは OX スタックマシンの上のデータをファイルに書き出してから
実行して, それからまたスタックマシンの上のデータに変換しないといけない.
この変換は単純仕事であるが, 実際のプログラムは unix と windows のパス名の違いとか,
/bin/sh の存在を仮定できる unix と /bin/sh の存在を仮定できない windows
とかいろんな要素があり, プログラムが大変読みにくく保守もしにくい
( phc での経験).  ZPG の極致である.
{\tt oxshell} ではこの仕事は次の 1 行で書く. \\
\verb@  [(polymake)  (stringInOut://スタックマシン変数名.poly)  動作] oxshell @ \\
スタックマシンの変数をファイルをみなしている.
変数を input output stream とみなすというのは Java の class 等で
すでにつかわれているよく知られている工夫だがこれを採り入れることにより,
考え方が整理されプログラムの保守性が大変よくなり, また新しいバッチ型アプリケーションの
OX サーバ化が楽になった.


{\tt oxshell} のその他のコマンドについては, sm1 で {\tt (oxshell) usage}
の解説を見よ.
将来的には /bin/sh の拡張言語とする予定.

OX RFC 100 にファイルの概念を加える作業は OX RFC 103 (100, 101 の補い) でやる予定.
*/

\end{document}
