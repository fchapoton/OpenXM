@comment $OpenXM$
\BJP
@node 配列,,, 組み込み函数
@section 配列
\E
\BEG
@node Arrays,,, Built-in Function
@section Arrays
\E

@menu
* newvect::
* vtol::
* newmat::
* size::
* det::
* qsort::
@end menu

\JP @node newvect,,, 配列
\EG @node newvect,,, Arrays
@subsection @code{newvect}
@findex newvect

@table @t
@item newvect(@var{len}[,@var{list}])
\JP :: 長さ @var{len} のベクトルを生成する. 
\EG :: Creates a new vector object with its length @var{len}.
@end table

@table @var
@item return
\JP ベクトル
\EG vector
@item len
\JP 自然数
\EG non-negative integer
@item list
\JP リスト
\EG list
@end table

@itemize @bullet
\BJP
@item
長さ @var{len} のベクトルを生成する. 第 2 引数がない場合, 
各成分は 0 に初期化される. 第 2 引数がある場合, 
インデックスの小さい成分から, リストの
各要素により初期化される. 各要素は, 先頭から順に
使われ, 足りない分は 0 が埋められる. 
@item
ベクトルの成分は, 第 0 成分から第 @var{len}-1 成分となる. 
(第 1 成分からではない事に注意. )
@item
リストは各成分が, ポインタを辿る事によってシーケンシャルに
呼び出されるのに対し, ベクトルは各成分が
第一成分からのメモリ上の displacement (変位)によってランダムアクセスで
呼び出され, その結果, 成分のアクセス時間に大きな差が出てくる. 
成分アクセスは, リストでは, 成分の量が増えるに従って
時間がかかるようになるが, ベクトルでは, 成分の量に依存せずほぼ一定である. 
@item
@b{Asir} では, 縦ベクトル, 横ベクトルの区別はない. 
行列を左から掛ければ縦ベクトルとみなされるし, 右から掛ければ横ベクトルと
みなされる. 
@item
ベクトルの長さは @code{size()} によって得られる. 
@item
函数の引数としてベクトルを渡した場合, 渡された函数は, そのベクトルの成分
を書き換えることができる. 
\E
\BEG
@item 
Creates a new vector object with its length @var{len} and its elements
all cleared to value 0.
If the second argument, a list, is given, the vector is initialized by
the list elements.
Elements are used from the first through the last.
If the list is short for initializing the full vector,
0's are filled in the remaining vector elements.
@item 
Elements are indexed from 0 through @var{len}-1.  Note that the first
element has not index 1.
@item 
List and vector are different types in @b{Asir}.
Lists are conveniently used for representing many data objects whose
size varies dynamically as computation proceeds.
By its flexible expressive power, it is also conveniently used to
describe initial values for other structured objects as you see
for vectors.
Access for an element of a list is performed by following pointers to
next elements.  By this, access costs for list elements differ for
each element.
In contrast to lists, vector elements can be accessed in a same time,
because they are accessed by computing displacements from the top memory
location of the vector object.
      
Note also, in @b{Asir}, modification of an element of a vector causes
modification of the whole vector itself,
while modification of a list element does not cause the modification
of the whole list object.
      
By this, in @b{Asir} language,
a vector element designator can be a left value of
assignment statement, but a list element designator can NOT be a left
value of assignment statement.
      
@item
No distinction of column vectors and row vectors in @b{Asir}.
If a matrix is applied to a vector from left, the vector shall be taken
as a column vector, and if from right it shall be taken as a row vector.
@item
The length (or size or dimension) of a vector is given by function
@code{size()}.
@item 
When a vector is passed to a function as its argument
(actual parameter), the vector element can be modified in that
function.
      
@item
A vector is displayed in a similar format as for a list.
Note, however, there is a distinction: Elements of a vector are
separated simply by a `blank space', while those of a list by a `comma.'
\E
@end itemize

@example
[0] A=newvect(5);
[ 0 0 0 0 0 ]
[1] A=newvect(5,[1,2,3,4,[5,6]]);
[ 1 2 3 4 [5,6] ]
[2] A[0];
1
[3] A[4];
[5,6]
[4] size(A);
[5]
[5] def afo(V) @{ V[0] = x; @}
[6] afo(A)$
[7] A;
[ x 2 3 4 [5,6] ]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{newmat}, @fref{size}.
@end table

\JP @node vtol,,, 配列
\EG @node vtol,,, Arrays
@subsection @code{vtol}
@findex vtol

@table @t
@item vtol(@var{vect})
\JP :: ベクトルをリストに変換する. 
\EG :: Converts a vector into a list.
@end table

@table @var
@item return
\JP リスト
\EG list
@item vect
\JP ベクトル
\EG vector
@end table

@itemize @bullet
\BJP
@item
長さ @var{n} のベクトル @var{vect} を
 @code{[@var{vect}[0],...,@var{vect}[@var{n}-1]]} なるリストに変換する. 
@item
リストからベクトルへの変換は @code{newvect()} で行う. 
\E
\BEG
@item 
Converts a vector @var{vect} of length @var{n} into
a list @code{[@var{vect}[0],...,@var{vect}[@var{n}-1]]}.
@item 
A conversion from a list to a vector is done by @code{newvect()}.
\E
@end itemize

@example
[3] A=newvect(3,[1,2,3]);
[ 1 2 3 ]
[4] vtol(A);
[1,2,3]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{newvect}.
@end table

\JP @node newmat,,, 配列
\EG @node newmat,,, Arrays
@subsection @code{newmat}
@findex newmat

@table @t
@item newmat(@var{row},@var{col} [,@var{[[a,b,}...@var{],[c,d,}...@var{],}...@var{]}])
\JP :: @var{row} 行 @var{col} 列の行列を生成する. 
\EG :: Creates a new matrix with @var{row} rows and @var{col} columns.
@end table

@table @var
@item return
\JP 行列
\EG matrix
@item row,col
\JP 自然数
\EG non-negative integer
@item a,b,c,d
\JP 任意
\EG arbitrary
@end table

@itemize @bullet
\BJP
@item
@var{row} 行 @var{col} 列の行列を生成する. 第 3 引数がない場合, 
各成分は 0 に初期化される. 第 3 引数がある場合, 
インデックスの小さい成分から, 各行が, リストの
各要素 (これはまたリストである) により初期化される. 各要素は, 先頭から順に
使われ, 足りない分は 0 が埋められる. 
@item
行列のサイズは @code{size()} で得られる. 
@item
@code{M} が行列のとき, @code{M[I]} により第 @code{I} 行をベクトルとして
取り出すことができる. このベクトルは, もとの行列と成分を共有しており, 
いずれかの成分を書き換えれば, 他の対応する成分も書き換わることになる. 
@item
函数の引数として行列を渡した場合, 渡された函数は, その行列の成分
を書き換えることができる. 
\E
\BEG
@item 
If the third argument, a list, is given, the newly created matrix
is initialized so that each element of the list (again a list)
initializes each of the rows of the matrix.
Elements are used from the first through the last.
If the list is short, 0's are filled in the remaining matrix elements.
If no third argument is given all the elements are cleared to 0.
@item 
The size of a matrix is given by function  @code{size()}.
@item 
Let @code{M} be a program variable assigned to a matrix.
Then, @code{M[I]} denotes a (row) vector which corresponds with
the @code{I}-th row of the matrix.
Note that the vector shares its element with the original matrix.
Subsequently, if an element of the vector is modified, then the
corresponding matrix element is also modified.
@item 
When a matrix is passed to a function as its argument
(actual parameter), the matrix element can be modified within that
function.
\E
@end itemize

@example
[0] A = newmat(3,3,[[1,1,1],[x,y],[x^2]]);
[ 1 1 1 ]
[ x y 0 ]
[ x^2 0 0 ]
[1] det(A);
-y*x^2
[2] size(A);
[3,3]
[3] A[1];
[ x y 0 ]
[4] A[1][3];
getarray : Out of range
return to toplevel
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{newvect}, @fref{size}, @fref{det}.
@end table

\JP @node size,,, 配列
\EG @node size,,, Arrays
@subsection @code{size}
@findex size

@table @t
@item size(@var{vect|mat})
\JP :: @code{[@var{vect} の長さ]} または @code{[@var{mat} の行数,@var{mat} の列数]}. 
\BEG
:: A list containing the number of elements of the given vector,
@code{[size of @var{vect}]},
or a list containing row size and column size of the given matrix,
@code{[row size of @var{mat}, column size of @var{mat}]}.
\E
@end table

@table @var
@item return
\JP リスト
\EG list
@item vect
\JP ベクトル
\EG vector
@item mat
\JP 行列
\EG matrix
@end table

@itemize @bullet
\BJP
@item
@var{vect} 又は, @var{mat} のサイズをリストで出力する. 
@item
@var{list} のサイズは @code{length()}を, 有理式に現れる単項式の数は @code{nmono()} を用いる. 
\E
\BEG
@item 
Return a list consisting of the dimension of the vector @var{vect},
or a list consisting of the row size and column size of the matrix
@var{matrix}.
@item 
Use @code{length()} for the size of @var{list}, and
@code{nmono()} for the number of monomials with non-zero coefficients
in a rational expression.
\E
@end itemize

@example
[0] A = newvect(4);
[ 0 0 0 0 ]
[1] size(A);
[4]
[2] B = newmat(2,3,[[1,2,3],[4,5,6]]);
[ 1 2 3 ]
[ 4 5 6 ]
[3] size(B);
[2,3]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{car cdr cons append reverse length}, @fref{nmono}.
@end table

\JP @node det,,, 配列
\EG @node det,,, Arrays
@subsection @code{det}
@findex det

@table @t
@item det(@var{mat}[,@var{mod}])
\JP :: @var{mat} の行列式を求める. 
\EG :: Determinant of @var{mat}.
@end table

@table @var
@item return
\JP 式
\EG expression
@item mat
\JP 行列
\EG matrix
@item mod
\JP 素数
\EG prime
@end table

@itemize @bullet
\BJP
@item
行列 @var{mat} の行列式を求める. 
@item
引数 @var{mod} がある時, GF(@var{mod}) 上での行列式を求める. 
@item
分数なしのガウス消去法によっているため, 多変数多項式を成分とする
行列に対しては小行列式展開による方法のほうが効率がよい場合もある. 
\E
\BEG
@item 
Determinant of matrix @var{mat}.
@item 
The computation is done over GF(@var{mod}) if @var{mod} is specitied.
@item 
The fraction free Gaussian algorithm is employed.  For matrices with
multi-variate polynomial entries, minor expansion algorithm sometimes
is more efficient than the fraction free Gaussian algorithm.
\E
@end itemize

@example
[91] A=newmat(5,5)$                         
[92] V=[x,y,z,u,v];
[x,y,z,u,v]
[93] for(I=0;I<5;I++)for(J=0,B=A[I],W=V[I];J<5;J++)B[J]=W^J;
[94] A;
[ 1 x x^2 x^3 x^4 ]
[ 1 y y^2 y^3 y^4 ]
[ 1 z z^2 z^3 z^4 ]
[ 1 u u^2 u^3 u^4 ]
[ 1 v v^2 v^3 v^4 ]
[95] fctr(det(A));
[[1,1],[u-v,1],[-z+v,1],[-z+u,1],[-y+u,1],[y-v,1],[-y+z,1],[-x+u,1],[-x+z,1],
[-x+v,1],[-x+y,1]]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{newmat}.
@end table

\JP @node qsort,,, 配列
\EG @node qsort,,, Arrays
@subsection @code{qsort}
@findex qsort

@table @t
@item qsort(@var{array}[,@var{func}]) 
\JP :: 一次元配列 @var{array} をソートする. 
\EG :: Sorts an array @var{array}.
@end table

@table @var
@item return
\JP @var{array} (入力と同じ; 要素のみ入れ替わる)
\EG @var{array} (The same as the input; Only the elements are exchanged.)
@item array
\JP 一次元配列
\EG array
@item func
\JP 比較用関数
\EG function for comparison
@end table

@itemize @bullet
\BJP
@item
一次元配列を quick sort でソートする. 
@item
比較用関数が指定されていない場合, オブジェクトどうしの比較結果で
順序が下のものから順に並べ換えられる. 
@item
0, 1, -1 を返す 2 引数関数が @var{func} として与えられた場合, 
@code{@var{func}(A,B)=1} の場合に @code{A<B} として, 順序が下の
ものから順に並べ換えられる. 
@item
配列は新たに生成されず, 引数の配列の要素のみ入れ替わる. 
\E
\BEG
@item
This function sorts an array by @var{quick sort}.
@item
If @var{func} is not specified, the built-in comparison function
is used and the array is sorted in increasing order.
@item
If a function of two arguments @var{func} which returns 0, 1, or -1
is provided, then an ordering is detemined so that
@code{A<B} if @code{@var{func}(A,B)=1} holds, and
the array is sorted in increasing order with respect to the ordering.
@item
The returned array is the same as the input. Only the elements
are exchanged.
\E
@end itemize

@example
[0] qsort(newvect(10,[1,4,6,7,3,2,9,6,0,-1]));
[ -1 0 1 2 3 4 6 6 7 9 ]
[1] def rev(A,B) @{ return A>B?-1:(A<B?1:0); @}
[2] qsort(newvect(10,[1,4,6,7,3,2,9,6,0,-1]),rev);
[ 9 7 6 6 4 3 2 1 0 -1 ]
@end example

@table @t
\JP @item 参照
\EG @item References
@fref{ord}, @fref{vars}.
@end table
