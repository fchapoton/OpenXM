@node 配列,,, 組み込み函数
@section 配列

@menu
* newvect::
* vtol::
* newmat::
* size::
* det::
* qsort::
@end menu

@node newvect,,, 配列
@subsection @code{newvect}
@findex newvect

@table @t
@item newvect(@var{len}[,@var{list}])
:: 長さ @var{len} のベクトルを生成する. 
@end table

@table @var
@item return
ベクトル
@item len
自然数
@item list
リスト
@end table

@itemize @bullet
@item
長さ @var{len} のベクトルを生成する. 第 2 引数がない場合, 
各成分は 0 に初期化される. 第 2 引数がある場合, 
インデックスの小さい成分から, リストの
各要素により初期化される. 各要素は, 先頭から順に
使われ, 足りない分は 0 が埋められる. 
@item
ベクトルの成分は, 第 0 成分から第 @var{len}-1 成分となる. 
(第 1 成分からではない事に注意. )
@item
リストは各成分が, ポインタを辿る事によってシーケンシャルに
呼び出されるのに対し, ベクトルは各成分が
第一成分からのメモリ上の displacement (変位)によってランダムアクセスで
呼び出され, その結果, 成分のアクセス時間に大きな差が出てくる. 
成分アクセスは, リストでは, 成分の量が増えるに従って
時間がかかるようになるが, ベクトルでは, 成分の量に依存せずほぼ一定である. 
@item
@b{Asir} では, 縦ベクトル, 横ベクトルの区別はない. 
行列を左から掛ければ縦ベクトルとみなされるし, 右から掛ければ横ベクトルと
みなされる. 
@item
ベクトルの長さは @code{size()} によって得られる. 
@item
函数の引数としてベクトルを渡した場合, 渡された函数は, そのベクトルの成分
を書き換えることができる. 
@end itemize

@example
[0] A=newvect(5);
[ 0 0 0 0 0 ]
[1] A=newvect(5,[1,2,3,4,[5,6]]);
[ 1 2 3 4 [5,6] ]
[2] A[0];
1
[3] A[4];
[5,6]
[4] size(A);
[5]
[5] def afo(V) @{ V[0] = x; @}
[6] afo(A)$
[7] A;
[ x 2 3 4 [5,6] ]
@end example

@table @t
@item 参照
@fref{newmat}, @fref{size}.
@end table

@node vtol,,, 配列
@subsection @code{vtol}
@findex vtol

@table @t
@item vtol(@var{vect})
:: ベクトルをリストに変換する. 
@end table

@table @var
@item return
リスト
@item vect
ベクトル
@end table

@itemize @bullet
@item
長さ @var{n} のベクトル @var{vect} を
 @code{[@var{vect}[0],...,@var{vect}[@var{n}-1]]} なるリストに変換する. 
@item
リストからベクトルへの変換は @code{newvect()} で行う. 
@end itemize

@example
[3] A=newvect(3,[1,2,3]);
[ 1 2 3 ]
[4] vtol(A);
[1,2,3]
@end example

@table @t
@item 参照
@fref{newvect}.
@end table

@node newmat,,, 配列
@subsection @code{newmat}
@findex newmat

@table @t
@item newmat(@var{row},@var{col} [,@var{[[a,b,}...@var{],[c,d,}...@var{],}...@var{]}])
:: @var{row} 行 @var{col} 列の行列を生成する. 
@end table

@table @var
@item return
行列
@item row,col
自然数
@item a,b,c,d
任意
@end table

@itemize @bullet
@item
@var{row} 行 @var{col} 列の行列を生成する. 第 3 引数がない場合, 
各成分は 0 に初期化される. 第 3 引数がある場合, 
インデックスの小さい成分から, 各行が, リストの
各要素 (これはまたリストである) により初期化される. 各要素は, 先頭から順に
使われ, 足りない分は 0 が埋められる. 
@item
行列のサイズは @code{size()} で得られる. 
@item
@code{M} が行列のとき, @code{M[I]} により第 @code{I} 行をベクトルとして
取り出すことができる. このベクトルは, もとの行列と成分を共有しており, 
いずれかの成分を書き換えれば, 他の対応する成分も書き換わることになる. 
@item
函数の引数として行列を渡した場合, 渡された函数は, その行列の成分
を書き換えることができる. 
@end itemize

@example
[0] A = newmat(3,3,[[1,1,1],[x,y],[x^2]]);
[ 1 1 1 ]
[ x y 0 ]
[ x^2 0 0 ]
[1] det(A);
-y*x^2
[2] size(A);
[3,3]
[3] A[1];
[ x y 0 ]
[4] A[1][3];
getarray : Out of range
return to toplevel
@end example

@table @t
@item 参照
@fref{newvect}, @fref{size}, @fref{det}.
@end table

@node size,,, 配列
@subsection @code{size}
@findex size

@table @t
@item size(@var{vect|mat})
:: @code{[@var{vect} の長さ]} または @code{[@var{mat} の行数,@var{mat} の列数]}. 
@end table

@table @var
@item return
リスト
@item vect
ベクトル
@item mat
行列
@end table

@itemize @bullet
@item
@var{vect} 又は, @var{mat} のサイズをリストで出力する. 
@item
@var{list} のサイズは @code{length()}を, 有理式に現れる単項式の数は @code{nmono()} を用いる. 
@end itemize

@example
[0] A = newvect(4);
[ 0 0 0 0 ]
[1] size(A);
[4]
[2] B = newmat(2,3,[[1,2,3],[4,5,6]]);
[ 1 2 3 ]
[ 4 5 6 ]
[3] size(B);
[2,3]
@end example

@table @t
@item 参照
@fref{car cdr cons append reverse length}, @fref{nmono}.
@end table

@node det,,, 配列
@subsection @code{det}
@findex det

@table @t
@item det(@var{mat}[,@var{mod}])
:: @var{mat} の行列式を求める. 
@end table

@table @var
@item return
式
@item mat
行列
@item mod
素数
@end table

@itemize @bullet
@item
行列 @var{mat} の行列式を求める. 
@item
引数 @var{mod} がある時, GF(@var{mod}) 上での行列式を求める. 
@item
分数なしのガウス消去法によっているため, 多変数多項式を成分とする
行列に対しては小行列式展開による方法のほうが効率がよい場合もある. 
@end itemize

@example
[91] A=newmat(5,5)$                         
[92] V=[x,y,z,u,v];
[x,y,z,u,v]
[93] for(I=0;I<5;I++)for(J=0,B=A[I],W=V[I];J<5;J++)B[J]=W^J;
[94] A;
[ 1 x x^2 x^3 x^4 ]
[ 1 y y^2 y^3 y^4 ]
[ 1 z z^2 z^3 z^4 ]
[ 1 u u^2 u^3 u^4 ]
[ 1 v v^2 v^3 v^4 ]
[95] fctr(det(A));
[[1,1],[u-v,1],[-z+v,1],[-z+u,1],[-y+u,1],[y-v,1],[-y+z,1],[-x+u,1],[-x+z,1],
[-x+v,1],[-x+y,1]]
@end example

@table @t
@item 参照
@fref{newmat}.
@end table

@node qsort,,, 配列
@subsection @code{qsort}
@findex qsort

@table @t
@item qsort(@var{array}[,@var{func}]) 
:: 一次元配列 @var{array} をソートする. 
@end table

@table @var
@item return
@var{array} (入力と同じ; 要素のみ入れ替わる)
@item array
一次元配列
@item func
比較用関数
@end table

@itemize @bullet
@item
一次元配列を quick sort でソートする. 
@item
比較用関数が指定されていない場合, オブジェクトどうしの比較結果で
順序が下のものから順に並べ換えられる. 
@item
0, 1, -1 を返す 2 引数関数が @var{func} として与えられた場合, 
@code{@var{func}(A,B)=1} の場合に @code{A<B} として, 順序が下の
ものから順に並べ換えられる. 
@item
配列は新たに生成されず, 引数の配列の要素のみ入れ替わる. 
@end itemize

@example
[0] qsort(newvect(10,[1,4,6,7,3,2,9,6,0,-1]));
[ -1 0 1 2 3 4 6 6 7 9 ]
[1] def rev(A,B) @{ return A>B?-1:(A<B?1:0); @}
[2] qsort(newvect(10,[1,4,6,7,3,2,9,6,0,-1]),rev);
[ 9 7 6 6 4 3 2 1 0 -1 ]
@end example

@table @t
@item 参照
@fref{ord}, @fref{vars}.
@end table
