@node 一変数多項式の演算,,, 組み込み函数
@section 一変数多項式の演算

@menu
* umul umul_ff usquare usquare_ff utmul utmul_ff::
* kmul ksquare ktmul::
* utrunc udecomp ureverse::
* set_upkara set_uptkara set_upfft::
* uinv_as_power_series ureverse_inv_as_power_series::
* udiv urem urembymul urembymul_precomp ugcd::
@end menu

@node umul umul_ff usquare usquare_ff utmul utmul_ff,,, 一変数多項式の演算
@subsection @code{umul}, @code{umul_ff}, @code{usquare}, @code{usquare_ff}, @code{utmul}, @code{utmul_ff}
@findex umul
@findex umul_ff
@findex usquare
@findex usquare_ff
@findex utmul
@findex utmul_ff

@table @t
@item umul(@var{p1},@var{p2}) 
@itemx umul_ff(@var{p1},@var{p2}) 
:: 一変数多項式の高速乗算
@item usquare(@var{p1})
@itemx usquare_ff(@var{p1})
:: 一変数多項式の高速 2 乗算
@item utmul(@var{p1},@var{p2},@var{d}) 
@itemx utmul_ff(@var{p1},@var{p2},@var{d}) 
:: 一変数多項式の高速乗算 (打ち切り次数指定)
@end table

@table @var
@item return
一変数多項式
@item p1 p2
一変数多項式
@item d
非負整数
@end table

@itemize @bullet
@item
一変数多項式の乗算を, 次数に応じて決まるアルゴリズムを用いて
高速に行う. 
@item
@code{umul()}, @code{usquare()}, @code{utmul()} は
係数を整数と見なして, 整数係数の多項式として積を求める. 
係数が有限体 GF(p) の元の場合には, 係数は 0 以上 p 未満の整数と見なされる. 
@item
@code{umul_ff()}, @code{usquare_ff()}, @code{utmul_ff()} は,
係数を有限体の元と見なして, 有限体上の多項式として
積を求める. ただし, 引数が全く有限体の元を含まない場合には, 
整数係数の多項式を返す場合もあるので, これらを呼び出した結果
が有限体係数であることを保証するためには
あらかじめ @code{simp_ff()} で係数を有限体の元に変換しておくとよい. 
@item
@code{umul_ff()}, @code{usquare_ff()}, @code{utmul_ff()} は, 
GF(2^n) 係数の多項式を引数に取れない. 
@item
@code{umul()}, @code{umul_ff()} の結果は @var{p1}, @var{p2} の積, 
@code{usquare()}, @code{usquare_ff()} の結果は @var{p1} の 2 乗, 
@code{utmul()}, @code{utmul_ff()} の結果は @var{p1}, @var{p2} の積
の, @var{d} 次以下の部分となる. 
@item
いずれも, @code{set_upkara()} (@code{utmul}, @code{utmul_ff} については
@code{set_uptkara()}) で返される値以下の次数に対しては通常の筆算
形式の方法, @code{set_uufft()} で返される値以下の次数に対しては Karatsuba
法, それ以上では FFTおよび中国剰余定理が用いられる. すなわち, 
整数に対する FFT ではなく, 十分多くの 1 ワード以内の法 @var{mi} を用意し, 
@var{p1}, @var{p2} の係数を @var{mi} で割った余りとしたものの積を, 
FFT で計算し, 最後に中国剰余定理で合成する. その際, 有限体版の関数に
おいては, 最後に基礎体を表す法で各係数の剰余を計算するが, ここでは
Shoup によるトリックを用いて高速化してある. 
@end itemize

@example
[176] load("fff")$
[177] cputime(1)$
0sec(1.407e-05sec)
[178] setmod_ff(2^160-47);
1461501637330902918203684832716283019655932542929
0sec(0.00028sec)
[179] A=randpoly_ff(100,x)$
0sec(0.001422sec)
[180] B=randpoly_ff(100,x)$
0sec(0.00107sec)
[181] for(I=0;I<100;I++)A*B;
7.77sec + gc : 8.38sec(16.15sec)
[182] for(I=0;I<100;I++)umul(A,B);
2.24sec + gc : 1.52sec(3.767sec)
[183] for(I=0;I<100;I++)umul_ff(A,B);
1.42sec + gc : 0.24sec(1.653sec)
[184] for(I=0;I<100;I++)usquare_ff(A);  
1.08sec + gc : 0.21sec(1.297sec)
[185] for(I=0;I<100;I++)utmul_ff(A,B,100);
1.2sec + gc : 0.17sec(1.366sec)
[186] deg(utmul_ff(A,B,100),x);
100
@end example

@table @t
@item 参照
@fref{set_upkara set_uptkara set_upfft},
@fref{kmul ksquare ktmul}.
@end table

@node kmul ksquare ktmul,,, 一変数多項式の演算
@subsection @code{kmul}, @code{ksquare}, @code{ktmul}
@findex kmul
@findex ksquare
@findex ktmul

@table @t
@item kmul(@var{p1},@var{p2}) 
:: 一変数多項式の高速乗算
@item ksquare(@var{p1})
:: 一変数多項式の高速 2 乗算
@item ktmul(@var{p1},@var{p2},@var{d}) 
:: 一変数多項式の高速乗算 (打ち切り次数指定)
@end table

@table @var
@item return
一変数多項式
@item p1 p2
一変数多項式
@item d
非負整数
@end table

@itemize @bullet
@item
一変数多項式の乗算を Karatsuba 法で行う. 
@item
基本的には @code{umul} と同様だが, 次数が大きくなっても
FFT を用いた高速化は行わない. 
@item
GF(2^n) 係数の多項式にも用いることができる. 
@end itemize

@example
[0] load("code/fff");
1
[34] setmod_ff(defpoly_mod2(160));
x^160+x^5+x^3+x^2+1
[35] A=randpoly_ff(100,x)$
[36] B=randpoly_ff(100,x)$
[37] umul(A,B)$
umul : invalid argument
return to toplevel
[37] kmul(A,B)$
@end example

@node set_upkara set_uptkara set_upfft,,, 一変数多項式の演算
@subsection @code{set_upkara}, @code{set_uptkara}, @code{set_upfft}
@findex set_upkara
@findex set_uptkara
@findex set_upfft

@table @t
@item set_upkara([@var{threshold}])
@itemx set_uptkara([@var{threshold}])
@itemx set_upfft([@var{threshold}])
:: 1 変数多項式の積演算における N^2 , Karatsuba, FFT アルゴリズムの切替えの閾値
@end table

@table @var
@item return
設定されている値
@item threshold
非負整数
@end table

@itemize @bullet
@item
いずれも, 一変数多項式の積の計算における, アルゴリズム切替えの閾値を
設定する. 
@item
一変数多項式の積は, 次数 N が小さい範囲では通常の N^2 アルゴリズム, 中程度
の場合 Karatsuba アルゴリズム, 大きい場合には FFT アルゴリズムで計算
される. この切替えの次数を設定する. 
@item
詳細は, それぞれの積関数の項を参照のこと. 
@end itemize

@table @t
@item 参照
@fref{kmul ksquare ktmul},
@fref{umul umul_ff usquare usquare_ff utmul utmul_ff}.
@end table

@node utrunc udecomp ureverse,,, 一変数多項式の演算
@subsection @code{utrunc}, @code{udecomp}, @code{ureverse}
@findex utrunc
@findex udecomp
@findex ureverse

@table @t
@item utrunc(@var{p},@var{d}) 
@itemx udecomp(@var{p},@var{d}) 
@itemx ureverse(@var{p})
:: 多項式に対する操作
@end table

@table @var
@item return
一変数多項式あるいは一変数多項式のリスト
@item p
一変数多項式
@item d
非負整数
@end table

@itemize @bullet
@item
@var{p} の変数を x とする. このとき @var{p} = @var{p1}+x^(d+1)@var{p2}
(@var{p1} の次数は @var{d} 以下) と分解できる. @code{utrunc()} は
@var{p1} を返し, @code{udecomp()} は [@var{p1},@var{p2}] を返す. 
@item
@var{p} の次数を @var{e} とし, @var{i} 次の係数を @var{p[i]} とすれば, 
@code{ureverse()} は @var{p[e]}+@var{p[e-1]}x+... を返す. 
@end itemize

@example
[132] utrunc((x+1)^10,5);
252*x^5+210*x^4+120*x^3+45*x^2+10*x+1
[133] udecomp((x+1)^10,5);
[252*x^5+210*x^4+120*x^3+45*x^2+10*x+1,x^4+10*x^3+45*x^2+120*x+210]
[134] ureverse(3*x^3+x^2+2*x);
2*x^2+x+3
@end example

@table @t
@item 参照
@fref{udiv urem urembymul urembymul_precomp ugcd}.
@end table

@node uinv_as_power_series ureverse_inv_as_power_series,,, 一変数多項式の演算
@subsection @code{uinv_as_power_series}, @code{ureverse_inv_as_power_series}
@findex uinv_as_power_series
@findex ureverse_inv_as_power_series

@table @t
@item uinv_as_power_series(@var{p},@var{d}) 
@itemx ureverse_inv_as_power_series(@var{p},@var{d})
:: 多項式を冪級数とみて, 逆元計算
@end table

@table @var
@item return
一変数多項式
@item p
一変数多項式
@item d
非負整数
@end table

@itemize @bullet
@item
@code{uinv_as_power_series(@var{p},@var{d})} は, 定数項が 0 でない
多項式 @var{p} に対し, @var{p}@var{r}-1 の最低次数が @var{d}+1
以上になるような 高々 @var{d} 次の多項式 @var{r} を求める. 
@item
@code{ureverse_inv_as_power_series(@var{p},@var{d})} は
@var{p} の次数を @var{e} とするとき, @var{p1}=@code{ureverse(@var{p},@var{e})}
に対して @code{uinv_as_power_series(@var{p1},@var{d})} を計算する. 
@item
@code{rembymul_precomp()} の引数として用いる場合, @code{ureverse_inv_as_power_series()} の結果をそのまま用いることができる. 
@end itemize

@example
[123] A=(x+1)^5;                 
x^5+5*x^4+10*x^3+10*x^2+5*x+1
[124] uinv_as_power_series(A,5); 
-126*x^5+70*x^4-35*x^3+15*x^2-5*x+1
[126] A*R;
-126*x^10-560*x^9-945*x^8-720*x^7-210*x^6+1
[127] A=x^10+x^9;
x^10+x^9
[128] R=ureverse_inv_as_power_series(A,5);
-x^5+x^4-x^3+x^2-x+1
[129] ureverse(A)*R;
-x^6+1
@end example

@table @t
@item 参照
@fref{utrunc udecomp ureverse},
@fref{udiv urem urembymul urembymul_precomp ugcd}.
@end table

@node udiv urem urembymul urembymul_precomp ugcd,,, 一変数多項式の演算
@subsection @code{udiv}, @code{urem}, @code{urembymul}, @code{urembymul_precomp}, @code{ugcd}
@findex udiv
@findex urem
@findex urembymul
@findex urembymul_precomp
@findex ugcd

@table @t
@item udiv(@var{p1},@var{p2}) 
@item urem(@var{p1},@var{p2}) 
@item urembymul(@var{p1},@var{p2}) 
@item urembymul_precomp(@var{p1},@var{p2},@var{inv}) 
@item ugcd(@var{p1},@var{p2}) 
:: 多項式に対する操作
@end table

@table @var
@item return
一変数多項式
@item p1,p2,inv
一変数多項式
@end table

@itemize @bullet
@item
一変数多項式 @var{p1}, @var{p2} に対し, 
@code{udiv} は商, @code{urem}, @code{urembymul} は剰余, 
@code{ugcd} は GCD を返す. 
これらは, 密な一変数多項式に対する高速化を図ったものである. 
@code{urembymul} は, @var{p2} による剰余計算を, @var{p2} の
冪級数としての逆元計算および, 乗算 2 回に置き換えたもので, 
次数が大きい場合に有効である. 
@item @code{urembymul_precomp} は, 固定された多項式による剰余
計算を多数行う場合などに効果を発揮する. 
@end itemize

@example
[177] setmod_ff(2^160-47);
1461501637330902918203684832716283019655932542929
[178] A=randpoly_ff(200,x)$
[179] B=randpoly_ff(101,x)$
[180] cputime(1)$
0sec(1.597e-05sec)
[181] srem(A,B)$
0.15sec + gc : 0.15sec(0.3035sec)
[182] urem(A,B)$
0.11sec + gc : 0.12sec(0.2347sec)
[183] urembymul(A,B)$          
0.08sec + gc : 0.09sec(0.1651sec)
[184] R=ureverse_inv_as_power_series(B,101)$
0.04sec + gc : 0.03sec(0.063sec)
[185] urembymul_precomp(A,B,R)$             
0.03sec(0.02501sec)
@end example

@table @t
@item 参照
@fref{uinv_as_power_series ureverse_inv_as_power_series}.
@end table
