%% $OpenXM: OpenXM/src/asir-doc/exp/exp-ja.texi,v 1.58 2020/09/06 03:26:47 noro Exp $
\input texinfo-ja
@iftex
@catcode`@#=6
@def@fref#1{@xrefX[#1,,@code{#1},,,]}
@def@b#1{{@bf #1}}
@catcode`@#=@other
@end iftex
@overfullrule=0pt
@c -*-texinfo-*-
@comment %**start of header
@comment --- おまじない終り ---

@comment --- GNU info ファイルの名前 ---
@setfilename exp
@documentlanguage ja

@comment --- タイトル ---
@settitle 実験的仕様の関数

@comment %**end of header
@comment %@setchapternewpage odd

@comment --- おまじない ---
@ifinfo
@macro fref{name}
@ref{\name\,,@code{\name\}}
@end macro
@end ifinfo

@iftex
@comment @finalout
@end iftex

@titlepage
@comment --- おまじない終り ---

@comment --- タイトル, バージョン, 著者名, 著作権表示 ---
@title 実験的仕様の関数
@subtitle Risa/Asir 実験的仕様関数説明書
@subtitle 1.0 版
@subtitle 2018 年 3 月

@author  by Risa/Asir committers
@page
@vskip 0pt plus 1filll
Copyright @copyright{} Risa/Asir committers
2004--2018. All rights reserved.
@end titlepage

@comment --- おまじない ---
@synindex vr fn
@comment --- おまじない終り ---

@comment --- @node は GNU info, HTML 用 ---
@comment --- @node  の引数は node-name,  next,  previous,  up ---
@node Top,, (dir), (dir)

@comment --- @menu は GNU info, HTML 用 ---
@comment --- chapter 名を正確に並べる ---
@comment --- この文書では chapter XYZ, Chapter Index がある.
@comment ---  Chapter XYZ には section XYZについて, section XYZに関する関数がある.
@menu
* 実験的仕様の関数説明書について::
* 実験的仕様の関数::
* Index::
@end menu

@comment --- chapter の開始 ---
@comment --- 親 chapter 名を正確に. 親がない場合は Top ---
@node 実験的仕様の関数説明書について,,, Top
@chapter 実験的仕様の関数説明書について

この説明書では
@b{Asir} に導入された実験的仕様の関数について説明する.
正式な関数として導入されたものの記述は Risa/Asir マニュアル
に移動される.
ChangeLog の項目は www.openxm.org の cvsweb で
ソースコードを読む時の助けになる情報が書かれている.

@node 実験的仕様の関数,,, Top
@chapter 実験的仕様の関数

@comment --- section ``実験的関数'' の subsection xyz_abc
@comment --- subsection xyz_pqr xyz_stu がある.
@menu
* asir-port.sh asir-install.sh::
* asirgui.hnd::
* chdir pwd::
* copyright::
* dcurrenttime::
* dp_gr_main::
* dp_initial_term::
* dp_order::
* dp_weyl_gr_main::
* eval_quote::
* f_res::
* fj_simplify.simplify::
* flatten_quote::
* function::
* get_struct_name get_element_names get_element_at put_element_at::
* getpid::
* initialize_static_variable::
* list::
* mapat::
* nd_sba nd_sba_f4::
* nd_gr nd_gr_trace nd_weyl_gr nd_weyl_gr_trace (module)::
* nd_gr nd_gr_trace nd_weyl_gr nd_weyl_gr_trace (option)::
* noro_matrix.rr::
* nqt_comp::
* nqt_match::
* nqt_match_rewrite::
* objtoquote::
* ot_hgm_ahg.cbase::
* ot_hgm_ahg.get_mat2::
* ot_hgm_ahg.hgm_ahg_contiguity::
* pari setbprec setround todouble mpfr_gamma mpfr_floor mpfr_round::
* printf fprintf sprintf::
* qt_is_var qt_is_coef::
* qt_normalize::
* qt_rewrite::
* qt_set_coef::
* qt_set_ord::
* qt_set_weight::
* quote_to_funargs funargs_to_quote remove_paren get_function_name::
* quotetotex quotetotex_env::
* set_print_function::
* set_secure_flag set_secure_mode::
* small_jacobi::
* string_to_tb tb_to_string write_to_tb::
* tk_fd.abc2ahg::
* tk_fd.ahvec_abc::
* tk_hgpoly.hgpoly::
* tk_hgpoly.optip::
* tk_jack.zonal::
* tk_pfn.graph::
* tk_pfn.rkn::
* tk_rk.runge_kutta_4::
* tk_rk.runge_kutta_4_linear::
@end menu

@node クオート,,, 実験的仕様の関数
@section クオート

@comment --- ◯◯◯◯  関数 quotetotex, quotetotex_env の説明 ◯◯◯◯
@comment --- 個々の関数の説明の開始 ---
@comment --- section 名を正確に ---
@node quotetotex quotetotex_env,,, クオート
@subsection @code{quotetotex}, @code{quotetotex_env}
@comment --- 索引用キーワード
@findex quotetotex
@findex quotetotex_env

@comment --- 関数の簡単な説明 ---
@table @t
@item quotetotex(@var{q})
:: @var{q} を latex 形式で表現した文字列に変換する.
@item quotetotex_env(@var{key},@var{value})
:: quotetotex の動作を制御するパラメータを変更する.
@item quotetotex_env()
:: quotetotex の動作を制御するパラメータの現在値を戻す.
@item quotetotex_env(0)
:: quotetotex の動作を制御するパラメータをデフォールト値に戻す.
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item return
文字列(quotetotex) または リストまたはオブジェクト(quotetotex_env)
@item q
quote
@item key
文字列
@item value
オブジェクト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item
quotetotex は @var{q} を latex 形式で表現した文字列に変換する.
@item
以下 quotetotex_env のパラメータの意味を説明する.
@item
conv_rule: 3 ビットを用いて変換ルールを指定する.
0ビット目は symbol_table による変換を行うか,
1ビット目は添字変換を行うか,
2ビット目は d から始まる変数名を微分作用素とみなして処理するか,
を意味する.
たとえば conv_rule として 3 を指定すると,
0ビット目, 1 ビット目が 1 となるので
symbol_table による変換を行い, 添字変換をおこなう.
添字変換は数字と英字の境目および _ 記号を区切りとする.
symbol_table による変換が最初に適用される.
alpha, beta, 等は自動的をギリシャ文字に変換するテーブルは
内蔵ずみ.
@item
  dp_vars_prefix: 分散表現多項式は
  @iftex
  @tex
  $x_0, x_1, \cdots$
  @end tex
  @end iftex
  @ifinfo
  x0, x1, ...
  @end ifinfo
  の多項式として latex 形式に変換されるがこの
  x の部分を変更する.
@item
  dp_vars_origin: インデックスの始まりの値を指定する.
  デフォールトは 0.
@item
dp_vars_hweyl: 分散表現多項式をワイル代数の元とみなして
latex 形式に変換する.
偶数個変数があるときは 最初の半分を
@iftex
@tex
$x_0, x_1, \cdots$
@end tex
に後半の半分を
@tex
$\partial_0, \partial_1, \cdots$
@end tex
@end iftex
@ifinfo
x0, x1, ... に後半の半分を dx0, dx1, ...
@end ifinfo
に変換する.
奇数個の場合は最後の変数が同時化変数として h で表示される.
@item
  dp_dvars_prefix: dp_vars_hweyl が 1 の時に後半部分の prefix を指定する.
  デフォールトは @tex $\partial$ @end tex
@item
  dp_dvars_origin: dp_vars_hweyl が 1 の時のインデックスの始まりの値.
@item
conv_func: ユーザ定義の変換関数をよぶ.
@end itemize

@comment --- @example〜@end example は実行例の表示 ---
@example
[3] quotetotex(quote(1/(x+1)));
\frac@{ 1@} @{ (  @{x@}+ 1)@}
[4]  quotetotex(objtoquote(diff(x^x,x)));
   @{x@}^@{  @{x@}- 1@}   @{x@}+  \log( @{x@})   @{x@}^@{ @{x@}@}
[5] quotetotex_env("conv_rule",3);
[6] quotetotex(objtoquote( (alpha2beta+x_i_j)^2));
  @{\alpha@}_@{2,\beta@}^@{ 2@} +   2  @{x@}_@{i,j@}  @{\alpha@}_@{2,\beta@}+  @{x@}_@{i,j@}^@{ 2@}
@end example

@comment --- 参照(リンク)を書く ---
@table @t
@item 参照
@ref{objtoquote}
print_tex_form(contrib)
@end table

@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
 この関数は 2004年2月末から3月にかけて asir を
 knoppix 版 texmacs に対応させるために書かれた.
 Asir-contrib の print_tex_form がその原型であり, それを効率化しまた
 出力形式を改善した.
 OpenXM/src/kxx/ox_texmacs.c, OpenXM/src/texmacs も参照.
@item
 OpenXM/src/asir-contrib/packages/src/noro_print.rr 1.1--1.8,
 noro_print_default.rr 1.1--1.3 も参照.
@item
 変更を受けたファイルは OpenXM_contrib2/asir2000 の下の次のファイル.
  builtin/strobj.c 1.14--1.43,
  include/ca.h 1.46, io/cexpr.c 1.18, io/pexpr.c 1.32, io.sexpr.c 1.29,
  parse/arith.c 1.12, parse/parse.h 1.28--1.29,
  parse/quote.c 1.7--1.8, 1.12.
@item
  knoppix/math は 福岡大学の濱田さんが中心となり開発されている.
@item
  dp_dvars_prefix, *_origin は builtin/strobj.c 1.46 で導入された.
@item
  Todo: quotetoterminalform (分散表現多項式の見易い出力).
@end itemize



@comment --- ◯◯◯◯  関数 objtoquote の説明 ◯◯◯◯
@node objtoquote,,, クオート
@subsection @code{objtoquote}
@findex objtoquote

@comment --- 関数の簡単な説明 ---
@table @t
@item objtoquote(@var{ob})
:: オブジェクトと quote 型のデータに変換する.
@end table

@table @var
@item return
quote
@item ob
オブジェクト
@end table

@itemize @bullet
@item
@code{objtoquote(ob)} は, @var{ob} を quote 型のデータに変換する.
@end itemize

@example
[1150] quotetolist(quote(1+2));
[b_op,+,[internal,1],[internal,2]]
[1151] quotetolist(objtoquote(1+x));
[b_op,+,[internal,x],[internal,1]]3
@end example

@table @t
@item 参照
@ref{quotetotex} @ref{quotetolist}
@end table

@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数は quotetotex の前処理をするために書かれた.
@item asir-contrib の関数 quote_to_quote も参照.
@item OpenXM_contrib2/asir2000/builtin/print.c 1.16.
@end itemize


@node flatten_quote,,, クオート
@subsection @code{flatten_quote}
@findex flatten_quote

@comment --- 関数の簡単な説明 ---
@table @t
@item flatten_quote(@var{q},@var{op})
:: quote の括弧をとりさる.
@end table

@table @var
@item return
Quote
@item q
Quote
@item op
演算子を表す文字列.
@end table

@itemize @bullet
@item
Quote 型のデータは木構造をしている
( quotetolist 参照 ).
@code{quote_flatten()} は, @var{q} の中にあられる演算子 @var{op}
の子供ノードを平等にする.
つまり演算子 @var{op} に関する括弧づけがあった場合それをすべてとりさる.
たとえば (1+2)+(3+4) という表現を 1+2+3+4 に変換する.
@item
 現在の実装では n-ary の演算子は定義されていないので,
 1+2+3 は実は 1+(2+3) と表現されている.
 つまり + 演算子は右結合的である.
@item  R=0; for (I=0; I<N; I++) R = R+ P[I]; なる足し算を繰り返すと,
  + は左結合的になる. 右結合的に変換するには flatten_quote を呼ぶ.
@item 名前は quote_flatten でなく flatten_quote である.
@end itemize

@example
[1288] flatten_quote(quote((1+2)+(3+4*(x+3))),"+");
quote(1+2+3+4*(x+3))
[1289] flatten_quote(quote( (x*y)*(p*3)-(x*y)*z),"*");
quote(x*y*p*3-x*y*z)
[1290] quotetolist(quote(1+2+3));
[b_op,+,[b_op,+,[internal,1],[internal,2]],[internal,3]]
@end example

@table @t
@item 参照
@ref{quotetolist}, @ref{print_tex_form}(contrib)
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
 この関数は 2004-7-7 から 2004-7-8 にかけて
 quote に関する操作を研究するために実験的に書かれた.
 OpenXM/fb で蓄積された公式の不要な括弧をとりはずし, tex 形式に変換するのに
 応用.
@item
 変更をうけたソースコードは
 builtin/strobj.c 1.47,
 parse/eval.c 1.35,
 parse/parse.h 1.31,
 parse/quote.c 1.14--1.16.
@end itemize


@node quote_to_funargs funargs_to_quote remove_paren get_function_name,,, クオート
@subsection @code{quote_to_funargs}, @code{funargs_to_quote}, @code{remove_paren}, @code{get_function_name}
@findex quote_to_funargs
@findex funargs_to_quote
@findex remove_paren
@findex get_function_name

@table @t
@item quote_to_funargs(@var{q})
::  quote を funarg 形式(リスト) へ.
@item funargs_to_quote(@var{f})
::  funarg 形式を quote へ.
@item get_function_name(@var{f})
::  funarg 形式の op を文字列へ.
@item remove_paren(@var{q})
::  上の関数を用いて書かれた余分な括弧を取り去る simplifier (asir-contrib マニュアルへ: todo)
@end table

@table @var
@item return
quote(funargs_to_quote, remove_paren) か リスト(quote_to_funargs)
@item q
quote
@item f
リスト
@end table

@itemize @bullet
@item
 @code{quote_to_funargs} は quote 型のデータ (内部的には FNODE) を
quote への復元可能な形でリストへ変換する.
@code{quotetolist} は quote をリストへ変換するが, 一部の情報を捨てるため
もとの quote の復元はできない.
@item
 @code{quote_to_funargs} の戻り値は [fid, op, arg1, arg2, ...]
なる形式をしている.
ここで op は node の名前であり,
関数 @code{get_function_name} を用いて人間が読める形式
で取りだせる.
たとえば @code{get_function_name(quote_to_funargs(quote(1+2))[1])}
は "+" を戻す.
@item
 名前@code{get_function_name} はそのうち変更されるだろう.
@item
 下の例で
 quote_to_funargs(FA[2]);
[34,[b_op,+,[internal,x],[internal,1]]]
となる.
34 は @code{I_PAREN} を意味する.
数と意味の対応表は @code{OpenXM/src/asir-contrib/packages/src/noro_simplify.rr}
または @code{OpenXM_contrib2/asir2000/parse/parse.h} を見よ.
以下の fid が 0, 1, 2, ... に対応づけられている.
        I_BOP, I_COP, I_AND, I_OR, I_NOT, I_CE,
        I_PRESELF, I_POSTSELF,
        I_FUNC, I_FUNC_OPT, I_IFUNC, I_MAP, I_RECMAP, I_PFDERIV,
        I_ANS, I_PVAR, I_ASSPVAR,
        I_FORMULA, I_LIST, I_STR, I_NEWCOMP, I_CAR, I_CDR, I_CAST,
        I_INDEX, I_EV, I_TIMER, I_GF2NGEN, I_GFPNGEN, I_GFSNGEN,
        I_LOP, I_OPT, I_GETOPT, I_POINT, I_PAREN, I_MINUS,
        I_NARYOP
@end itemize

次の例では (x+1)+(x+2) の括弧をはずして x+1+x+2 に変換している.
@example
[0] ctrl("print_quote",1) $

[1] Q=quote((x+1)+(x+2));
[b_op,+,[u_op,(),[b_op,+,[internal,x],[internal,1]]],
        [u_op,(),[b_op,+,[internal,x],[internal,2]]]]

[2] FA=quote_to_funargs(Q);
[0,<...quoted...>,
  [u_op,(),[b_op,+,[internal,x],[internal,1]]],
  [u_op,(),[b_op,+,[internal,x],[internal,2]]]]

[3] FA2=quote_to_funargs(FA[2])[1];
[b_op,+,[internal,x],[internal,1]]

[4] FA3=quote_to_funargs(FA[3])[1];
[b_op,+,[internal,x],[internal,2]]

[5] funargs_to_quote([FA[0],FA[1],FA2,FA3]);
[b_op,+,[b_op,+,[internal,x],[internal,1]],
        [b_op,+,[internal,x],[internal,2]]]
@end example

次の例は OpenXM/asir-contrib 版の asir で実行.
@example
[1287] load("noro_simplify.rr");
1
[1293] noro_simplify.remove_paren(quote( f(1-(x))));
quote(f(1-x))
@end example

funargs_to_quote を用いて既存の quote の子供を置き換えて
新しい quote をつくり出せる.
@example
[1184] R=quote_to_funargs(quote(a+(b+c)));
[0,<...quoted...>,<...quoted...>,<...quoted...>]
[1185] T=quote_to_funargs(quote(1+2));
[0,<...quoted...>,<...quoted...>,<...quoted...>]
[1186] funargs_to_quote([0,R[1],R[2],T[2]]);
quote(a+1)
@end example

@table @t
@item 参照
@ref{quotetolist}
@end table


@noindent
ChangeLog
@itemize @bullet
@item
 これらの関数は 2004-7-8 から開発のはじまっている quote の simplification 関連
 の実験的関数である.
 変更をうけたソースコードは多岐にわたるのでまだ書かない.
@item
 括弧を取り去る問題は OpenXM/fb が蓄えている公式を tex で綺麗に表示するのが動機の一つ.
@item
 2004-6-26 の計算代数セミナーにおいて, 中川さんが simplifier についていろいろ問題提起
をした (計算代数セミナービデオ参照).
@item parse/quote.c の strcut fid_spec fid_spec_tab[]
の部分に書いてある形式に @code{funargs_to_quote} は変換する.
@end itemize


@node eval_quote,,, クオート
@subsection @code{eval_quote}
@findex eval_quote

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item eval_quote(@var{Q});
:: quote 型データ @var{Q} を asir のオブジェクトに変換する.
@end table

@table @var
@item return
オブジェクト
@item Q
quote型
@end table

@itemize @bullet
@item quote 型データ @var{Q} を asir のオブジェクトに変換する.
@item 逆関数は @code{objtoquote}
@end itemize

@example
ctrl("print_quote",2);
A=quote((x-1)^2+(x-1)+3);
     出力: ((((x)-(1))^(2))+((x)-(1)))+(3)
eval_quote(A);
     出力: x^2-x+3
print_input_form(A);     /* asir-contrib */
     出力: quote((x-1)^2+(x-1)+3)
@end example

@table @t
@item 参照
@ref{objtoquote}, @ref{quotetolist}, @ref{eval_string},
@ref{quote_to_funargs}, @ref{funargs_to_quote}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item  -----まだ書いてない.
@end itemize


@node nqt_match,,, クオート
@subsection @code{nqt_match}
@findex nqt_match

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item nqt_match(@var{Expr},@var{Pattern}[,@var{Mode}])
:: @var{Expr} が @var{Pattern} にマッチ(適合)すると 1 を戻す. しないと 0 を戻す.
@end table

@table @var
@item return
整数
@item Expr
quote型
@item Pattern
quote型
@item Mode
整数
@end table

@itemize @bullet
@item  @var{Expr} が @var{Pattern} にマッチ(適合)すると 1 を戻す. しないと 0 を戻す.
@item 適合した場合, 副作用として, @var{Pattern} に含まれるプログラム変数(大文字ではじまる変数)に適合した値が代入される.
@item nqt は normalized quote の略であり fnode標準形に変換してから適合検査をする.  fnode標準形については @ref{qt_normalize} を見よ.
@item @var{Mode} により展開方法を指定し, その展開方法により得られた @var{Expr} の
fnode標準形と @var{Pattern} を比較する.
@end itemize

@example
ctrl("print_quote",2);
A=quote((x-y)*(x+y));
nqt_match(A,quote(P*Q));
[P,Q]
    出力:  [x-y, x+y]
nqt_match(A,quote(P*Q),1);
    マッチしない.
nqt_match(A,quote(P*Q),2);
    マッチしない.
qt_normalize(A,1);
    出力:  ((x)^(2))+((x)*(y))+((-1)*((y)^(2)))+((-1)*(y)*(x))
qt_normalize(A,2);
    出力:  ((x)*(x))+((x)*(y))+((-1)*(y)*(x))+((-1)*(y)*(y))
@end example

@table @t
@item 参照
@ref{nqt_match_rewrite},
@ref{qt_rewrite}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item  ----- まだ書いてない.
@end itemize


@node nqt_match_rewrite,,, クオート
@subsection @code{nqt_match_rewrite}
@findex nqt_match_rewrite

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item nqt_match_rewrite(@var{Expr},@var{Rule},@var{Mode})
:: @var{Expr} を @var{Rule} に従い書き換える.
@end table

@table @var
@item return
quote型
@item Expr
quote型
@item Rule
[@var{Pattern},@var{Action}] かまたは
[@var{Pattern},@var{Condition},@var{Action}].
これらの要素はすべて quote型.
@item Mode
整数
@end table

@itemize @bullet
@item @var{Expr} を @var{Rule} に従い書き換える. @var{Pattern} に適合しない場合は
@var{Exprt} 自体を戻す.
@item nqt は normalized quote の略であり fnode標準形に変換してから適合検査をする.  fnode標準形については @ref{qt_normalize} を見よ.
@end itemize

@comment %%Doc: cfep/tests/2006-03-12-qt.rr
@example
ctrl("print_quote",2);
nqt_match_rewrite(`x*y*z,[`X*Y,`X+Y],1);
   出力: (x)+((y)*(z))
A=`x*x;
nqt_match_rewrite(A,[`X*Y,`X+Y],1);
   出力: x^2   (マッチしていない)
nqt_match_rewrite(A,[`X*Y,`X+Y],2);
   出力: 2*x

適合についてのモードの違いを理解するために次の例および fnode標準形(qt_normalize) を参照.
quotetolist(qt_normalize(`x*x,0));
    出力:  [b_op,^,[internal,x],[internal,2]]
quotetolist(qt_normalize(`x*x,1));
    出力:  [b_op,^,[internal,x],[internal,2]]
quotetolist(qt_normalize(`x*x,2));
    出力:  [n_op,*,[internal,x],[internal,x]]
@end example

@table @t
@item 参照
@ref{nqt_match},
@ref{qt_rewrite},
@ref{qt_normalize}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item   -----まだ書いてない.
@end itemize



@node qt_normalize,,, クオート
@subsection @code{qt_normalize}
@findex qt_normalize

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item qt_normalize(@var{Expr}[,@var{Mode}])
:: @var{Expr} を fnode標準形に変換する. @var{Mode}により標準形への展開アルゴリズムを指定できる.
@end table

@table @var
@item return
quote型
@item Expr
quote型
@item Mode
整数
@end table

fnodeは quote型の実体である.
fnode は木であり, 型 id および子供からなる.
型および子供を取り出す関数が funargs_to_quote である.
また fnode をリストに変換する関数が quotetolist である.

fnode の標準形はパターンマッチング, 書き換えを容易におこなうために導入された.
fnode の標準形を fn と書くとき, 標準形の BNF風表現での定義は以下のとおり.
@example
 fn           = formula | functor(nf [,...]) | sum_of_monom
     fnode の標準形.  functor は関数よびだしみたいなもの.
 sum_of_monom = monom [+ ...]
     モノミアルの和
 monom        = [formula *] nfpow [* ...]
     モノミアル
 nfpow        = nf | nf^(nf)
     冪乗部分の標準形
 formula      = Risa object
@end example


@itemize @bullet
@item  @var{Expr} を fnode標準形に変換する. @var{Mode}により標準形への展開アルゴリズムを指定できる.
@item 展開は再帰的である.
@item 入力が fnode に変換された初期状態では + や * は子供が2人の binary operator
(b_op) であるが, qt_normalize を作用させることにより, + や * は任意人数の
子供を持てる n-ary operator に変換される.
@item n-ary operator を基礎とした fnode標準形を用いることにより, パターンマッチ用のパターンの数を減らせることが経験的にわかっている.
@item @var{Mode}=0. 展開しない. これが既定の動作.
@item @var{Mode}=1. 展開する. ただし x*x 等を x^2 等に変換
@item @var{Mode}=2. 展開する. ただし x*x 等を x^2 等に変換しない.
@end itemize

@var{Mode} の違いについては以下の例も参考に.
@comment %%cfep/tests/2006-03-12-qt.rr
@example
ctrl("print_quote",2);
A=quote((x-y)*(x+y));
   出力:  ((x)-(y))*((x)+(y))
B=qt_normalize(A,0);
   出力: ((x)+((-1)*(y)))*((x)+(y))  Mode=0. 展開はされない. +, * は n_op (nary-op) へ.
quotetolist(B);
   出力: [n_op,*,[n_op,+,[internal,x],[n_op,*,[internal,-1],[internal,y]]],[n_op,+,[internal,x],[internal,y]]]

B=qt_normalize(A,1);
   出力: ((x)^(2))+((x)*(y))+((-1)*((y)^(2)))+((-1)*(y)*(x))
           Mode=1. 展開する. +, * は n_op (nary-op) へ. 巾をまとめる.
quotetolist(B);
   出力: [n_op,+,[b_op,^,[internal,x],[internal,2]],[n_op,*,[internal,x],[internal,y]],[n_op,*,[internal,-1],[b_op,^,[internal,y],[internal,2]]],[n_op,*,[internal,-1],[internal,y],[internal,x]]]

qt_normalize(A,2);
   出力: ((x)*(x))+((x)*(y))+((-1)*(y)*(x))+((-1)*(y)*(y))
           Mode=2. 展開する. +, * は n_op (nary-op) へ. 巾は使わない.
quotetolist(B);
   出力: [n_op,+,[b_op,^,[internal,x],[internal,2]],[n_op,*,[internal,x],[internal,y]],[n_op,*,[internal,-1],[b_op,^,[internal,y],[internal,2]]],[n_op,*,[internal,-1],[internal,y],[internal,x]]]

qt_normalize(`x^2,2);
   出力: (x)*(x)
       Mode=2. 巾は使わない. n-ary の * へ.
@end example

@table @t
@item 参照
@ref{nqt_match},
@ref{nqt_match_rewrite},
@ref{quotetolist},
@ref{quote_to_funargs}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item -----まだ書いてない.
@end itemize


@node qt_set_coef,,, クオート
@subsection @code{qt_set_coef}
@findex qt_set_coef

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item qt_set_coef(@var{ParamList})
:: 以下 @var{ParamList} に現れる多項式変数を変数とする有理関数体を係数とする
非可換多項式を扱う.
@end table

@table @var
@item return
リスト
@item  ParamList
リスト
@end table

@itemize @bullet
@item 以下 @var{ParamList} に現れる多項式変数を変数とする有理関数体を係数とする
非可換多項式を扱う.
@item この宣言をしないと係数体を数とする非可換多項式として計算する.
@item qt_normalize およびその機能を用いる関数がこの機能の影響を受ける.
@item qt_comp 関数がこの機能の影響を受ける.
@end itemize

@example
ctrl("print_quote",2);
qt_set_coef([a]);
B=qt_normalize(quote((a*x+a)^2),2);
     出力: ((a^2)*(x)*(x))+((2*a^2)*(x))+(a^2)
qt_normalize(B+B,2);
     出力: ((2*a^2)*(x)*(x))+((4*a^2)*(x))+(2*a^2)
@end example

@table @t
@item 参照
@ref{qt_normalize}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item -----まだ書いてない.
@end itemize


@node qt_set_ord,,, クオート
@subsection @code{qt_set_ord}
@findex qt_set_ord

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item qt_set_ord(@var{VarList})
:: @var{VarList} を変数順序とする.
@end table

@table @var
@item return
リスト
@item VarList
リスト
@end table

@itemize @bullet
@item @var{VarList} を辞書式に用いた変数順序を以下使用する.
@item この宣言をしないとある不定元についての既定の辞書式順序-----まだ書いてない---を用いて項を比較する.
@var{VarList} に現れない変数についてはこの順序が適用される.
@item qt_normalize およびその機能を用いる関数がこの機能の影響を受ける.
@item qt_comp 関数がこの機能の影響を受ける.
@end itemize

@example
ctrl("print_quote",2);
qt_normalize(quote(x+y),2);
     出力: (x)+(y)
qt_set_ord([y,x]);
     出力: [y,x,z,u,v,w,p,q,r,s,t,a,b,c,d,e,f,g, 以下省略 ]
qt_normalize(quote(x+y),2);
     出力: (y)+(x)
@end example

@table @t
@item 参照
@ref{qt_normalize},
@ref{nqt_comp}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item -----まだ書いてない.
@end itemize


@node qt_set_weight,,, クオート
@subsection @code{qt_set_weight}
@findex qt_set_weight

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item qt_set_weight(@var{WeightVector})
:: 変数について weight ベクトルを設定する.
@end table

@table @var
@item return
リスト
@item WeightVector
リスト
@end table

fnode f の weight w(f) は次の式で計算する.
@example
 f が葉の場合は原則 0. qt_weight_vector で weight が与えられている不定元に
 ついてはその値.

 f がnodeの場合は次の規則で再帰的にきめる.
   w(f+g) = max(w(f),w(g))
   w(f g) = w(f) + w(g)
   w(f^n) = n w(f)
   関数については? -----まだ書いてない.
@end example

@itemize @bullet
@item @var{WeightVector} でまず順序の比較をして, それから qt_set_order による順序, 最後に既定の順序で比較する.
@var{WeightVector} に現れない変数についての weight は 0 となる.
@item qt_normalize およびその機能を用いる関数がこの機能の影響を受ける.
qt_normalize での展開では, この順序を用いて項がソートされる.
@item qt_comp およびその機能を用いる関数がこの機能の影響を受ける.
@item weight ベクトルによる順序比較についてはグレブナ基底の節@ref{dp_gr_main}も参照.
@end itemize

@example
ctrl("print_quote",2);
qt_set_weight([[x,-1],[y,-1]]);
     結果: [[x,-1],[y,-1]]
qt_normalize(quote( 1+(x+y)+(x+y)^2),1);
     結果: (1)+(y)+(x)+((y)^(2))+((y)*(x))+((x)^(2))+((x)*(y))
@end example

@table @t
@item 参照
@ref{qt_normalize},
@ref{qt_set_ord},
@ref{qt_set_weight},
@ref{dp_gr_main}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item -----まだ書いてない.
@end itemize


@node nqt_comp,,, クオート
@subsection @code{nqt_comp}
@findex nqt_comp

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item nqt_cmp(@var{Expr1},@var{Exprt2})
:: @var{Expr1} と @var{Expr2} の順序を比較する.
@end table

@table @var
@item return
整数
@item Expr1, Expr2
quote型
@end table

@itemize @bullet
@item @var{Expr1} と @var{Expr2} の順序を比較する.
@item @var{Expr1} > @var{Exprt2} なら 1.
@item @var{Expr1} < @var{Exprt2} なら -1.
@item @var{Expr1} = @var{Exprt2} (おなじ順序) なら 0.
@end itemize

@example
ctrl("print_quote",2);
qt_set_ord([y,x]); qt_set_weight([[x,-1],[y,-1]]);
[nqt_comp(`x,`y), nqt_comp(`y,`x), nqt_comp(`x,`x)];
     出力: [-1,1,0]
@end example

@table @t
@item 参照
@ref{qt_normalize},
@ref{qt_set_ord},
@ref{qt_set_weight}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item まだ書いてない.
@end itemize
@comment ****************************************************************

@node qt_is_var qt_is_coef,,, クオート
@subsection @code{qt_is_var}, @code{qt_is_coef}
@findex qt_is_var
@findex qt_is_coef

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item qt_is_var(@var{Expr})
:: @var{Expr} が不定元に対応する quote なら 1 を戻す.
@item qt_is_coef(@var{Expr})
:: @var{Expr} が係数の有理関数体に属するとき 1 を戻す.
@end table

@table @var
@item return
整数
@item Expr
quote型
@end table

@itemize @bullet
@item  @var{Expr} が不定元に対応する quote なら 1 を戻す.
そうでないとき 0 を戻す.
@end itemize

@example
[qt_is_var(quote(x)), qt_is_var(quote(3/2))];
     出力: [1,0]
@end example

@table @t
@item 参照
@ref{qt_rewrite},
@ref{nqt_match_rewrite}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item -----まだ書いてない.
@end itemize
@comment ****************************************************************

@node qt_rewrite,,, クオート
@subsection @code{qt_rewrite}
@findex qt_rewrite

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item qt_rewrite(@var{Expr},@var{Rules},@var{Mode})
:: @var{Expr} を規則集合 @var{Rules} を用いて書き換える.
@end table

@table @var
@item return
quote型
@item Expr
quote型
@item Rules
リスト
@item Mode
整数
@end table

@itemize @bullet
@item ユーザ言語を用いて定義された関数.
@code{import("noro_rewrite.rr")}  しておくこと.
(noro_rewrite.rr が OpenXM/lib/asir-contrib に存在しない場合
ソースの OpenXM/src/asir-contrib/testing/noro/new_rewrite.rr をコピー)
@item @var{Expr} を規則集合 @var{Rules} を用いて書き換える.
@item 規則の適用は fnode木に対して再帰的である.
 一方 @code{nqt_match_rewrite} ではトップレベルのみに規則が適用される.
@item 規則集合 @var{Rules} の各要素の書き方は @code{nqt_match()} の
@var{Pattern} と同じ書き方.
つまり [パターン, 書き換え結果] または
[パターン, 条件, 書き換え結果].
@item @var{Mode} の意味は @ref{qt_normalize} の @var{Mode} と同様.
パターンマッチ, 書き換えは @var{Mode} で @code{qt_normalize()}
されてから遂行される.
@end itemize

注意: 数学的には X*Y=Y*X が可換性を与える規則だが, これをそのまま規則として
           与えると書き換えが停止しない. 次の例では, 上の例のように順序比較し, たとえば,
           順序が大きくなる場合のみに書き換えるべきである.
@example
import("noro_rewrite.rr");
R=[[`X*Y,`nqt_comp(Y*X,X*Y)>0, `Y*X]];
qt_rewrite(`(x-y)^2,R,2);
     出力: quote(x*x+-2*x*y+y*y)
@end example

外積代数の計算 (asir-contrib をロードした状態).
@example
import("noro_rewrite.rr");
Rext0=[quote(X*Y),quote(qt_is_var(X) && qt_is_var(Y) && nqt_comp(Y,X)>0),
                  quote(-Y*X)];
Rext1=[quote(X^N),quote(eval_quote(N)>=2),quote(0)];
Rext2=[quote(X*X),quote(0)];
Rext=[Rext0,Rext1,Rext2];
qt_rewrite(quote( (x+2*y)*(x+4*y) ), Rext,1);
     出力: 2*x*y

qt_set_coef([a,b,c,d]);
qt_rewrite(quote((a*x+b*y)*(c*x+d*y)), Rext,1);
     出力: (d*a-c*b)*x*y

@end example

微分の計算 (asir-contrib をロードした状態).
@example
import("noro_rewrite.rr");
qt_set_coef([a,b]);
Rd1=[`d(X+Y), `d(X)+d(Y)];
Rd2=[`d(X*Y),`d(X)*Y+X*d(Y)];
Rd3=[`d(N), `qt_is_coef(N), `0];
Rd4=[`d(x),`1];
Rd=[Rd1,Rd2,Rd3,Rd4];
B=qt_rewrite( `d( (a*x+b)^3),Rd,2);
     出力: quote(3*a^3*x*x+6*b*a^2*x+3*b^2*a)
fctr(eval_quote(B));
     出力: [[3,1],[a,1],[a*x+b,2]]
@end example

@table @t
@item 参照
@ref{nqt_match},
@ref{nqt_match_rewrite},
@ref{qt_normalize}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item qt 系の関数の原型は OpenXM/src/asir-contrib/testing/tr.rr である.
このユーザ言語による開発が 2005年の春まで行われ, そのあと組み込み関数主体の
qt 系の関数が開発された.
@item qt 系の関数についてのその他の参考文献:
  OpenXM/doc/Papers/2005-rims-noro.tex および
  OpenXM/doc/Papers/2005-rims-noro.tm (TeXmacsの記事).
@item Todo: qt 系の関数を用いたおもしろい計算を Risa/Asir ジャーナルの記事として書く.
@end itemize

@comment ****************************************************************

@node 文字列処理,,, 実験的仕様の関数
@section 文字列処理

@comment --- ◯◯◯◯  関数 copyright の説明 ◯◯◯◯
@node copyright,,, 文字列処理
@subsection @code{copyright}
@findex copyright

@comment --- 関数の簡単な説明 ---
@table @t
@item copyright()
:: Risa/Asir の copyright 表示を文字列として戻す.
@end table

@table @var
@item return
文字列
@end table

@itemize @bullet
@item
Risa/Asir の copyright 表示を文字列として戻す.
@end itemize

@example
[1150] copyright();
This is Risa/Asir, Version 20040312 (Kobe Distribution).
Copyright (C) 1994-2000, all rights reserved, FUJITSU LABORATORIES LIMITED.
Copyright 2000-2003, Risa/Asir committers, http://www.openxm.org/.
GC 6.2(alpha6) copyright 1988-2003, H-J. Boehm, A. J. Demers, Xerox, SGI, HP.
PARI 2.0.17, copyright 1989-1999, C. Batut, K. Belabas, D. Bernardi,
   H. Cohen and M. Olivier.
@end example

@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数は texmacs 用に書かれた (2004-03).
@item OpenXM_contrib2/asir2000 の下の以下のファイルをみよ. builtin/miscf.c 1.21,
      parse/glob.c 1.47.
@end itemize



@comment --- ◯◯◯◯  関数 string_to_tb, ... の説明 ◯◯◯◯
@comment --- 複数の関数をまとめて説明する例 ---
@node string_to_tb tb_to_string write_to_tb,,, 文字列処理
@subsection @code{string_to_tb}, @code{tb_to_string}, @code{write_to_tb}
@findex string_to_tb
@findex tb_to_string
@findex write_to_tb

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item string_to_tb(@var{s})
@itemx tb_to_string(@var{tb})
@itemx write_to_tb(@var{s},@var{tb})
:: 文字列可変長配列型(text buffer)のデータの処理
@end table

@table @var
@item return
文字列可変長配列型(string_to_tb), 文字列型(tb_to_string)
@item s
文字列
@item tb
文字列可変長配列型
@end table

@itemize @bullet
@item
@code{string_to_tb(@var{s})} は, 文字列 @var{s} をはじめの要素とする
文字列可変長配列型オブジェクトを生成する.
@item
@code{tb_to_string_(@var{tb})} は,
文字列可変長配列型オブジェクト @var{tb} から通常の文字列オブジェクトを生成する.
@item
@code{write_to_tb(@var{s},@var{tb})} は, 文字列 @var{s} を
文字列可変長配列型オブジェクト @var{tb} へ書き出す.
@item @var{SS} を文字列変数とするとき,
@var{SS} += "文字列" で @var{SS} へ文字列を書き足していくことができるが,
無駄なメモリを大量に消費する.
代りに関数 @code{write_to_tb} を用いるべきである.
文字列可変長配列型オブジェクトは文字列の可変長の配列でありメモリ管理に優しい
データ構造である.
@end itemize

@example
[219] T=string_to_tb("");

[220] write_to_tb("Hello",T);
0
[221] write_to_tb(" world!",T);
0
[222] tb_to_string(T);
Hello world!
@end example


@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
 この関数は 2004-3 に print_tex_form を効率化するために書かれた.
@item
 OpenXM_contrib2/asir2000 の下の以下のファイルを見よ.
io/ox_asir.c 1.52, builtin/strobj.c 1.12--1.13, 1.16,
engine/str.c 1.5, parse/quote.c 1.9.
@item
 rtostr が text buffer 型のデータに関しておそかった. 速度の改善は
 asir2000/io/pexpr_body.c 1.2, asir2000/parse/lex.c 1.32.
@end itemize


@node set_print_function,,, 文字列処理
@subsection @code{set_print_function}
@findex set_print_function

@comment --- 関数の簡単な説明 ---
@table @t
@item set_print_function([@var{fname}])
:: 画面表示用の関数を登録
@end table

@table @var
@item return
整数
@item fname
文字列
@end table

@itemize @bullet
@item
@code{set_print_function} は @code{fname(F)} を通常の画面表示関数の代わりによぶ.
@code 引数がない場合は画面表示関数をデフォールトへ戻す.
@code Asir-contrib はこの関数を用いて出力関数を Asir-contrib 用に変更している.
@end itemize

@example
[219] def my_output(F) @{
           print("Out: ",0); print(rtostr(F));
      @}
[220] set_print_function("my_output");
Out: 0
[221]  1+2;
Out: 3
@end example

@table @t
@item 参照
@ref{rtostr}
@end table

@noindent
ChangeLog
@itemize @bullet
@item この関数は 2001-9-4 に asir-contrib のために導入された.
 変更をうけたソースコードは builtin/print.c 1.11 である.
@end itemize


@node printf fprintf sprintf,,, 文字列処理
@subsection @code{printf}, @code{fprintf}, @code{sprintf}
@findex printf
@findex fprintf
@findex sprintf

@table @t
@item printf(@var{format}[,@var{args}])
@item fprintf(@var{fd},@var{format}[,@var{args}])
@item sprintf(@var{format}[,@var{args}])
:: C に似たプリント関数
@end table

@table @var
@item return
整数(printf,fprintf), 文字列(sprintf)
@item format
文字列
@item fd
非負整数(ファイル記述子)
@item args
オブジェクト
@end table

@itemize @bullet
@item
@code{printf} は書式文字列 @var{format } にしたがい, オブジェクト @var{args} を標準出力に書き出す.
@item
@code{fprintf} は結果を, ファイル記述子 @var{fd} の指すファイルに書き出す.
@item
@code{sprintf} は結果を文字列で返し, 標準出力には書き出さない.
@item
書式文字列の中で @code{%a} (any) が利用可能.
@var{args} の個数は書式文字列の中の @code{%a} の個数に等しくすること.
@item
ファイル記述子は, @code{open_file} 関数を用いて得ること.
@end itemize

@example
[0] printf("%a: rat = %a\n",10,x^2-1)$
10: rat = x^2-1
[1] S=sprintf("%a: rat = %a",20,x^2-1)$
[2] S;
20: rat = x^2-1
[3] Fd=open_file("hoge.txt","w");
0
[4] fprintf(Fd,"Poly=%a\n",(x-1)^3)$
[5] close_file(Fd)$
[6] quit;

$ cat hoge.txt
Poly=x^3-3*x^2+3*x-1
@end example

@table @t
@item 参照
@ref{rtostr},@ref{open_file},@ref{close_file}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item
 関数 sprintfは 2004-7-13 にコミットされた.
 変更をうけたソースコードは builtin/strobj (1.50) である.
@item
 関数 printfは 2007-11-8 にコミットされた.
 変更をうけたソースコードは builtin/print.c (1.23) である.
@item
 関数 fprintfは 2008-11-18 にコミットされた.
 変更をうけたソースコードは builtin/file.c (1.25) である.
@item
 @code{%a} は Maple の sprintf の真似か.
@end itemize


@node グレブナー基底,,, 実験的仕様の関数
@section グレブナー基底

@comment --- ◯◯◯◯  関数 dp_gr_main の説明 ◯◯◯◯
@comment --- 複数の関数をまとめて説明する例 ---
@node dp_gr_main,,, グレブナー基底
@subsection @code{dp_gr_main}
@findex dp_gr_main

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item dp_gr_main(@var{f} | v=@var{vv}, order=@var{oo}, homo=@var{n}, matrix=@var{m}, block=@var{b}, sugarweight=@var{sw})
:: dp_gr_main の新しいインタフェース.
@end table

@table @var
@item return
リスト (グレブナ基底. 再帰表現多項式か分散表現多項式のリスト)
@item f
リスト  (入力多項式系. 再帰表現多項式か分散表現多項式のリスト)
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@item n
0 か1 (homogenization をするか)
@item m
順序を matrix で表現する場合 (cf. dp_ord).
@item b
???
@item sw
Sugar strategy を適用するときの weight vector. 全ての要素は非負.
@end table

@itemize @bullet
@item
 @code{dp_gr_main(@var{f})} は, @var{f} のグレブナ基底を計算する.
 グレブナ基底は順序を変えるとその形が変わる.   asir ではいままで順序の指定方法が
 系統だっていなかった.
 dp_gr_main の新しいインタフェースでは順序をある文法に従い指定する.
@comment  ~taka/this03/misc-2003/A2/dp
@item 順序 order は次の文法で定義する.  @{, @} は 0 回以上の繰り返しを意味する.
@example
  order         : '[' orderElement @{ ',' orderElement @} ']'
  orderElement   :  weightVec | builtinOrder
  weightVec     : '[' weightElement @{ ',' weightElement @} ']'
  builtiniOrder : '[' orderName  ',' setOfVariables ']'
  weightElement :   NUMBER | setOfVariables ',' NUMBER
  setOfVariables:  V | range(V,V)
  orderName    : @@grlex | @@glex | @@lex
@end example
ここで @code{V} は 変数名, @code{NUMBER} は整数をあわらす.
例1:  @code{v=[x,y,z,u,v], order=[[x,10,y,5,z,1],[@@grlex,range(x,v)]]}
は @code{x},@code{y},@code{z} がそれぞれ weight 10, 5, 1 をもつ
順序で比較したあと, @code{[x,y,z,u,v]} についての
graded reverse lexicographic order を tie-breaker として用いることを意味する.
参考書: B.Sturmfels: Gr\"obner Bases and Convex Polytopes (1995).
M.Saito, B.Sturmfels, N.Takayama:
Gr\"obner Deformations of Hypergeometric Differential Equations (2000).
@item
  順序要素 (orderElement) の指定方法は
 (1) 変数名または rangeで指定された変数の集合と重みの値の繰り返し
 (2) 重みの値を変数リストの順番に並べる方法
 (3) 変数名または rangeで指定された変数の集合と順序名の組
 の三通りの基礎的方法がある.
 似た指定方法が Macaulay, Singular, CoCoA, Kan/sm1 等の環論システムで
 使用されていた. Risa/Asir の指定方法はこれらのシステムの指定方法を参考に
 さらに改良を加えたもので柔軟性が高い.
@item
  order の tie-breaker は grlex がデフォールト.
@item
  分散表現多項式を引数としたときは結果も分散表現多項式として戻る.
  order 指定にもちいるデフォールトの変数名はこのとき x0, x1, x2, ... となる.
@item
  オプションの値は option_list キーワードを用いてリストで与えてもよい.
  下の例を参照.
@end itemize

@example
[218] load("cyclic");
[219] V=vars(cyclic(4));
[c0,c1,c2,c3]
[220]dp_gr_main(cyclic(4) | v=V, order=[[c0,10,c1,1],[c2,5],[@@grlex,range(c0,c3)]]);
[ 10 1 0 0 ]
[ 0 0 5 0 ]
[ R R R R ]
[(-c3^6+c3^2)*c2^2+c3^4-1,c3^2*c2^3+c3^3*c2^2-c2-c3,
 (c3^4-1)*c1+c3^5-c3,(c2-c3)*c1+c3^4*c2^2+c3*c2-2*c3^2,-c1^2-2*c3*c1-c3^2,
 c0+c1+c2+c3]

[1151]  F=map(dp_ptod,katsura(4), vars(katsura(4)));
[(1)*<<1,0,0,0,0>>+(2)*<<0,1,0,0,0>>+ ... ]
[1152] dp_gr_main(F | order=[[range(x0,x3),1]]);
[ 1 1 1 1 0 ]
[ R R R R R ]
[(47774098944)*<<0,0,0,0,13>>+ ... ]

[1153] Opt=[["v",[x,y]], ["order",[[x,5,y,1]]]];
[[v,[x,y]],[order,[[x,5,y,1]]]]
[1154]  dp_gr_main([x^2+y^2-1,x*y-1] | option_list=Opt);
[ 5 1 ]
[ R R ]
[-y^4+y^2-1,x+y^3-y]
@end example

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2003-12 から 2004-2 の始めに大きな修正が行われた.
@item
 @code{setOfVariables}の表現のために range オブジェクトが導入された.
@item
  グレブナ基底は順序を変えるとその形が変わる.   asir ではいままで順序の指定方法が
  系統だっていなかった.
  dp_gr_main の新しいインタフェースでは順序をある文法に従い指定する.
@item
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/gr.c 1.56--1.57,
builtin/dp-supp.c 1.27--1.31 (create_composite_order_spec),
builtin/dp.c 1.46--1.48 (parse_gr_option),
engine/Fgfs.c 1.20,
engine/dist.c 1.27--1.28
engine/nd.c 1.89,
include/ca.h 1.42--1.43,
io/pexpr.c 1.28,
io/sexpr.c 1.26,
parse/arith.c 1.11,
parse/glob.c 1.44-1.45,
parse/lex.c 1.29,
parse/parse.h 1.23--1.26
@item
 Todo: return キーワードで戻り値のデータを quote のリストにできるように.
  attribute, ring 構造体.
@end itemize

@comment --- ◯◯◯◯  関数 dp_gr_main の説明 ◯◯◯◯
@node dp_weyl_gr_main,,, グレブナー基底
@subsection @code{dp_weyl_gr_main}
@findex dp_weyl_gr_main

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item dp_weyl_gr_main(@var{f} | v=@var{vv}, order=@var{oo}, homo=@var{n}, matrix=@var{m}, block=@var{b}, sugarweight=@var{sw})
:: dp_weyl_gr_main の新しいインタフェース.  dp_gr_main と同じ形式である.
@end table

@table @var
@item return
リスト (グレブナ基底. 再帰表現多項式か分散表現多項式のリスト)
@item f
リスト  (入力多項式系. 再帰表現多項式か分散表現多項式のリスト)
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@item n
0 か1 (homogenization をするか). [テストまだ]
@item m
順序を matrix で表現する場合 (cf. dp_ord). [テストまだ]
@item b
???
@item sw
Sugar strategy を適用するときの weight vector. 全ての要素は非負. [テストまだ]
@end table

@itemize @bullet
@item
 @code{dp_weyl_gr_main(@var{f})} は, @var{f} のグレブナ基底を計算する.
 グレブナ基底は順序を変えるとその形が変わる.   asir ではいままで順序の指定方法が
 系統だっていなかった.
 dp_weyl_gr_main の新しいインタフェースでは順序をある文法に従い指定する.
 指定方法については dp_gr_main のマニュアルを参照.
@item
 分散表現多項式の各モノミアルの長さが偶数のときはワイル代数
 K[x_1, ..., x_n, d_1, ..., d_n]
で計算がおこなわれる. ワイル代数では x_i と d_i は非可換な掛け算規則
 d_i x_i = x_i d_i +1 をみたし, x_i と x_j や d_i と d_j は可換である.
 また i と j が異なる場合は x_i と d_j も可換である.
@item
 分散表現多項式の各モノミアルの長さが奇数のときは同次化ワイル代数
 K[x_1, ..., x_n, d_1, ..., d_n, h]
で計算がおこなわれる. 同次化ワイル代数では x_i と d_i は非可換な掛け算規則
 d_i x_i = x_i d_i + h^2
をみたし, h は任意の元と可換, その他の変数もワイル代数と同様な可換性の規則をみたす.
 詳しくは dp_gr_main で参照した Saito, Sturmfels, Takayama の教科書をみよ.
@end itemize

@example
[1220] F=sm1.gkz([ [[1,1,1,1],[0,1,3,4]], [0,0]]);  /* Command in asir-contrib*/
[[x4*dx4+x3*dx3+x2*dx2+x1*dx1,4*x4*dx4+3*x3*dx3+x2*dx2,-dx1*dx4+dx2*dx3,-dx2^2*dx4+dx1*dx3^2,dx1^2*dx3-dx2^3,-dx2*dx4^2+dx3^3],[x1,x2,x3,x4]]
[1221] V=[x1,x2,x3,x4,dx1,dx2,dx3,dx4]$
[1222] dp_weyl_gr_main(F[0] | v=V, order=[[dx1,1,dx2,1,dx3,1,dx4,1]]);
...
[1238] FF=map(dp_ptod,F[0],V);
[(1)*<<1,0,0,0,1,0,0,0>>+(1)*<<0,1,0,0,0,1,0,0>>+(1)*<<0,0,1,0,0,0,1,0>>+(1)*<<0,0,0,1,0,0,0,1>>,(1)*<<0,1,0,0,0,1,0,0>>+(3)*<<0,0,1,0,0,0,1,0>>+(4)*<<0,0,0,1,0,0,0,1>>,0,0,0,0]

[1244] FF=map(dp_ptod,F[0],V);
[(1)*<<1,0,0,0,1,0,0,0>>+(1)*<<0,1,0,0,0,1,0,0>>+(1)*<<0,0,1,0,0,0,1,0>>+(1)*<<0,0,0,1,0,0,0,1>>,(1)*<<0,1,0,0,0,1,0,0>>+(3)*<<0,0,1,0,0,0,1,0>>+(4)*<<0,0,0,1,0,0,0,1>>,(1)*<<0,0,0,0,0,1,1,0>>+(-1)*<<0,0,0,0,1,0,0,1>>,(1)*<<0,0,0,0,1,0,2,0>>+(-1)*<<0,0,0,0,0,2,0,1>>,(-1)*<<0,0,0,0,0,3,0,0>>+(1)*<<0,0,0,0,2,0,1,0>>,(1)*<<0,0,0,0,0,0,3,0>>+(-1)*<<0,0,0,0,0,1,0,2>>]

dp_weyl_gr_main(FF | v=V, order=[[0,0,0,0,1,1,1,1]]);

[1246] dp_weyl_gr_main(FF | v=V, order=[[dx1,1,dx2,1,dx3,1,dx4,1]]);
[ 0 0 0 0 1 1 1 1 ]
[ R R R R R R R R ]
 ...

@end example

@table @t
@item 参照
@ref{dp_gr_main}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item dp_gr_main のインタフェースが dp_weyl_gr_main へも導入された.
@item
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/dp-supp.c 1.32--1.33
builtin/dp.c 1.49--1.50
@end itemize

@comment --- ◯◯◯◯  関数 dp_initial_term の説明 ◯◯◯◯
@node dp_initial_term,,, グレブナー基底
@subsection @code{dp_initial_term}
@findex dp_initial_term

@comment --- 関数の簡単な説明 ---
@table @t
@item dp_initial_term(@var{f} | v=@var{vv}, order=@var{oo})
:: dp_initial_term は与えられた weight に対する先頭項の和を戻す.
@end table

@table @var
@item return
分散表現多項式または分散表現多項式のリスト.
@item f
分散表現多項式か分散表現多項式のリスト.
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@end table

@itemize @bullet
@item
 dp_initial_term は与えられた weight w に対する先頭項の和を戻す.
 これは多くの教科書で @tex ${\rm in}_w(f)$ @end tex
 と書かれている.
@item
 順序を表すリストは dp_gr_main で定義した文法に従う.
 このリストの先頭が weight vector で無い場合はエラーとなる.
 たとえば order=[[@@lex,...]] はエラーとなる.
@item
 結果は与えられた順序に関してソートされてるわけではない.
@end itemize

@example
[1220] F=<<2,0,0>>+<<1,1,0>>+<<0,0,1>>;
(1)*<<2,0,0>>+(1)*<<1,1,0>>+(1)*<<0,0,1>>
[1220] dp_initial_term(F | order=[[1,1,1]]);
[ 1 1 1 ]
[ R R R ]
(1)*<<2,0,0>>+(1)*<<1,1,0>>
[1221] dp_initial_term(F | v=[x,y,z], order=[[x,1]]);
[ 1 0 0 ]
[ R R R ]
(1)*<<2,0,0>>
@end example

@table @t
@item 参照
@ref{dp_gr_main}, @ref{dp_weyl_gr_main}, @ref{dp_order}, @ref{dp_hm}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/dp-supp.c 1.32
builtin/dp.c 1.49
@end itemize

@comment --- ◯◯◯◯  関数 dp_order の説明 ◯◯◯◯
@node dp_order,,, グレブナー基底
@subsection @code{dp_order}
@findex dp_order

@comment --- 関数の簡単な説明 ---
@table @t
@item dp_order(@var{f} | v=@var{vv}, order=@var{oo})
:: dp_order は与えられた weight に対する次数の最大値を戻す.
@end table

@table @var
@item return
数か数のリスト
@item f
分散表現多項式か分散表現多項式のリスト.
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@end table

@itemize @bullet
@item
 順序を表すリストは dp_gr_main で定義した文法に従う.
 このリストの先頭が weight vector で無い場合はエラーとなる.
 たとえば order=[[@@lex,...]] はエラーとなる.
@item
 dp_order は与えられた weight w に対する次数の最大値を戻す.
 これを @tex ${\rm ord}_w(f)$ @end tex
 と書く論文や教科書もある.
@item
 引数がリストの場合各要素の次数が計算される.
@end itemize

@example
[1220] F=<<2,0,0>>+<<1,1,0>>+<<0,0,1>>;
(1)*<<2,0,0>>+(1)*<<1,1,0>>+(1)*<<0,0,1>>
[1222] dp_order(F | order=[[1,1,1]]);
[ 1 1 1 ]
[ R R R ]
2
[1223] dp_order(F | v=[x,y,z], order=[[x,1]]);
[ 1 0 0 ]
[ R R R ]
@end example

@table @t
@item 参照
@ref{dp_gr_main}, @ref{dp_weyl_gr_main}, @ref{dp_initial_term}, @ref{dp_hm}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/dp-supp.c 1.32
builtin/dp.c 1.49
@end itemize

@node nd_sba nd_sba_f4,,, グレブナー基底
@subsection @code{nd_sba}, @code{nd_sba_f4}
@findex nd_sba
@findex nd_sba_f4

@comment --- SBA アルゴリズムの実験的実装 ---
@table @t
@item  nd_sba(@var{gen},@var{vars},@var{char},@var{ord})
@itemx  nd_sba_f4(@var{gen},@var{vars},@var{char},@var{ord})
:: signature based algorithm によるグレブナー基底の計算
@end table

@table @var
@item gen
多項式リスト
@item ord
項順序型
@item var
変数リスト
@item return
多項式リスト
@end table

@itemize @bullet
@item
signature based algorithm (SBA) によるグレブナー基底計算の実験的実装である.
@item
signature based algorithm とは, イデアルの各元に, その元をもとの生成系から生成する
係数ベクトル (加群の元) の先頭項 (signature) を付随させ, 単項式除算を, signature が
真に小さいものによる除算に限定して Buchberger algorithm 類似の手続きを実行する.
@item
Buchberger algorithm における useless pair elimination criteria の代わりに,
syzygy を用いた criterion や, 同一 signature の S-ペアを 1 つに絞るなどの
S-ペア消去手法により, Buchberger algorithm より効率よくグレブナー基底を計算できる場合がある.
@item
@code{nd_sba} は signature 付き Buchberger algorithm を実行する.
引数, オプション, @code{dp_gr_flags()} で設定されるスイッチは @code{nd_gr} と同一である.
@item
@code{nd_sba_f4} は @code{nd_sba} において, 複数のS-ペアをまとめて簡約できるような
reducer を symbolic preprocessing で集め, 行列上で簡約操作を行う実装である.
しかし, 通常の F4 と異なり, SBA の実行は S-ペアを選ぶ順序に鋭敏であり, 
どのような基準で複数のS-ペアを選ぶかについて実験中である.
@end itemize

@example
[0] load("katsura")$
[4] F=katsura(10)$
[5] V=[u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10]$
[6] cputime(1)$
1.7e-05sec(1.502e-05sec)
[7] G=nd_gr(F,V,31991,0)$
83.04sec(83.2sec)
[8] Gs=nd_sba(F,V,31991,0)$
12.9sec(12.92sec)
[9] G4=nd_f4(F,V,31991,0)$ 
12.56sec(12.58sec)
[10] G4s=nd_sba_f4(F,V,31991,0)$
5.534sec(5.538sec)
@end example

@table @t
@item 参照
Risa/Asir ユーザーズマニュアルの「グレブナ基底の計算」
@end table


@node nd_gr nd_gr_trace nd_weyl_gr nd_weyl_gr_trace (module),,, グレブナー基底
@subsection @code{nd_gr}, @code{nd_gr_trace} (加群)
@findex nd_gr (module)
@findex nd_gr_trace (module)
@findex nd_weyl_gr (module)
@findex nd_weyl_gr_trace (module)

@comment --- nd_gr, nd_gr_trace における加群のグレブナー基底計算 ---
@table @t
@item  nd_gr(@var{gen},@var{vars},@var{char},@var{ord})
@itemx  nd_gr_trace(@var{gen},@var{vars},@var{homo},@var{char},@var{ord})
@item  nd_weyl_gr(@var{gen},@var{vars},@var{char},@var{ord})
@itemx  nd_weyl_gr_trace(@var{gen},@var{vars},@var{homo},@var{char},@var{ord})
:: 部分加群のグレブナー基底の計算
@end table

@table @var
@item gen
リストのリスト
@item ord
@var{[IsPOT,Ord]} なるリスト
@item return
リストのリスト
@end table

@itemize @bullet
@item 多項式環あるいはワイル代数上の自由加群の部分加群のグレブナー基底
を計算する. 結果はリストのリストである. 各要素リストは, 自由加群の
元であるベクトルとみなす.
@item @var{ord} として @var{[IsPOT,Ord]} という2要素リストが指定された
場合, 加群のグレブナー基底計算を実行する. この場合, @var{gen} は, 多項式
のリストのリストとして与える必要がある.
@item @var{IsPOT} が 1 の場合, POT (position over term), 0 の
場合 TOP (term over position) で比較する. 基礎環での項比較は @var{Ord}
で行う.
@item 説明されていない引数は, イデアルの場合の解説を参照のこと.
@end itemize

@example
[0] Gen=[[x,y,z],[y^2+x,x^2,z],[y^2,z^3+x,x+z]];
[[x,y,z],[x+y^2,x^2,z],[y^2,x+z^3,x+z]]
[1]  nd_gr(Gen,[x,y,z],0,[0,0]);
[[x,y,z],[y^2,x^2-y,0],[y^2,x+z^3,x+z],[y^3+z^3*y^2,y^3*x-y^3,
-x^3-z*x^2+(z*y^2+y)*x-z*y^2+z*y],[0,0,x^4+z*x^3+(-z*y^2-y)*x^2
+(-y^3+z*y^2-z*y)*x+z^4*y^2]]
@end example

@table @t
@item 参照
@ref{nd_gr}, @ref{nd_gr_trace}
@end table

@node nd_gr nd_gr_trace nd_weyl_gr nd_weyl_gr_trace (option),,, グレブナー基底
@subsection @code{nd_gr}, @code{nd_gr_trace} (option)
@findex nd_gr (option)
@findex nd_gr_trace (option)
@findex nd_weyl_gr (option)
@findex nd_weyl_gr_trace (option)

@comment --- nd_gr, nd_gr_trace のオプション ---

@table @t
@item  nd_gr(@var{...}[|@var{opt},@var{opt},@dots{}])
@itemx  nd_gr_trace(@var{...}[|@var{opt},@var{opt},@dots{}])
@itemx  nd_weyl_gr(@var{...}[|@var{opt},@var{opt},@dots{}])
@itemx  nd_weyl_gr_trace(@var{...}[|@var{opt},@var{opt},@dots{}])
:: グレブナー基底計算に関する種々のオプションの説明
@end table

@table @var
@item opt
@var{key=value} なるオプション設定
@item return
オプションにより異なる
@end table

@itemize @bullet
@item グレブナー基底計算をオプションにより制御する.
@item 現状では次の 3 つのオプションを受け付ける.

@table @var
@item gentrace
@var{value} が 0 でないとき, グレブナー基底の計算経過情報を出力する.
@item gensyz
@var{value} が 0 でないとき, 計算されたグレブナー基底に対する syzygy の生成系を出力する.
@item nora
@var{value} が 0 でないとき, 最終ステップで相互簡約を行わない.
@end table

@item @var{gentrace} が指定された場合, 出力は,
@var{[GB,Homo,Trace,IntRed,Ind,InputRed,SpairTrace]} なるリストである. 各要素の意味は
次の通りである.
@table @var
@item GB
グレブナー基底
@item Homo
中間基底が斉次化されている場合 1, そうでない場合 0.
@item Trace
全中間基底に対する計算経過情報
@item IntRed
相互簡約に対する計算経過情報
@item Ind
簡約グレブナー基底の各要素の, 全中間基底のにおけるインデックス
@item InputRed
各入力多項式をグレブナー基底で簡約して剰余 0 を得るまでの計算経過情報
(@var{gensyz} が指定された場合)
@item SpairTrace
簡約グレブナー基底に対する S 多項式を簡約して剰余 0 を得るまでの計算経過情報
(syzygy 加群の生成系の要素のみ; @var{gensyz} が指定された場合)
@end table
@item 詳細は, 入力多項式集合とグレブナー基底の相互変換行列, および syzygy 計算
関数の項で説明する予定.
@end itemize

@example
[0] C=[c3*c2*c1*c0-1,((c2+c3)*c1+c3*c2)*c0+c3*c2*c1,...]
[1] D=nd_gr_trace(C,[c0,c1,c2,c3,c4],0,1,0|gentrace=1,gensyz=1)$
[2] D[0];
[c0+c1+c2+c3,-c1^2-2*c3*c1-c3^2,...]
[3] D[2];
[[[0,0,1],[1,1,1],[2,2,1],[3,3,1]],[4,[[1,2,(1)*<<0,0,0,0>>,1],...]
[4] D[6];
[[-1,[[1,0,(1)*<<0,0,2,4>>,1],[1,6,(-1)*<<1,0,0,0>>,1],...]
@end example

@table @t
@item 参照
@ref{nd_gr}, @ref{nd_gr_trace}
@end table


@node システム,,, 実験的仕様の関数
@section システム

@comment --- ◯◯◯◯  関数 syz_pqr, xyz_stu の説明 ◯◯◯◯
@comment --- 複数の関数をまとめて説明する例 ---
@node asir-port.sh asir-install.sh,,, システム
@subsection @code{asir-port.sh}, @code{asir-install.sh}
@findex asir-port.sh
@findex asir-install.sh

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item asir-install.sh
@itemx asir-port.sh
:: これは asir の内部コマンドではない. asir をネットワークからダウンロードかつ実行するシェルスクリプト
@end table


@itemize @bullet
@item
asir-port.sh は knoppix 専用である.
このコマンドは asir のバイナリおよび FLL で配布できない部分を
 ftp.math.kobe-u.ac.jp よりダウンロードして
/home/knoppix/.asir-tmp へセーブして, 実行する.
.asirrc および .TeXmacs/plugins/ox/progs/init-ox.scm もダウンロードする.
@item
asir-install.sh は Debian GNU Linux / openxm-binary*.deb 専用である.
asir-install.sh は asir をダウンロードして /usr/local/OpenXM/bin および
/usr/local/OpenXM/lib/asir へインストールする.
@end itemize


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
 これらのシェルスクリプトは knoppix/math のために 2004/2, 3 月に書かれた.
@item
  knoppix/math は福岡大学の濱田さんが中心となり開発されている.
@item
  OpenXM/misc/packages/Linux/Debian の下の全てのファイル (2004-2-22 から
  2004-3 の末まで). ( ~taka/this03/misc-2003/A3/knoppix-03-05 (プライベートファイル) も見よ.)
  OpenXM/src/asir-port の下の次の各ファイル.
  Makefile 1.1--1.8, asir-install.sh 1.1--1.2, asir-port.sh 1.1--1.6.
@end itemize


@node asirgui.hnd,,, システム
@subsection @code{asirgui.hnd}
@findex asirgui.hnd

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item asirguid.hnd
:: asirgui の main window のハンドル番号を保持するファイル
@end table

@comment ****************************************************************

@itemize @bullet
@item asirgui (Windows 版) を起動すると 環境変数 TEMP で指定されたフォルダにこのファイルが作成される.
@item 中身は１０進整数で, asirgui の main window のハンドルである. このハンドルあてに PostMessage をすれば, asuirgui にキーボードから入力したのと同様な効果が得られる.
@item text editor で作成, 保存したファイルを text editor 側から asirgui に読み込ませたりするために利用可能.
@item http://www.math.kobe-u.ac.jp/Asir/Add-ons にて winfep.exe を配布している. winfep ではあらかじめファイルに入力スクリプトを書いておいて, asirgui で一行づつ実行させることができる. winfep はプレゼンテーション用のソフトウエアである. これは asirgui.hnd を利用している. 
@end itemize

@example
// cl test.c user32.lib

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <process.h>

int main()
@{

	HWND hnd;
	FILE *fp = fopen("c:/Program Files/asir/bin/asirgui.hnd","r");
	fscanf(fp,"%d",&hnd);
	fclose(fp);
	while (1) @{
		int c;
		c = getchar();
		if ( c == '#' ) break;
		PostMessage(hnd,WM_CHAR,c,1);
	@}
	return 0;
@}
@end example

@table @t
@item 参照
@ref{xyz_abc}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この機能は 2006-12-5, 2007-02-13 に加えられた.
@item @code{OpenXM_contrib2/windows/asir32gui/asir32gui.clw} 1.11
@item @code{OpenXM_contrib2/windows/asir32gui/asir32guiview.cpp}  1.15, 1.1.6
@item winfep は 2010-01-20 頃に第一版が commit された.
@item @code{OpenXM_contrib2/windows/winfep}  1.1
@end itemize


@comment ****************************************************************

@node chdir pwd,,, システム
@subsection @code{chdir}, @code{pwd}
@findex chdir
@findex pwd

@comment --- ディレクトリ操作 ---
@table @t
@item chdir(@var{directory})
@item  pwd()
:: シェルコマンド cd と pwd に対応する操作.
@end table

@table @var
@item return
文字列(@code{pwd}), 整数(@code{chdir})
@item dirctory
文字列
@end table

@itemize @bullet
@item
@code{pwd} はカレントディレクトリを文字列で返す.
@item
@code{chdir} はカレントディレクトリを @var{directory} に変更する.  成功すれば 0 を失敗すれば -1 を返す.
@end itemize

@example
[0] S=pwd();
/home/ohara
[1] chdir(".../taka");
-1
[2] chdir("/usr/bin");
0
@end example

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item
これらの関数は 2008-8-27 にコミットされた.
変更をうけたソースコードは builtin/miscf.c (1.27) である.
@end itemize


@node dcurrenttime,,, システム
@subsection @code{dcurrenttime}
@findex dcurrenttime

@comment --- 現在時刻を取得 ---
@table @t
@item  dcurrenttime()
:: 現在時刻を取得.
@end table

@table @var
@item return
浮動小数点数
@end table

@itemize @bullet
@item
返り値は1970年1月1日0時0分0秒からの経過秒数である.
@end itemize

@example
[0] ctrl("real_digit", 16);
16
[1] dcurrenttime();
1226390851.34476
[2] currenttime();
1226390854
@end example

@table @t
@item 参照
@ref{currenttime}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item
この関数は 2008-9-12 にコミットされた.
変更をうけたソースコードは builtin/time.c (1.6) である.
@end itemize


@node getpid,,, システム
@subsection @code{getpid}
@findex getpid

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item getpid()
@end table

@table @var
@item return
整数
@end table

@itemize @bullet
@item asir のプロセス番号を戻す.
@item プロセス番号は asir, ox_asir 等で独立したプロセスに対してシステム内で一意である.
@end itemize

@example
[219] getpid();
3214
@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は ox_work_dir() 関数が一意な作業ファイル名を得るために使われている.
src/asir-contrib/packages/src/misc/rr 1.3,
asir2000/builtin/file.c 1.28, rat.c 1.5,
asir2000/parse/puref.c 1.9 を参照 (2013/02/15, 18).
@end itemize


@node loadpath,,, システム
@subsection @code{loadpath}
@findex loadpath

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item ctrl(``loadpath''[,list])
@end table

@table @var
@item list
文字列(パス)のリスト
@item return
文字列(パス)のリスト, または数(listが与えられたとき)
@end table

@itemize @bullet
@item asir の組み込み関数 ctrl のスイッチのひとつである.
@item asir のロードパスの出力または設定を行う.
@end itemize

@example
[0] L=ctrl("loadpath");
[/home/you/OpenXM/lib/asir-contrib,/home/you/OpenXM/lib/asir,.]
[1] ctrl("loadpath", cons(getenv("HOME")+"/lib",L));
0
@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2014-5-12 にコミットされた.
変更をうけたソースコードは builtin/ctrl.c (1.41) である.
@end itemize


@node sysinfo,,, システム
@subsection @code{sysinfo}
@findex sysinfo

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item sysinfo()
@end table

@table @var
@item return
文字列のリスト
@end table

@itemize @bullet
@item asir の動作しているオペレーティングシステムの情報を返す.
@item リストの各成分は, OSタイプ, カーネル名, OS名, CPUタイプ, OSバージョン, 完全な情報, ロケールである.
@item OSタイプは unix, macosx, windows のいずれかである.
@item unix および macosx においては, システムコールおよび uname コマンドにより情報を取得している.
windows では, GetVersionEx() などの Win32 API が用いられている.
@end itemize

@example
[0] sysinfo();
[windows,WindowsNT,Windows7,x86_64,6.1.7601,WindowsNT 6.1.7601 Windows7 Service Pack 1 x86_64,ja]
@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2014-5-14 にコミットされた.
変更をうけたソースコードは builtin/ctrl.c (1.42) である.
@end itemize


@comment ****************************************************************


@node 言語,,, 実験的仕様の関数
@section 言語

@node get_struct_name get_element_names get_element_at put_element_at,,, 言語
@subsection @code{get_struct_name}, @code{get_element_names}, @code{get_element_at}, @code{put_element_at}
@findex get_struct_name
@findex get_element_names
@findex get_element_at
@findex put_element_at

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item get_struct_name(@var{s})
@itemx get_element_names(@var{s})
@itemx get_element_at(@var{s},@var{key})
@itemx put_element_at(@var{s},@var{key},@var{obj})
:: 構造体 @var{s} に対する操作
@end table

@table @var
@item return
文字列 (get_struct_name),
文字列のリスト (get_element_names),
オブジェクト (get_element_at),
オブジェクト (put_element_at)
@item s
構造体
@item key
文字列
@item obj
オブジェクト
@end table

@itemize @bullet
@item
 @code{get_struct_name(s)} は, 構造体 @var{s} の名前を戻す.
@item
 @code{get_element_names(s)} は, 構造体のメンバーの名前のリストを戻す.
@item
 @code{get_element_at(s,key)} は構造体 s のメンバー key の値を戻す.
@item
 @code{put_element_at(s,key,obj)} は構造体 s のメンバー key の値を obj に設定する.
@end itemize

@example
[219]  struct point @{ x, y, color@};
[220]  P = newstruct(point);
@{0,0,0@}
[221]  P->x = 10$ P->y=5$ P->color="red"$
[222]  get_element_names(P);
[x,y,color]
[223] put_element_at(P,"color","blue");
blue
[224] P->color;
bule
@end example

@table @t
@item 参照
@ref{newstruct}, @ref{struct}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item  構造体の定義を知らずに構造体を扱うユーザ関数を書くときに便利.
       asir-contrib の noro_print.rr を見よ.
@item  OpenXM_contrib2/asir2000/builtin/compobj.c 1.8.
@end itemize


@comment  mapat
@node mapat,,, 言語
@subsection @code{mapat}
@findex mapat

@table @t
@item mapat(@var{fname},@var{pos}[,@var{arg0}, @var{arg1}, ...])
:: @var{pos} に対する map 関数
@end table

@table @var
@item return
オブジェクト
@item pos
整数
@item arg0, arg1, arg2, ...
オブジェクト
@end table

@itemize @bullet
@item
@code{map} 関数は 0 番目の引数に対してしか動作しないが, @code{mapat}
関数は指定した番号の引数に対して @code{map} 関数を実行する.
@item
@code{mapat(fname,0,A0,A1,...)} は
@code{map(fname,A0,A1,...)} に等価である.
@item
次の副作用がある. まだ書いてない.
@end itemize

@example
[219] mapat(deg,1,x^2+y^3+x+y,[x,y]);
[2,3]
[220] mapat(subst,1,x+y+z,[x,y,z],2);
[y+z+2,x+z+2,x+y+2]
@end example

@table @t
@item 参照
@ref{map}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-6-22 にコミットされた.
 変更をうけたソースコードは builtin/pf.c, subst.c である.
@end itemize

@comment  list
@node list,,, 言語
@subsection @code{list}
@findex list

@table @t
@item list([@var{arg0}, @var{arg1}, ...])
:: list を生成する.
@end table

@table @var
@item return
リスト
@item arg0, arg1, arg2, ...
オブジェクト
@end table

@itemize @bullet
@item
@var{arg0}, @var{arg1}, ... を要素とするリストを生成する.
@end itemize

@example
[219] list(1,2,3);
[1,2,3]
[220] list(1,2,[3,4]);
[1,2,[3,4]]
@end example

@table @t
@item 参照
@ref{cons}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-6-22 にコミットされた.
 変更をうけたソースコードは builtin/list.c である.
@end itemize


@node assoc,,, 言語
@subsection @code{assoc}
@findex assoc

@comment --- 関数の簡単な説明 ---
@table @t
@item assoc(@var{a},@var{b})
:: 連想リストをつくる
@end table

@table @var
@item return
List
@item a
List
@item b
List
@end table

@itemize @bullet
@item リスト @var{a}, @var{b} より
[[@var{a}[0],@var{b}[0]], [@var{a}[1],@var{b}[1]], ...]
なる新しいリストを生成する.
@end itemize

下の例では @code{A} に動物の名前が,
@code{B} に足の本数が入っている.
@code{assoc(A,B)} で動物と足の本数をペアにしたリストを生成する.

@example
[1192]  A=["dog","cat","snake"];
[dog,cat,snake]
[1193] B=[4,4,0];
[4,4,0]
[1194] assoc(A,B);
[[dog,4],[cat,4],[snake,0]]
@end example

@table @t
@item 参照
@ref{cons}, @ref{append}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item
 この関数は 2004-6-28 に書かれた.
 変更をうけたソースコードは
 builtin/list.c 1.9
 parse/eval.c 1.35,
 parse/parse.h 1.31,
 parse/quote.c 1.14--1.16.
@end itemize


@node set_secure_flag set_secure_mode,,, 言語
@subsection @code{set_secure_flag}, @code{set_secure_mode}
@findex set_secure_flag
@findex set_secure_mode

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item set_secure_flag(@var{fname},@var{m})
@itemx set_secure_mode(@var{m})
:: 関数の実行権限を設定する.  (web サービス用)
@end table

@table @var
@item return
整数
@item fname
文字列
@item m
整数
@end table

@itemize @bullet
@item @code{set_secure_flag}, @code{set_secure_mode} は
asir を web サーバ等で公開するために加えられた関数.
@code{set_secure_flag} で公開する関数を指定する.
@code{secure_mode} が 1 の場合は @code{set_secure_flag} で指定された
関数しか実行できない.
関数の実行途中では @code{secure_mode} が 0 となっているので,
任意の関数を実行できる.
またエラーの時等は, @code{secure_mode} は 1 に自動的に復帰する.
ただし @code{def} は実行できない.
公開する関数では, その処理中は任意の関数が実行できるので,
security に十分注意した実装をする必要がある.
@item
@code{set_secure_flag} は, @var{fname} の secure flag を @var{m}
にする.
公開する命令は 1 に設定する.
@item
@var{set_secure_mode(1)} で @code{secure_mode} が 1 となり,
公開された関数しか実行できなくなる.
quit 等も実行できないので注意.
@item  @code{ timer } の引数として secure_flag を設定していない関数を
指定して実行してもエラーが表示されない.
このときは, @code{ ctrl("error_in_timer",1) } を実行しておく.
@end itemize

@example
[1194] set_secure_flag("print_input_form_",1);
1
[1195] set_secure_flag("fctr",1);
1
[220] set_secure_mode(1);
1
[1197] fctr((x-1)^3);
[[1,1],[x-1,3]]
[1198] fctr(shell("ls"));
evalf : shell not permitted
return to toplevel
@end example

@table @t
@item 参照
@ref{timer}
@end table

@noindent
ChangeLog
@itemize @bullet
@item @code{set_secure_flag}, @code{set_secure_mode} は asir を
web サーバ等で公開するために加えられた関数.
sm1 の同様な関数 RestrictedMode で採用された方法を用いている.
つまり, @code{set_secure_flag} で公開する関数を指定する.
@code{secure_mode} が 1 の場合は @code{set_secure_flag} で指定された
関数しか実行できない.
v関数の実行途中では @code{secure_mode} が 0 となっているので,
任意の関数を実行できる.
@item この関数は 2004-10-27 から 2004-11-22 にかけて開発された.
@item cgiasir.sm1, cgi-asir.sh と組み合わせて cgi サービスを提供するために
利用する.
cgi-asir.sh では
@code{CGI_ASIR_ALLOW} 環境変数で公開するコマンドを指定する.
@item
  1.24--1.25      OpenXM_contrib2/asir2000/builtin/miscf.c
@item
  1.36--1.38      OpenXM_contrib2/asir2000/parse/eval.c
@item
  1.6--1.7       OpenXM_contrib2/asir2000/parse/function.c
@item
  1.33      OpenXM_contrib2/asir2000/parse/parse.h
@end itemize

@node initialize_static_variable,,, 言語
@subsection @code{initialize_static_variable}
@findex initialize_static_variable


@comment --- 説明 ---
@table @t
@item static 変数の初期化の問題点. 初期化の時に segmentation fault がおきる.
@end table


@itemize @bullet
@item static 変数の取扱.
下の例を参照のこと.
@end itemize


@example
if (1) @{
 module abc;
 static A;
 A=1;
 endmodule;
@} else @{ @};

end$
を t.rr とするとき,

[6] load("./t.rr");
1
internal error (SEGV)
となる.

t.rr を
if (1) @{
 module abc;
 static A;
 localf initA;
 localf foo;
 def initA() @{
   A=1;
 @}
 initA();
 def foo() @{
   return A;
 @}
 endmodule;
@} else @{ @};

end$
とすると正しく初期化される.
@end example

@comment --- ChangeLog
@noindent
ChangeLog
@itemize @bullet
@item  oxasir-win.rr の取扱で問題点として浮上.  2005.07.25.
@item  oxasir-win.rr の取扱で double quote の取り扱いに問題があったが, これは asir2000/io/ox_asir.c, 1.58, で問題点解決.
@item ox_asir に計算を依頼する時は if (1) @{ ... @}で囲む.
@end itemize

@comment ****************************************************************

@node function,,, 言語
@subsection @code{function}
@findex function

@table @t
@item function 宣言することにより函数形式の不定元を生成できる.
@end table

@comment --- 説明 ---
@table @t
@item function 宣言することにより函数形式の不定元を生成できる.
@item 微分函数 diff はこの函数形式の不定元の微分をやはり函数形式の不定元として生成する.
たとえば f@{1,2@}(x,y) は f を x について一階偏微分, y について 2階偏微分したもの.
@item diff は合成関数としての処理も行う.
@end table


@example
[1915] function f(x,y);
[1916] F=f(f(x,y),y)$
[1917] diff(F,y);
f@{1,0@}(f(x,y),y)*f@{0,1@}(x,y)+f@{0,1@}(f(x,y),y)
[1918] vtype(f(p,q));
2
[1919] deg(diff(F,y),f@{0,1@}(x,y));
1
@end example

@xref{vtype}
@xref{diff}

@comment --- ChangeLog
@noindent
ChangeLog
@itemize @bullet
@item  いつの commit で導入されたか不明.
@end itemize

@comment ****************************************************************

@node 数論・代数,,, 実験的仕様の関数
@section 数論・代数


@node small_jacobi,,, 数論・代数
@subsection @code{small_jacobi}
@findex small_jacobi

@comment --- 関数の簡単な説明 ---
@table @t
@item small_jacobi(@var{a},@var{m})
:: Jacobi 記号の計算
@end table

@table @var
@item return
整数
@item arg1, arg2
整数
@end table

@itemize @bullet
@item
 @var{m} が素数のときは Legendre 記号とよばれ,
 x^2 = @var{a} mod @var{m} に解があるとき 1, 解がないとき -1 をもどす.
@item
Jacobi 記号は Legendre 記号の積で定義される (初等整数論の本参照).
@item
 この関数は machine int の範囲で jacobi 記号を計算する.
@end itemize

@example
[1286] small_jacobi(2,3);
-1
[1287] small_jacobi(2,7);
1
@end example

@table @t
@item 参照
http://members.jcom.home.ne.jp/yokolabo/asirlib/
も見てね.
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数の由来は不明.
@end itemize


@node noro_matrix.rr,,, 数論・代数
@subsection @code{noro_matrix.rr}
@findex noro_matrix.rr

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item linalg.unit_mat(@var{arg1})
@item linalg.random_rmat(@var{arg1}, @var{arg2}, @var{arg3})
@item linalg.minipoly_mat(@var{arg1})
@item linalg.compute_kernel(@var{arg1})
@item linalg.compute_image(@var{arg1})
@item linalg.jordan_canonical_form(@var{arg1})
@end table


@itemize @bullet
@item 簡単な解説および実例は http://www.math.kobe-u.ac.jp/HOME/taka/2007/knx/noro_matrix-ja.txt を参照.
@end itemize

@example
load("noro_matrix.rr");
A=newmat(4,4,[[2,0,0,0],[3,5,1,0],[-9,-9,-1,0],[-5,0,0,1]]);
B=linalg.jordan_canonical_form(A);
@end example

@table @t
@item 参照
@ref{invmat}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-04 頃から線形代数III の講義をしながら書かれた.
@item ソース:  OpenXM/src/asir-contrib/packages/src/noro_matrix.rr
@end itemize


@node f_res,,, 数論・代数
@subsection @code{f_res}
@findex f_res

@comment --- 関数の簡単な説明 ---
@table @t
@item f_res
@end table


@itemize @bullet
@item f_res は各種の終結式を計算するモジュールである. ox_grep("f_res"); で online manual を閲覧可能である.
@end itemize

@table @t
@item 参照
@ref{}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item このモジュールは Fujiwara 君の修士論文が元になり, それを改造したものである.
@item OpenXM/src/ox_cdd, OpenXM/src/asir-contrib/packages/src/f_res.rr
@end itemize


@node D 加群の制限に関する関数,,, 実験的仕様の関数
@section D 加群の制限に関する関数


@node nk_restriction.restriction,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.restriction}
@comment --- 索引用キーワード
@findex nk_restriction.restriction

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.restriction(@var{Id}, @var{VL}, @var{DVL}, @var{W})
:: D 加群 M = D / @var{Id} (ホロノミック D イデアル @var{Id}) に対して, 
重みベクトル @var{W} についての制限加群を返す.
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item Id
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@itemize @bullet
@item
@var{W} の要素は非負整数で, 0 番目の要素から連続して正の整数が入らなければならない.
(すなわち, @code{[1,1,0,0,0]} は OK だが、 @code{[1,0,1,0,0]} はダメ)
@item
正の重みを持つ変数についての制限を行う. 
例えば, @var{VL} @code{=[x,y,z]}, @var{W} @code{=[1,1,0]} であれば, 
x,y について制限を行う. 
@end itemize

以下は, イデアル 
@iftex
@tex 
$I = D \cdot \{x \partial_x -1, y \partial_y - 1\} $ 
@end tex
とおいた時, D 加群 
@tex $M = D / I$ @end tex
の 
@tex $x$ @end tex
@end iftex
@ifinfo
I = D . @{ x dx -1, y dy - 1 @} とおいた時, 
D 加群 M = D / I の x
@end ifinfo
についての制限加群を計算した例である.
@example
[1432] nk_restriction.restriction([x*dx-1,y*dy-1],[x,y],[dx,dy],[1,0]);
-- generic_bfct_and_gr :0.001sec(0.001629sec)
generic bfct : [[1,1],[s-1,1]]
S0 : 1
B_@{S0@} length : 2
-- fctr(BF) + base :0.000999sec(0.0005109sec)
[[y*dy-1,(y*dy-1)*dx,-1],[[1],[0]]]
@end example
返り値の第 1 番目の要素 @code{[[1],[0]]]} は, 
制限加群の基底 
@iftex
@tex $\partial_x^1, \partial_x^0$ @end tex 
を意味し, 
返り値の第 0 番目の要素から, 制限加群は 
@tex $(y \partial_y - 1, 0), (0, y\partial_y-1), (-1,0)$ @end tex 
@end iftex
@ifinfo
dx^1, dx^0 
を意味し, 
返り値の第 0 番目の要素から, 制限加群は 
(y dy - 1, 0), (0, ydy-1), (-1,0) 
@end ifinfo
で生成されることがわかる. 

@node nk_restriction.restriction_ideal,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.restriction_ideal}
@comment --- 索引用キーワード
@findex nk_restriction.restriction_ideal

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.restriction_ideal(@var{Id}, @var{VL}, @var{DVL}, @var{W})
:: ホロノミック D イデアル @var{Id} を重みベクトル @var{W} についての制限イデアルを返す. 
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item Id
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@itemize @bullet
@item
@var{W} の要素は非負整数で, 0 番目の要素から連続して正の整数が入らなければならない. 
(すなわち, @code{[1,1,0,0,0]} は OK だが, @code{[1,0,1,0,0]} はダメ)
@item
正の重みを持つ変数についての制限を行う. 
例えば, @var{VL} @code{=[x,y,z]}, @var{W} @code{=[1,1,0]} であれば, 
x,y について制限を行う. 
@end itemize

以下は, イデアル
@iftex
@tex $I = D \cdot \{x \partial_x -1, y \partial_y - 1\} $ @end tex
の
@tex $x$ @end tex
@end iftex
@ifinfo
I = D . @{ x dx -1, y dy - 1 @} の x
@end ifinfo
についての制限イデアルを計算した例である。
@example
[1346] nk_restriction.restriction_ideal([x*dx-1,y*dy-1],[x,y],[dx,dy],[1,0]);
-- generic_bfct_and_gr :0.002sec(0.001652sec)
generic bfct : [[1,1],[s-1,1]]
S0 : 1
B_@{S0@} length : 2
-- fctr(BF) + base :0sec(0.000566sec)
-- restriction_ideal_internal :0.001sec(0.0007441sec)
[-1]
@end example

@node nk_restriction.integration,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.integration}
@comment --- 索引用キーワード
@findex nk_restriction.integration

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.integration(@var{Id}, @var{VL}, @var{DVL}, @var{W})
:: D 加群 M = D / @var{Id} (ホロノミック D イデアル @var{Id}) に対して, 重みベクトル @var{W} についての積分加群を返す. 
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item Id
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item
@var{W} の要素は非負整数で, 0 番目の要素から連続して正の整数が入らなければならない. 
(すなわち, @code{[1,1,0,0,0]} は OK だが, @code{[1,0,1,0,0]} はダメ)
@item
正の重みを持つ変数についての積分を行う. 
例えば, @var{VL} @code{=[x,y,z]}, @var{W} @code{=[1,1,0]} であれば, 
x,y について積分を行う. 
@end itemize

以下は, イデアル
@iftex
@tex $I = D \cdot \{2 t \partial_x + \partial_t, t \partial_t + 2 x \partial_x + 2\}$ @end tex
とおいた時, D 加群 
@tex $M = D / I$ @end tex 
の 
@tex $t$ @end tex
@end iftex
@ifinfo
I = D . @{2 t dx + dt, t dt + 2 x dx + 2 @} 
とおいた時, D 加群 M = D / I の t
@end ifinfo
についての積分加群を計算した例である. ([SST, Ex5.5.2, Ex5.5.6])
@example
[1351] nk_restriction.integration([2*t*dx+dt,2*x*dx+t*dt+2],[t,x],
[dt,dx],[1,0]);
-- generic_bfct_and_gr :0.001sec(0.001796sec)
generic bfct : [[1,1],[s,1],[s-1,1]]
S0 : 1
B_@{S0@} length : 2
-- fctr(BF) + base :0.001sec(0.0006731sec)
[[4*x*dx^2+6*dx,-4*t*x*dx^2-6*t*dx,2*x*dx+1,-2*t*x*dx,2*t*dx],[[1],[0]]]
@end example
返り値の第 1 番目の要素 @code{[[1],[0]]]} は, 
積分加群の基底 
@iftex
@tex $t^1, t^0$ @end tex 
@end iftex
@ifinfo
t^1, t^0
@end ifinfo
を意味し, 
返り値の第 0 番目の要素から, 積分加群は 
@iftex
@tex $(4 x \partial_x^2 + 6 \partial_x, 0), (0, -4 x \partial_x^2 - 6 \partial_x), 
(0, -2 x \partial_x), (0, 2 \partial_x)$ @end tex 
@end iftex
@ifinfo
(4 x dx^2 + 6 dx, 0), (0, -4 x dx^2 - 6 dx), 
(0, -2 x dx), (0, 2 dx)
@end ifinfo
で生成されることがわかる. 

@node nk_restriction.integration_ideal,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.integration_ideal}
@comment --- 索引用キーワード
@findex nk_restriction.integration_ideal

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.integration_ideal(@var{Id}, @var{VL}, @var{DVL}, @var{W})
:: ホロノミック D イデアル @var{Id} を重みベクトル @var{W} についての積分イデアルを返す. 
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item Id
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item
@var{W} の要素は非負整数で, 0 番目の要素から連続して正の整数が入らなければならない. 
(すなわち, @code{[1,1,0,0,0]} は OK だが, @code{[1,0,1,0,0]} はダメ)
@item
正の重みを持つ変数についての積分を行う. 
例えば, @var{VL} @code{=[x,y,z]}, @var{W} @code{=[1,1,0]} であれば, 
x,y について積分を行う. 
@end itemize

以下は, イデアル
@iftex
@tex
$I = D \cdot \{2 t \partial_x + \partial_t, t \partial_t + 2 x \partial_x + 2\} $
@end tex
の
@tex $t$ @end tex
@end iftex
@ifinfo
I = D . @{2 t dx + dt, t dt + 2 x dx + 2 @} の t
@end ifinfo
についての積分イデアルを計算した例である. ([SST, Ex5.5.2, Ex5.5.6])
@example
[1431]  nk_restriction.integration_ideal([2*t*dx+dt,t*dt+2*x*dx+2],[t,x],
[dt,dx],[1,0]);
-- generic_bfct_and_gr :0.002999sec(0.002623sec)
generic bfct : [[1,1],[s,1],[s-1,1]]
S0 : 1
B_@{S0@} length : 2
-- fctr(BF) + base :0.001sec(0.001091sec)
-- integration_ideal_internal :0.002sec(0.001879sec)
[2*x*dx+1]
@end example

@node nk_restriction.ann_mul,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.ann_mul}
@comment --- 索引用キーワード
@findex nk_restriction.ann_mul

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.ann_mul(@var{I}, @var{J}, @var{VL}, @var{DVL})
:: @var{f} を零化するホロノミック D イデアル @var{I},
@var{g} を零化するホロノミック D イデアルを @var{J} としたとき,
@var{fg} を零化するホロノミック D イデアルを返す.
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item I
イデアルの生成元のリスト
@item J
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item test_ann_mul(), test_ann_mul2(), test_ann_mul3() を参照.
@end itemize


@node nk_restriction (option) ,,, D 加群の制限, 積分に関する関数の説明 (option)
@subsection @code{nk_restriction (option)}
@comment --- 索引用キーワード
@findex nk_restriction (option)

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.restriction(... | inhomo=@var{n}, param=@var{p}, s0=@var{m})
@item nk_restriction.restriction_ideal(... | inhomo=@var{n}, param=@var{p}, s0=@var{m}, ht=@var{b}, ord=@var{ord})
@item nk_restriction.integration(... | inhomo=@var{n}, param=@var{p}, s0=@var{m})
@item nk_restriction.integration_ideal(... | inhomo=@var{n}, param=@var{p}, s0=@var{m}, ht=@var{b}, ord=@var{ord})
:: D 加群の制限, 積分に関する関数のオプションの説明
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item @var{n}
0 または 1
@item @var{p}
リスト (係数体に属する変数のリスト)
@item @var{m}
整数
@item @var{b}
0, 1, 2, 3 のいずれか
@item @var{ord}
重み0の変数に対する項順序
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item @var{n} が 0 でないとき, 非斉次部分の計算を行う.

restriction_ideal (integration_ideal) に関しては, イデアル @code{I} の
@code{M} 変数についての制限(積分)イデアル @code{J} と

@iftex
@tex
{\tt J[K]-(1/IH[K][1])(IH[K][0][0][0]IH[K][0][0][1]+...+IH[K][0][M][0]IH[K][0][M][1])} $\in$ {\tt I}
@end tex
@end iftex
@ifinfo
J[K]-(1/IH[K][1])(IH[K][0][0][0]IH[K][0][0][1]+...+IH[K][0][M][0]IH[K][0][M][1]) \in I
@end ifinfo

を満たす非斉次部分を構成する情報 @code{IH} とのペア @code{[J,IH]} を出力する.
詳しい出力の見方については, 下の例やソースの @code{inhomo_part} の
コメントを参照.

restriction, integration に対する @code{inhomo} オプションは
restriction_ideal, integration_ideal のサブルーチンとしての実行用なので,
ユーザが明示的に使用することはない.

@item @var{param} に指定された変数は係数体に属するものとみなされて計算が行われる.
また, ``generic'' であることが仮定される.
つまり, これらの変数に依存するような generic b-関数の根は,
最大整数根でないということである.

@item @var{param} が指定されると, generic b-関数の計算は noro による
高速アルゴリズムではなく, 消去法が用いられる.
@var{param} に空リストを指定することで, b-関数の計算方法のフラグとしても
利用できる.

@item @var{m} が負でないとき, 計算を行わずに s-m を generic b-関数として
制限, 積分等の計算を行う. 

@item @var{b} により, 加群のグレブナ基底計算に斉次化, trace アルゴリズム
を用いるかどうか指定できる.
ただし, 斉次化ありで計算できるのは Risa/Asir バージョン 20100415 以降である.

0: 斉次化なし, trace なし

1: 斉次化なし, trace あり

2: 斉次化あり, trace なし (デフォルト) 

3: 斉次化あり, trace あり

@item @var{ord} が指定されると, 出力の積分, 制限イデアルは, その項順序に
関するグレブナ基底となる. 加群のグレブナ基底計算の POT 順序の tie breaker
として使用されるので計算効率に大きな影響を与える可能性がある.
デフォルトは 0, つまり全次数逆次書式順序である.

このオプションは @var{param} と同時利用できない. (後に対応予定.)
@end itemize

以下は,
@iftex
@tex
$ t^{b-1} (1-t)^{c-b-1} (1-xt)^{-a} $
@end tex
の annihilator
@tex
$I = D \cdot \{ x(1-x) \partial_x^2+((1-t) \partial_t-(a+b+1)x+c-1)
 \partial_x-ab, (1-t)x \partial_x+t(1-t) \partial_t+(2-c)t+b-1,
 (xt-1) \partial_x+at \}$
@end tex
の
@tex
$t$
@end tex
についての積分イデアル
@tex
$J$
@end tex
を計算し, Gauss の超幾何微分方程式を導出した例である. ([SST, Chap 1.3])
@end iftex
@ifinfo
t^@{b-1@} (1-t)^@{c-b-1@} (1-xt)^@{-a@}
の annihilator
I = D . @{ x(1-x)dx^2+((1-t)dt-(a+b+1)x+c-1)dx-ab,
 (1-t)x dx+t(1-t)dt+(2-c)t+b-1, (xt-1)dx+at @}
の t についての積分イデアル J
を計算し, Gauss の超幾何微分方程式を導出した例である. ([SST, Chap 1.3])
@end ifinfo
@example
[1555] A=ndbf.ann_n([t,1-t,1-x*t])$
[1556] I=map(subst,A,s0,b-1,s1,c-b-1,s2,-a);
[(x^2-x)*dx^2+((t-1)*dt+(a+b+1)*x-c+1)*dx+b*a,(-t+1)*x*dx+(t^2-t)*dt+(-c+2)*t+b-1,(t*x-1)*dx+a*t]
[1557] J=nk_restriction.integration_ideal(I,[t,x],[dt,dx],[1,0]|inhomo=1, param=[a,b,c]);
-- nd_weyl_gr :0sec(0.001875sec)
-- weyl_minipoly_by_elim :0.008001sec(0.006133sec)
-- generic_bfct_and_gr :0.008001sec(0.006181sec)
generic bfct : [[-1,1],[s,1],[s-a+c-1,1]]
S0 : 0
B_@{S0@} length : 1
-- fctr(BF) + base :0sec(0.003848sec)
-- integration_ideal_internal :0sec(0.07707sec)
[[(x^2-x)*dx^2+((a+b+1)*x-c)*dx+b*a],[[[[dt,(-t+1)*dx]],1]]]
@end example
@iftex
この出力は
@tex
$\{(x^2-x) \partial_x^2+((a+b+1)x-c) \partial_x+ab \}
- 1/1 \{ \partial_t (-t+1) \partial_x \} \in I$
@end tex
であることを意味する.
@end iftex
@ifinfo
この出力は
@{(x^2-x)dx^2+((a+b+1)x-c)dx+ab @} - 1/1 @{ dt (-t+1)dx @} \in I
であることを意味する.
@end ifinfo

@node nk_restriction.trans_inhomo,,, D 加群の積分イデアルの非斉次部分に関する関数
@subsection @code{nk_restriction.trans_inhomo}
@comment --- 索引用キーワード
@findex nk_restriction.trans_inhomo

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.trans_inhomo(@var{P}, @var{INT}, @var{VL}, @var{DVL}, @var{W})
:: D 加群の制限イデアル, 積分イデアルの生成元に対する非斉次部分の情報から, 任意の元に対する非斉次部分を計算する関数
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item P
積分イデアルの元, または制限イデアルの元
@item INT
nk_restriction.integration_ideal( ... |inhomo=1); または

nk_restriction.restriction_ideal( ... |inhomo=1); の出力
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item @var{VL}, @var{DVL}, @var{W} は @var{INT} の計算に用いたものをそのまま使用しなければならない.
@item もし, @var{P} が @var{INT[0]} で生成される積分, 制限イデアルの元でない場合はエラーメッセージが表示される.
@end itemize

@node nk_restriction.ost_integration_ideal,,, D 加群の積分イデアル
@subsection @code{nk_restriction.ost_integration_ideal}
@comment --- 索引用キーワード
@findex nk_restriction.ost_integration_ideal

@comment --- 関数の簡単な説明 ---
積分領域が区間の直積であるような積分の満たす
ホロノミック斉次微分方程式系を返す (Oaku-Shiraki-Takayama, 2003).
@table @t
@item nk_restriction.ost_integration_ideal(@var{Id}, @var{VL}, @var{DVL}, @var{W}, @var{LB}, @var{UB})
:: Heaviside 関数との積の満たす微分方程式系の計算にショートカット法を用いる.
@item nk_restriction.ost_integration_ideal2(@var{Id}, @var{VL}, @var{DVL}, @var{W}, @var{LB}, @var{UB})
:: Heaviside 関数との積の満たす微分方程式系の計算に制限イデアルを用いる.
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item Id
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@item LB
積分区間の下端を表すリスト
@item UB
積分区間の上端を表すリスト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item 下端, 上端に無限大を指定するときは, 文字列  "inf", "+inf", "-inf" を用いる.
@end itemize

以下は, Oaku-Shiraki-Takayama (2003) の例5.1を計算したものである.
@iftex
@tex
$ \int_0^\infty \exp((-t^3+t)x) dt $
@end tex
の被積分関数の満たすホロノミックイデアルは
@tex
$ I = \langle \partial_t +(3t^2-1)x, \partial_x+t^3-t \rangle $
@end tex
であるから, これを入力として次のように計算を行う.
@end iftex
@ifinfo
\int_0^∞ exp((-t^3+t)x) dt
の非積分関数の満たすホロノミックイデアルは
I = < dt +(3t^2-1)x, dx+t^3-t >
であるから, これを入力として次のように計算を行う.
@end ifinfo
@example
[1871] Id=[dt+(3*t^2-1)*x, dx+t^3-t]$
[1872] VL=[t,x]$
[1873] DVL=[dt,dx]$
[1874] W=[1,0]$
[1875] nk_restriction.ost_integration_ideal(Id,VL,DVL,W,[0],["inf"]);
-- nd_weyl_gr :0.008sec(0.006768sec)
-- weyl_minipoly :0.004001sec(0.003029sec)
-- generic_bfct_and_gr :0.012sec(0.0129sec)
generic bfct : [[1,1],[s,1],[s-2,1]]
S0 : 2
B_@{S0@} length : 3
-- fctr(BF) + base :0.008sec(0.007395sec)
-- integration_ideal_internal :0.012sec + gc : 0.016sec(0.04311sec)
[-27*x^3*dx^3-54*x^2*dx^2+(4*x^3+3*x)*dx+4*x^2-3,27*x^2*dx^4+135*x*dx^3+(-4*x^2+105)*dx^2-16*x*dx-8]


[1876] nk_restriction.ost_integration_ideal2(Id,VL,DVL,W,[0],["inf"]);
(略)
[27*x^3*dx^3+54*x^2*dx^2+(-4*x^3-3*x)*dx-4*x^2+3,-27*x^2*dx^4-135*x*dx^3+(4*x^2-105)*dx^2+16*x*dx+8]
@end example
この出力は, 積分を零化するホロノミック系である.

@node nk_restriction.ost_sum,,, D 加群の積分イデアル
@subsection @code{nk_restriction.ost_sum}
@comment --- 索引用キーワード
@findex nk_restriction.ost_sum

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.ost_sum(@var{Id}, @var{VL}, @var{DVL}, @var{W})
:: 和の満たす(斉次/非斉次)差分方程式系を返す.
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item Id
イデアルの生成元のリスト
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する差分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item Oaku-Shiraki-Takayama (2003) の第6節のアルゴリズムの実装.
@item オプション inhomo が 0 でないとき, 非斉次部分を与える情報も返す.
@end itemize

以下は, Oaku-Shiraki-Takayama (2003) の例6.5の非斉次部分まで計算したものである.
@iftex
@tex
$ \sum_{k=a}^b {n \choose k} $
@end tex
の非和関数の満たすホロノミックイデアルは
@tex
$ I = \langle (n-k+1)E_n-(n+1), (k+1)E_k-(n-k) \rangle $
@end tex
であるから, これを入力として次のように計算を行う.
@end iftex
@ifinfo
\sum_@{k=a@}^b n_C_k
の非和関数の満たすホロノミックイデアルは
I = < (n-k+1)E_n-(n+1), (k+1)E_k-(n-k) >
であるから, これを入力として次のように計算を行う.
@end ifinfo
@example
[1871] Id=[(n-k+1)*en-(n+1), (k+1)*ek-(n-k)]$  
[1872] VL=[k,n]$
[1873] DVL=[ek,en]$
[1874] W=[1,0]$
[1875] nk_restriction.ost_sum(Id,VL,DVL,W|inhomo=1);
-- nd_weyl_gr :0.006667sec(0.004057sec)
-- weyl_minipoly :0sec(0.001163sec)
-- generic_bfct_and_gr :0.01sec(0.007085sec)
generic bfct : [[1,1],[s,1]]
S0 : 0
B_@{S0@} length : 1
-- fctr(BF) + base :0.003333sec(0.001785sec)
-- restriction_ideal_internal :0sec(0.002336sec)
[[(en-2)*n+en-2],[[[[ek-1,[(-en+1)*n-en+1,1]]],1]]]
@end example

@node nk_restriction.module_restriction,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.module_restriction}
@comment --- 索引用キーワード
@findex nk_restriction.module_restriction

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.module_restriction(@var{M}, @var{VL}, @var{DVL}, @var{W})
:: D 加群 D^r/@var{M} (@var{M} は D^r の部分加群) の重みベクトル @var{W} についての制限加群を返す. 
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item M
D 自由加群 D^r の部分加群
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@itemize @bullet
@item
@var{W} の要素は非負整数で, 0 番目の要素から連続して正の整数が入らなければならない.
@comment{(すなわち、@code{[1,1,0,0,0]} は OK だが、 @code{[1,0,1,0,0]} はダメ)}
現在のところ, 1 変数についてだけ制限をとるようにしか実装していないため, 
@var{W} は 0 番目の要素だけ正の整数が入る. 
@item
正の重みを持つ変数についての制限を行う. 
例えば, @var{VL} @code{=[x,y,z]}, @var{W} @code{=[1,0,0]} であれば
x について制限を行う. 
@end itemize

以下は, D 自由加群 
@iftex
@tex $D^2$ @end tex
の部分加群 
@tex 
$M = D \cdot \{(\partial_x, \partial_y), (\partial_y, \partial_x), (x,y) \}$ 
@end tex
をとり, D 加群 
@tex $D^2 / M$ @end tex
の 
@tex $x$ @end tex
@end iftex
@ifinfo
D^2 の部分加群 M = D . @{ (dx, dy), (dy, dx), (x, y) @} 
をとり, D 加群 D^2 / M の x
@end ifinfo
ついての制限加群を計算した例である. 
@example
[2691] nk_restriction.module_restriction([[dx,dy],[dy,dx],[x,y]], [x,y], [dx,dy], [1,0]);
....
bfunction : 
s
[[1,1],[s,1]]
integer roots :
[0,0]
Generators: 
[e1,e2]
Relations: 
[-8*e2*dy,4*e2*dy^2,-4*e2*dy^3,4*e1*y*dy-4*e1,-4*e1*dy^2,-4*e2,-e2*y*dy^2+2*e2*dy,-e1*y*dy+e1,e1*y*dy-e1]
[[0,-1],[-dy^2,0],[y*dy-1,0]]
@end example
制限加群は 
@iftex
@tex $(0, -1), (-\partial_y^2, 0), (y \partial_y -1 , 0)$ @end tex 
@end iftex
@ifinfo
(0, -1), (-dy^2, 0), (y, dy-1, 0)
@end ifinfo
で生成されることがわかる. 

@node nk_restriction.module_integration,,, D 加群の制限に関する関数
@subsection @code{nk_restriction.module_integration}
@comment --- 索引用キーワード
@findex nk_restriction.module_integration

@comment --- 関数の簡単な説明 ---
@table @t
@item nk_restriction.module_integration(@var{M}, @var{VL}, @var{DVL}, @var{W})
:: D 加群 D^r/M (@var{M} は D^r の部分加群) の重みベクトル @var{W} についての積分加群を返す. 
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item M
D 自由加群 D^r の部分加群 
@item VL
変数のリスト
@item DVL
変数のリスト(@var{VL} に対応する微分作用素の方の変数)
@item W
重みベクトルを表すリスト
@end table

@itemize @bullet
@item
@var{W} の要素は非負整数で, 0 番目の要素から連続して正の整数が入らなければならない.
@comment{(すなわち、@code{[1,1,0,0,0]} は OK だが、 @code{[1,0,1,0,0]} はダメ)}
現在のところ, 1 変数についてだけ積分をとるようにしか実装していないため, 
@var{W} は 0 番目の要素だけ正の整数が入る. 
@item
正の重みを持つ変数についての積分を行う. 
例えば, @var{VL} @code{=[x,y,z]}, @var{W} @code{=[1,0,0]} であれば
x について積分を行う. 
@end itemize

以下は, D 自由加群 
@iftex
@tex $D^2$ @end tex
の部分加群 
@tex $M = D \cdot \{(x, y), (y, x), (\partial_x, \partial_y) \}$ @end tex
をとり, D 加群 
@tex $D^2/M$ @end tex 
の
@tex $x$ @end tex
@end iftex
@ifinfo
D^2 の部分加群 M = D . @{ (x, y), (y, x), (dx, dy) @} をとり, 
D 加群 D^2 / M の x 
@end ifinfo
についての積分加群を計算した例である. 
@example
[2702] nk_restriction.module_integration([[x,y],[y,x],[dx,dy]], [x,y], [dx,dy], [1,0]);
...
bfunction : 
s
[[1,1],[s,1]]
integer roots :
[0,0]
Generators: 
[e1,e2]
Relations: 
[-8*e2*y,-4*e2*y^2,-4*e2*y^3,-4*e1*y*dy-8*e1,-4*e1*y^2,-4*e2,-e2*y^2*dy-4*e2*y,e1*y*dy+2*e1,e1*y*dy+2*e1]
[[0,-1],[y*dy+2,0],[-y^2,0]]
@end example
積分加群は 
@iftex
@tex $(0, -1), (y \partial_y + 2, 0), (-y^2, 0)$ @end tex 
@end iftex
@ifinfo
(0, -1), (y dy + 2, 0), (-y^2, 0)
@end ifinfo
で生成されることがわかる. 

@noindent
ChangeLog
@itemize @bullet
@item  これらの関数は OpenXM/src/asir-contrib/packages/src/nk_restriction.rr で定義されている. nk_restriction.rr, 1.1--1.6 を見よ.
@item 2010-02-05 に 3 つの option (@code{inhomo}, @code{param}, @code{s0}) が追加された. 1.7--1.9 を見よ.
@item 2010-05 から 2010-07 にかけて 2 つの option (@code{ht}, @code{ord}) と
新たな関数 trans_inhomo() が追加された. 1.10--1.13 を見よ.
@item 2011-08 に ost_sum() が追加された. 1.20 を見よ.
@item 2016-05 に module_integration(), module_restriction() が追加された. 
@end itemize

@node その他(未分類),,, 実験的仕様の関数
@section その他(未分類)

@node tk_pfn.rkn,,, 実験的仕様の関数
@subsection @code{tk_pfn.rkn}
@findex tk_pfn.rkn

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item tk_pfn.rkn(@var{F},@var{X},@var{Y},@var{Xs},@var{Ys},@var{Ht},@var{H})
:: Pfaffian 方程式に対する Runge-Kutta 法
@end table

@table @var
@item return
リスト  独立変数と解の組
@item F, X, Y, Xs, Ys, Ht, H
@var{F} は Pfaffian 方程式の係数行列リスト. 
@var{X} は独立変数リスト.
@var{Y} は従属変数リスト. 
@var{Xs} 独立変数の出発値リスト.
@var{Ys} は出発時の従属変数の値リスト.
@var{Xt} は停止する独立変数の値リスト.
@var{H} は微少数.
@end table

@itemize @bullet
@item この関数は連立Pfaffian方程式 dY/d X[i] = F[i] Y を数値的に解く. 
@item 任意の holonomic system は Pfaffian 方程式に変換できる ([SST, Chap 1]).　変換には yang.rr パッケージを用いる.
@item d F[i]/d X[j] + F[i] F[j] = d F[j]/d X[i] + F[j] F[i] = 0 が任意の i, j に対して成立していることが解が存在する必要十分条件である. この条件が成立しないときにこの関数を用いて解を計算してもその解は偽物である.
@item X[i] が動く範囲は実数でないといけない.
@item Xs[i] <= X[i] <= Xt[i] または Xt[i] <= X[i] <= Xs[i] である.
@item 引数の与え方の例はソースコード (@code{OpenXM/lib/asir-contrib/tk_pfn.rr} )の @code{tk_pfn.test1}, @code{tk_pfn.test2} を参照.
@item 下の例の出力は X=(1,3) での値が Y=(-8,2,-6) であることを意味する.
@item 参考. taka_runge_kutta.rr, yang.rr
@end itemize

@example
[1355] import("tk_pfn.rr");
[1590]  tk_pfn.test1();
Value at (3,0.1)[8.99,6,-0.2]
Value at (1,3)[-8,2,-6]
[[[1,3],-8,2,-6],
 [[1,2.9],-7.41,2,-5.8],
 --- snip ---
 [[3,0.1],8.99,6,-0.2]]
@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2009-12 から 2010-01 にかけて最初の版が書かれた.
@item @code{OpenXM/src/asir-contrib/packages/src/tk_pfn.rr} 1.1, 1.2
@item このモジュールの前身は @code{tk_pf2.rr} である. これは独立変数が 2 個の場合である.  
@end itemize


@node tk_pfn.graph,,, 実験的仕様の関数
@subsection @code{tk_pfn.graph}
@findex tk_pfn.graph

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item tk_pfn.graph(@var{Pf},@var{Dom},@var{Iv},@var{Step})
:: 2変数 Pfaffian 方程式を Runge-Kutta 法で解いてグラフ表示する.
@end table

@table @var
@item return
リスト  リストの要素は以下の形式 [[xの値,yの値],Y_1の値,Y_2の値, ...].
[xの値, yの値] は [0,0],[0.2,0],[0.4,0], ... , [0,0.2],[0.2,0.2], ... のように 
y の値が外側ループ, x の値が内側ループの形式で増える.
@item Pf, Dom, Iv, Step
@var{Pf} は Pfaffian 方程式の係数行列リスト.  独立変数は x, y で固定.
@var{Dom} リスト. 解くべき領域.
@var{Iv} リスト. 領域の左端での初期値.
@var{Step} 刻み幅.
@end table

@itemize @bullet
@item tk_pf2.rr, mt_graph.rr を import しておく必要がある.
@item この関数は連立Pfaffian方程式 dY/dx = Pf[0] Y, dY/dy = Pf[1] Y を数値的に解いてグラフ表示する. 
@item @var{Dom} は [[xmin,xmax],[ymin,ymax]] の形式.
@item 例はソースコード (@code{OpenXM/lib/asir-contrib/tk_pfn.rr} )の @code{tk_pfn.testgraph1()}, @code{tk_pfn.testgraph2()} を参照.
@item option としては fit=1 がある. Z軸を適宜調整する.
@item @var{Dom} の端はグラフ表示の時に一部カットされるので注意.
@end itemize

@example
[1355] import("tk_pf2.rr"); import("mt_graph.rr"); import("tk_pfn.rr");
[1590] tk_pfn.testgraph1();

ここで testgraph1() は以下のとおり. 
def testgraph1() @{
  /* tk_bess2.bess2pf(1/2); */
  Pf=  [[[ 0, (1)/(x), 0 ],
         [ -x, (2*x^2+1)/(x), -2*x ],
         [ -y, 0, 0 ]],
        [[ 0, 0, (1)/(y) ],
         [ -x, 0, 0 ],
         [ -x, (1/2)/(x), (-1/2)/(y) ]]];
  /* tk_bess2.bess2Iv(1/2,[0.5,1.5]); */
  Iv = [0.105994,-0.651603,-0.760628];
  Dom=[[0.5,1.5],[1.5,9]];
  Step = 0.5;
  return tk_pfn.graph(Pf,Dom,Iv,Step | fit=1);  
@}


@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2010-08 に最初の版が書かれた.
@item @code{OpenXM/src/asir-contrib/packages/src/tk_pfn.rr} 1.8
@end itemize

@node tk_rk.runge_kutta_4,,, 実験的仕様の関数
@subsection @code{tk_rk.runge_kutta_4}
@findex tk_rk.runge_kutta_4

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item tk_rk.runge_kutta_4(@var{Eq},@var{X},@var{Y},@var{X0},@var{Y0},@var{Terminal},@var{Step})
:: 4次の Runge-Kutta 法による微分方程式の数値近似解
@end table

@table @var
@item return
リスト  リストの要素は以下の形式 [@var{X}の値,Y_1の値,Y_2の値, ...].
 @var{X} の値は減っていく. よってリストの先頭が @var{Terminal} 付近での @var{Y} の値.
@item Eq, X, Y, Step
@var{Eq} は 方程式の右辺. リスト. Y[0]'=Eq[0], Y[1]'=Eq[1], ... である.
@var{X} 独立変数名.
@var{Y} リスト. 従属変数のリスト.
@var{Step} 刻み幅.
@item X0, Y0, Terminal
@var{X0} 出発点の @var{X} の値.
@var{Y0} 出発点での @var{Y} の初期値.
@var{Terminal} @var{X} の終着点.
@end table

@itemize @bullet
@item taka_runge_kutta.rr を import しておく必要がある.
@item この関数は連立常微分方程式 Y[0]'=Eq[0], Y[1]'=Eq[1], ... を数値的に解く.
@item 例はソースコード (@code{OpenXM/lib/asir-contrib/src/taka_runge_kutta.rr} )の 
@code{tk_rk.test4()} を参照.
@end itemize

@example
[1355] import("taka_runge_kutta.rr");
[1590] tk_rk.test4();

ここで test4() は以下のとおり. 振動の方程式, y0'=y1, y1'=-y0 (y0''+y0=0). 答は y0=cos(x)
taka_plot_auto は下方向で y が正.

def test4() @{
  A=runge_kutta_4([y1,-y0],x,[y0,y1],0,[1,0],3.14*2,0.1);
  taka_plot_auto(A);
  return(A);
@}

@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2000 年代の前半に最初の版が書かれた. 2010年 Pfaffian の数値解析の為に再度整備
@item @code{OpenXM/src/asir-contrib/packages/src/taka_runge_kutta.rr} 1.17
@end itemize

@node tk_rk.runge_kutta_4_linear,,, 実験的仕様の関数
@subsection @code{tk_rk.runge_kutta_4_linear}
@findex tk_rk.runge_kutta_4_linear

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item tk_rk.runge_kutta_4_linear(@var{P},@var{X},@var{Y},@var{X0},@var{Y0},@var{Terminal},@var{Step})
:: 4次の Runge-Kutta 法による微分方程式の数値近似解. 線形方程式専用.
@end table

@table @var
@item return
リスト  リストの要素は以下の形式 [@var{X}の値,Y_1の値,Y_2の値, ...].
 @var{X} の値は減っていく. よってリストの先頭が @var{Terminal} 付近での @var{Y} の値.
@item P, X, Y, Step
@var{P} は 方程式の右辺. リスト. Y'=P Y である. 従属変数 @var{Y} は不要.
@var{X} 独立変数名.
@var{Y} リスト. 従属変数のリスト. 従属変数は自動生成される. 使われていないので空リストでよい.
@var{Step} 刻み幅.
@item X0, Y0, Terminal
@var{X0} 出発点の @var{X} の値.
@var{Y0} 出発点での @var{Y} の初期値.
@var{Terminal} @var{X} の終着点.
@end table

@itemize @bullet
@item taka_runge_kutta.rr を import しておく必要がある.
@end itemize

@example
[1355] import("taka_runge_kutta.rr");
[1590] A=tk_rk.runge_kutta_4_linear([[0,1],[-1,0]],x,[ ], 0, [1,0], 3.14*2, 0.1);
[1591] taka_plot_auto(A);

振動の方程式, y0'=y1, y1'=-y0 (y0''+y0=0). 答は y0=cos(x) を解いている.
taka_plot_auto は下方向で y が正.

@end example


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item 2010年 Pfaffian の数値解析の為に再整備.
@item @code{OpenXM/src/asir-contrib/packages/src/taka_runge_kutta.rr} 1.17
@end itemize



@node fj_simplify.simplify,,, 実験的仕様の関数
@subsection @code{fj_simplify.simplify}
@findex fj_simplify.simplify

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item fj_simplify.simplify(@var{arg1})
:: arg1 を簡単化する.
@end table

@table @var
@item return
多項式, 有理式 または quote
@item arg1
多項式 または 有理式
@end table

@itemize @bullet
@item
この関数は
Joel S. Cohen, Computer Algebra and Symbolic Computation,
http://web.cs.du.edu/~jscohen/MathematicalMethods/index.htm
に記述されている Automatic simplification algorithm と
B.F.Caviness, R.J.Fateman, Simplification of Radical Expressions (1976)
に記述されている radcan アルゴリズムの実装である.
@item 
複素多値関数としては (x*y)^a = x^a*x^b は一般には成立しないので, 結果を複素関数に使うときは
注意が必要である. (x^a = exp(a*log(x)) なので)
@end itemize

@example
import("fj_simplify.rr");
[1434] fj_simplify.simplify((x^(1/2))^3);
((x)^(3/2))
[1435] fj_simplify.simplify((2^(1/2))^2);
2
[1436] fj_simplify.simplify((2+2^(1/2))^3);
14*((2)^(1/2))+20
[1437] fj_simplify.simplify(exp(x)*exp(-x+y));
((@@e)^(y))
@end example

@table @t
@item 参照
@ref{quote}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
Todo: exp 以外の特殊関数についてのsimplification の機能.
@item 
この関数は 2010.01 に M.Fujimoto により最初の版が書かれた. 
OpenXM/src/asir-contrib/packages/src/fj_simplify.rr
@end itemize

@node tk_jack.zonal,,, 実験的仕様の関数
@subsection @code{tk_jack.zonal}
@findex tk_jack.zonal

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item tk_jack.zonel(@var{p},@var{n})
:: 分割 p に対する n 変数の zonal 多項式を出力する. 
@end table

@table @var
@item return
多項式. x_1, x_2, ... が変数.
@item p
数のリスト. p=[p0,p1,...] の時 p0>=p1>=...>0. 
@item n
自然数
@end table

@itemize @bullet
@item
この関数は
Koev-Edelman による Pieri 型公式を用いた Jack symmetric function の計算
アルゴリズムの実装である.
詳しくは Wikipedia 英語版 Jack symmetric function の項を参照.
@item zonal(P,N) = jack(P,N,2) である.
@end itemize

@example
load("tk_jack.rr");
[1434] tk_jack.zonal([3,2,1],3);
(112*x_3*x_2^2+112*x_3^2*x_2)*x_1^3+(112*x_3*x_2^3+168*x_3^2*x_2^2+112*x_3^3*x_2)*x_1^2+(112*x_3^2*x_2^3+112*x_3^3*x_2^2)*x_1
[1435] tk_jack.zonal([1,1],3);
(2*x_2+2*x_3)*x_1+2*x_3*x_2
[1436]  tk_jack.jack([1,1],3,2);
(2*x_2+2*x_3)*x_1+2*x_3*x_2
@end example

@table @t
@item 参照
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は wishart 分布に従う対称行列の第一固有値が x 以下である確率の計算を 
holonomic gradient method でやるためにその初期値を計算する C のプログラムが
必要であった. それを debug するためにとりあえず書いたもの.
@item 最適化をまだまださぼってる.
@end itemize

@node ot_hgm_ahg.cbase,,, 実験的仕様の関数
@subsection @code{ot_hgm_ahg.cbase}
@findex ot_hgm_ahg.cbase

@table @t
@item cbase(@var{A})
::  @var{A} で定義される A-超幾何方程式系の Pfaffian の基底を求める. 
@end table

@table @var
@item return
Pfaffianの基底(微分作用素のモノミアル)のリスト
@item A
整数を成分とする行列 (maximal rank のもの)を表すリスト
@end table

@itemize @bullet
@item A-超幾何イデアルの Q(x)[dx] における標準基底は Pfaffian の基底となるが, 逆はかならずしも真ではない.  個数はもちろん同じである. 
@item
アルゴリズムは
T.Hibi, K.Nishiyama, N.Takayama, Pfaffian Systems of A-Hypergeometric Equations I, Bases of Twisted Cohomology Groups, arxiv:1212.6103 
による.
さらにパラメータ b を数に特殊化する確率算法を用いている.
@end itemize

@example
[2190] import("ot_hgm_ahg.rr");
1
[2191] ot_hgm_ahg.cbase([[1,1,1,1],[0,1,2,3]]);
We use a probabilistic algorithm to determine the base.[dx2^2,dx3*dx2,dx3^2]

[dx3,dx4,1]
@end example

@table @t
@item 参照
@ref{get_mat2}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は 2012  から 2014-春休みにかけてかかれた.
@item version 1.1 以前の版は h-mle/A-hg/Prog  (研究グループの共有フォルダ) にあり.
@end itemize

@node ot_hgm_ahg.get_mat2,,, 実験的仕様の関数
@subsection @code{ot_hgm_ahg.get_mat2}
@findex ot_hgm_ahg.get_mat2
@comment get_mat2
@table @t
@item get_mat2(@var{A},@var{W},@var{Std},@var{Mset})
::  @var{A} で定義される A-超幾何方程式系 H_A の Pfaffian の基底を求めるための Sylvester 法 を適用するための行列を生成する.
@end table

@table @var
@item return
リスト
@item A
整数を成分とする行列 (maximal rank のもの)を表すリスト
@item W
リスト. toric ideal のグレブナー基底を計算するための weight vector.
多分なんでもいいはず.
@item Std
リスト. Pfaffian の基底.  cbase(A) の出力を用いる.
@item Mset
Sylvester 型行列を作るための微分作用素のモノミアルのリスト.
@end table

@itemize @bullet
@item 出力を @var{P} に代入すると,
@var{P}[0]*@var{P}[2] - @var{P}[1]*@var{Std} が modulo  H_A で 0 となる.
@var{P}[0] と @var{P}[2] を結合した行列が, sylvester 行列 (論文の記号での F').
@var{P}[2], @var{Std} が index モノミアルである. 
論文での記号では @var{P}[2] は M_t,  @var{Std} は S.
@item
アルゴリズムは
K.Ohara, N.Takayama, Pfaffian Systems of A-Hypergeometric Equations II, Holonomic Gradient Method
による.  論文の行列 F'.
@end itemize

@example
[2190] import("ot_hgm_ahg.rr");
1
[2191] A=[[1,1,1,1],[0,1,2,3]]$
Std=ot_hgm_ahg.cbase(A)$
W=[[dx1,1,dx2,1,dx3,1,dx4,1]]$
Mset=[1,dx1,dx2,dx3,dx4]$
[2192] ot_hgm_ahg.get_mat2(A,W,Std,Mset);

省略
@end example

@table @t
@item 参照
@ref{cbase}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は 2012  から 2014-春休みにかけてかかれた.
@item version 1.1 以前の版は h-mle/A-hg/Prog  (研究グループの共有フォルダ) にあり.
@item
ソース ot_hgm_ahg.rr の test3(), test3b(), test4(), test5(), test6(), test6c() 等に利用例がある.
@item
test3b() で @var{Mset} を一次式全部にしたものが, 論文の例.
@end itemize

@comment -------------------
@comment  hgm_ahg_contiguity
@comment -------------------
@node ot_hgm_ahg.hgm_ahg_contiguity,,, 実験的仕様の関数
@subsection @code{ot_hgm_ahg.hgm_ahg_contiguity}
@findex ot_hgm_ahg.hgm_ahg_contiguity

@table @t
@item hgm_ahg_contiguity(@var{A},@var{StdMon},@var{Line},@var{X0},@var{InitVal},@var{Start},@var{End})
::  @var{A} で定義される A-超幾何方程式系のcontiguity relation
を Sylvester matrix を用いて計算し, それを用いて超幾何関数の値を求める.
@end table

@table @var
@item return
基底を超幾何関数に作用させたベクトルの値 F(End;X0) ??
@item A
整数を成分とする行列 (maximal rank のもの)を表すリスト.
@item StdMon
リスト.  Pfaffian の基底を与える微分作用素のモノミアルのリスト.
@item Line
リスト  [ContiDir,Beta,Z].
@item X0
リスト. x 変数の値. 
@item InitVal
リスト. 基底を超幾何関数に作用させたベクトルの初期値 F(Start;X0)
@item Start
リスト.   Z パラメータの初期値??
@item End
リスト.   Z パラメータの終端値??
@end table

@itemize @bullet
@item Todo, この関数のインタフェースは変更される予定.
@item  X0 は有理数のリスト.
@item ContiDir は End-Start と同じ方向.
@item Beta.  A超幾何関数の B パラメータの初期値 ??
@item Z.  ContiDir での一次元 contiguity を表現するための不定元の名前.
@item ソース中の利用例. test_fd_conti(), test_c111_conti() 
@item
アルゴリズムおよび利点は
K.Ohara, N.Takayama, Pfaffian Systems of A-Hypergeometric Equations II, Holonomic Gradient Method
参照.
@end itemize

@example
[2190] import("ot_hgm_ahg.rr");
1
[2191] ot_hgm_ahg.test_fd_conti();
(Todo, 引数がどうなるかの例を加える.)
@end example

@table @t
@item 参照
@ref{get_mat2}
@ref{hgm_ahg_expected_value_contiguity}
@ref{hgm_ahg}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は 2014-07-11 に最初の版が 1.10版 ot_hgm_ahg.rr に commit された. 
@item インタフェースが更新された版は, 1.??版.
@end itemize

@comment -------------------
@comment  tk_hgpoly.optip
@comment -------------------
@node tk_hgpoly.optip,,, 実験的仕様の関数
@subsection @code{tk_hgpoly.optip}
@findex tk_hgpoly.optip

@table @t
@item hgpoly.optip(@var{A},@var{B},@var{W})
::  整数計画問題をグレブナー基底を用いて解く.
@end table

@table @var
@item return
リスト.  
@item A
非負整数を成分とする行列 (maximal rank のもの)を表すリスト
@item B
非負整数を成分とするベクトルを表すリスト
@item W 
非負整数を成分とするベクトルを表すリスト
@end table

@itemize @bullet
@item  @var{A} U = @var{B} を満たす非負の整数ベクトル U の中で,
内積 @var{W} U を最小化する U を戻す.
@end itemize

@example
[0] import("tk_hgpoly.rr");
[2191] tk_hgpoly.optip([[1,1,1,1],[0,1,2,3]],[20,40],[1,1,1,0]);
[6,1,0,13]
@end example

@table @t
@item 参照
@ref{feasible}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は   2014-12-12 に commit された.
元版は h-mle/A-hg/Prog
@end itemize

@comment -------------------
@comment  tk_hgpoly.hgpoly
@comment -------------------
@node tk_hgpoly.hgpoly,,, 実験的仕様の関数
@subsection @code{tk_hgpoly.hgpoly}
@findex tk_hgpoly.hgpoly
@table @t
@item hgpoly.hgpoly(@var{A},@var{B})
::  @var{A}, @var{B} で定義される超幾何多項式を計算する.
@end table

@table @var
@item return
リスト.  
@item A
非負整数(todo, 再度確認)を成分とする行列 (maximal rank のもの)を表すリスト
@item B
非負整数を成分とするリスト.
@end table

@itemize @bullet
@item  戻り値を F とするとき, F[0] が超幾何多項式. 変数は x_1, x_2, ...
F[1] は F[0] の分散表現多項式.
@end itemize

@example
[0] import("tk_hgpoly.rr");
[2191] tk_hgpoly.hgpoly([[1,1,1,1],[0,1,2,3]],[2,2]);
[x_3*x_1+1/2*x_2^2,(1/2)*<<0,2,0,0>>+(1)*<<1,0,1,0>>]
@end example


@noindent
ChangeLog
@itemize @bullet
@item 
この関数は   2014-12-12 に commit された.
@end itemize

@comment -------------------
@comment  tk_fd.abc2ahg
@comment -------------------
@node tk_fd.abc2ahg,,, 実験的仕様の関数
@subsection @code{tk_fd.abc2ahg}
@findex tk_fd.abc2ahg
@table @t
@item tk_fd.abc2ahg(@var{A},@var{B},@var{C})
::  F_D(@var{A}, @var{B},@var{C}) を解にもつ A-超幾何方程式系を求める.
@end table

@table @var
@item return
リスト. 
@item A
数
@item B
数のリスト
@item C
数
@end table

@itemize @bullet
@item 戻り値リストの第０成分は A-超幾何方程式系を定義する行列.
第１成分はA-超幾何方程式系のパラメータβ.
@end itemize

@example
[2191] tk_fd.abc2ahg(-3,[-4,-5],3);

[[[0,0,0,1,1,1],[1,0,0,1,0,0],[0,1,0,0,1,0],[0,0,1,0,0,1]],[11,5,4,5]]
@end example

@table @t
@item 参照
@ref{abc2marginal}
@ref{marginal2abc}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は   2014-12-13 に tk_fd.rr に追加された.
@end itemize

@comment -------------------
@comment  tk_fd.ahvec_abc
@comment -------------------
@node tk_fd.ahvec_abc,,, 実験的仕様の関数
@subsection @code{tk_fd.ahvec_abc}
@findex tk_fd.ahvec_abc
@table @t
@item tk_fd.ahvec_abc(@var{A},@var{B},@var{C},@var{Y} | all=1)
::   abc2marginal(@var{A}, @var{B},@var{C})  を周辺和にもつ (2,m+1) 分割表全体についての正規化定数 Z, および Z の変数 Y[1][0], ..., Y[1][m]
(2番目の行)についての偏微分を計算する.
@end table

@table @var
@item return
リスト @var{Ans}
@item A
数
@item B
数のリスト. 長さは m.
@item C
数
@item Y
(2,m+1) 変数値をあらわすリストのリスト. 
@end table

@itemize @bullet
@item 
@var{A}, @var{B}, @var{C}, に現れる数は整数を与える.
@var{Y} の成分は有理数を与える.
@item 
@var{Ans}[2]*@var{Ans}[1] が Z.
@var{Ans}[2]*@var{Ans}[0][I] が Z の Y[1][I] についての偏微分.
@item
論文
1.Y.Goto, Contiguity relations of Lauricella's F_D revisited,  arxiv:1412.3256
で導出されている
contiguity relation を用いて計算する.
@end itemize

@example
[2449] marginal2abc([3,12],[6,3,3,3]);
[-3,[-3,-3,-3],4]

[2450] tk_fd.ahvec_abc(-3,[-3,-3,-3],4,[[1,1/2,1/3,1/4],[1,1,1,1]]);
[[ 24041/1152 143551/11520 16973/1280 78827/5760 ],1/7776]

[2451] expectation_abc(-3,[-3,-3,-3],4,[[1,1/2,1/3,1/4],[1,1,1,1]]);
[721230/173593,430653/173593,458271/173593,67566/24799]
@end example

@table @t
@item 参照
@ref{expectation_abc}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
この関数は   2014-夏に開発された.
@end itemize


@node pari setbprec setround todouble mpfr_gamma mpfr_floor mpfr_round,,, 実験的仕様の関数
@subsection @code{pari}, @code{setbprec},@code{setround},@code{todouble},@code{mpfr_gamma},@code{mpfr_floor},@code{mpfr_round},
@findex pari
@findex setbprec
@findex setround
@findex todouble
@findex mpfr_gamma
@findex mpfr_floor
@findex mpfr_round

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item pari(@var{arg1},@var{arg2},...)
::  MPFR で pari の関数を emulate するか ox_pari サーバーを呼び出す.
@itemx setbprec(@var{arg1})
@itemx setround(@var{arg1})
   丸めの方法の指定. mpfr 準拠.
@itemx todouble(@var{arg1})
:: bigfloat 型を double に変換する.
@itemx mpfr_gamma(@var{arg1})
:: gamma 関数の計算.
@itemx mpfr_floor(@var{arg1})
::  floor の計算.
@itemx mpfr_round(@var{arg1})
:: 丸めの計算.
@end table

@table @var
@item return
後述.
@item arg1, arg2
後述.
@end table

@itemize @bullet
@item 20150807 以降の asir では, bigfloat が pari ではなく mpfr を用いて計算される.
Todo, pari は ox_pari を呼び出すが, まだ ox_pari に未実装の機能が多くある.
区間演算への対応は行っていない.
@item
pari(floor,@var{arg1}), 
pari(round,@var{arg1}), 
pari(gamma,@var{arg1})
は mpfr で pari を emulate しているので, 動作が異なる.
特に gamma は複素数の引数を受け取らない.
pari の floor は桁数が足りなくなるとエラーで終了したが, 
この floor では setprec で指定した桁数以内なら正しく floor を戻す. 
Todo, ox_pari  を指定して呼び出す方法.
@end itemize

@example
[219] ctrl("bigfloat",1)$
[220] setprec(100)$
[221] pari(floor,1111111111111.1+1/10);
1111111111111
@end example

@table @t
@item 参照
@ref{pari}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item これらの大変更は 2015-08-03 より 08-07 の asir 合宿でおこなわれた.
まだ作業中.  Todo, asirgui への対応. debug, ...
@item 変更をうけたソースコードは asir2000/builtin/bfaux.c, 
asir2000/engine/bf.c, asir2000/builtin/parif.c 等多数.
@end itemize

@comment ****************************************************************
@comment --- ◯◯◯◯  以下他の関数について真似して記述する. ◯◯◯◯
@comment 新しい関数の説明を書くためのテンプレートである. 消すな.
@comment --- ◯◯◯◯  関数 syz_pqr, xyz_stu の説明 ◯◯◯◯
@comment --- 複数の関数をまとめて説明する例 ---
@node xyz_pqr syz_stu,,, 実験的仕様の関数
@comment @menu にも * syz_pqr syz_stu::  と続けて書く事. 分けてはいけない.
@subsection @code{xyz_pqr}, @code{syz_stu}
@findex xyz_pqr
@findex xyz_stu

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item xyz_pqr(@var{arg1},@var{arg2}[,@var{flag}])
@itemx xyz_stu(@var{arg1},@var{arg2})
:: xyz に関する操作.
@end table

@table @var
@item return
整数
@item arg1, arg2
整数
@item flag
0 または 1
@end table

@itemize @bullet
@item この項目は新しい関数の説明を書くためのテンプレートである. 消すな.
@item
@code{xyz_pqr()} は, @var{arg1}, @var{arg2} を pqr する.
@item
@var{flag} が 0 でないとき, モジュラ計算を行う.
@item
@code{xyz_stu()} は stu アルゴリズムを用いる.
@end itemize

@example
[219] xyz_pqr(1,2);
3
[220] xyz_pqr(1,2,1);
3
0
[221] xyz_stu(1,2);
3
@end example

@table @t
@item 参照
@ref{xyz_abc}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-3-1 から 2004-3-14 にかけて アルゴリズム xyz (論文
 http://www.afo.org/xyz.pdf ) を用いて書き直された.
 変更をうけたソースコードは xxxyy.rr, ppp.c である.
@item この関数は 2000 頃にはじめてのバージョンが書かれた. ソースは ppp.c である.
@end itemize

@comment --- おまじない ---
@node Index,,, Top
@unnumbered Index
@printindex fn
@printindex cp
@iftex
@vfill @eject
@end iftex
@summarycontents
@contents
@bye
@comment --- おまじない終り ---
