%% $OpenXM: OpenXM/src/asir-doc/exp/exp-ja.texi,v 1.15 2004/07/14 05:48:44 takayama Exp $
\input texinfo
@iftex
@catcode`@#=6
@def@fref#1{@xrefX[#1,,@code{#1},,,]}
@def@b#1{{@bf@gt #1}}
@catcode`@#=@other
@end iftex
@overfullrule=0pt
@c -*-texinfo-*-
@comment %**start of header
@comment --- おまじない終り ---

@comment --- GNU info ファイルの名前 ---
@setfilename xyzman

@comment --- タイトル ---
@settitle 実験的仕様の関数

@comment %**end of header
@comment %@setchapternewpage odd

@comment --- おまじない ---
@ifinfo
@macro fref{name}
@ref{\name\,,@code{\name\}}
@end macro
@end ifinfo

@iftex
@comment @finalout
@end iftex

@titlepage
@comment --- おまじない終り ---

@comment --- タイトル, バージョン, 著者名, 著作権表示 ---
@title 実験的仕様の関数
@subtitle Risa/Asir 実験的仕様関数説明書
@subtitle 1.0 版
@subtitle 2004 年 7 月

@author  by Risa/Asir committers
@page
@vskip 0pt plus 1filll
Copyright @copyright{} Risa/Asir committers
2004. All rights reserved.
@end titlepage

@comment --- おまじない ---
@synindex vr fn
@comment --- おまじない終り ---

@comment --- @node は GNU info, HTML 用 ---
@comment --- @node  の引数は node-name,  next,  previous,  up --- 
@node Top,, (dir), (dir)

@comment --- @menu は GNU info, HTML 用 ---
@comment --- chapter 名を正確に並べる ---
@comment --- この文書では chapter XYZ, Chapter Index がある.
@comment ---  Chapter XYZ には section XYZについて, section XYZに関する関数がある.
@menu
* Experimental Functions::
* Index::
@end menu

@comment --- chapter の開始 ---
@comment --- 親 chapter 名を正確に. 親がない場合は Top ---
@node 実験的仕様の関数,,, Top
@chapter 実験的仕様の関数

@comment --- section 名を正確に並べる.  ---
@menu
* 実験的仕様の関数説明書について::
* 実験的仕様の関数::
@end menu

@comment --- section ``XYZについて'' の開始 ---  section XYZについての親は chapter XYZ
@node 実験的仕様の関数説明書について,,, XYZ
@section 実験的仕様の関数説明書について

@comment --- 書体指定について ---
@comment --- @code{} はタイプライタ体表示 ---
@comment --- @var{} は斜字体表示 ---
@comment --- @b{} はボールド表示 ---
@comment --- @samp{} はファイル名などの表示 ---

この説明書では
@b{Asir} に導入された実験的仕様の関数について説明する.
正式な関数として導入されたものの記述は Risa/Asir マニュアル
に移動される.
ChangeLog の項目は www.openxm.org の cvsweb で
ソースコードを読む時の助けになる情報が書かれている.

@comment --- section ``実験的関数'' の開始 --- 
@node 実験的仕様の関数,,, 実験的仕様の関数
@section 実験的仕様の関数

@comment --- section ``実験的関数'' の subsection xyz_abc 
@comment --- subsection xyz_pqr xyz_stu がある.
@menu
* quotetotex::
* quotetotex_env::
* objtoquote::
* copyright::
* string_to_tb::
* tb_to_string::
* write_to_tb::
* dp_gr_main::
* asir-port.sh::
* asir-install.sh::
* get_struct_name::
* get_element_names::
* get_element_at::
* put_element_at::
* dp_initial_term::
* dp_order::
* dp_weyl_gr_main::
* list::
* mapat::
* set_print_function::
* small_jacobi::
* flatten_quote::
* sprintf::
* quote_to_funargs::
* funargs_to_quote::
* remove_paren::
@end menu

@comment --- ◯◯◯◯  関数 quotetotex, quotetotex_env の説明 ◯◯◯◯ 
@comment --- 個々の関数の説明の開始 ---
@comment --- section 名を正確に ---
@node quotetotex quotetotex_env,,, 実験的仕様の関数
@subsection @code{quotetotex}, @code{quotetotex_env}
@comment --- 索引用キーワード
@findex quotetotex
@findex quotetotex_env

@comment --- 関数の簡単な説明 ---
@table @t
@item quotetotex(@var{q}) 
:: @var{q} を latex 形式で表現した文字列に変換する.
@item quotetotex_env(@var{key},@var{value})
:: quotetotex の動作を制御するパラメータを変更する.
@item quotetotex_env()
:: quotetotex の動作を制御するパラメータの現在値を戻す.
@item quotetotex_env(0)
:: quotetotex の動作を制御するパラメータをデフォールト値に戻す.
@end table

@comment --- 引数の簡単な説明 ---
@table @var
@item return
文字列(quotetotex) または リストまたはオブジェクト(quotetotex_env)
@item q
quote
@item key
文字列
@item value
オブジェクト
@end table

@comment --- ここで関数の詳しい説明 ---
@comment --- @itemize〜@end itemize は箇条書き ---
@comment --- @bullet は黒点付き ---
@itemize @bullet
@item
quotetotex は @var{q} を latex 形式で表現した文字列に変換する.
@item 
以下 quotetotex_env のパラメータの意味を説明する.
@item 
conv_rule: 3 ビットを用いて変換ルールを指定する.
0ビット目は symbol_table による変換を行うか,
1ビット目は添字変換を行うか,
2ビット目は d から始まる変数名を微分作用素とみなして処理するか,
を意味する.
たとえば conv_rule として 3 を指定すると,
0ビット目, 1 ビット目が 1 となるので
symbol_table による変換を行い, 添字変換をおこなう.
添字変換は数字と英字の境目および _ 記号を区切りとする.
symbol_table による変換が最初に適用される.
alpha, beta, 等は自動的をギリシャ文字に変換するテーブルは
内蔵ずみ.
@item 
  dp_vars_prefix: 分散表現多項式は
  @tex 
  $x_0, x_1, \cdots$
  @end tex 
  の多項式として latex 形式に変換されるがこの
  x の部分を変更する.
@item 
  dp_vars_origin: インデックスの始まりの値を指定する.
  デフォールトは 0.
@item
dp_vars_hweyl: 分散表現多項式をワイル代数の元とみなして
latex 形式に変換する.
偶数個変数があるときは 最初の半分を 
@tex 
$x_0, x_1, \cdots$
@end tex 
に
後半の半分を
@tex 
$\partial_0, \partial_1, \cdots$
@end tex 
に変換する.
奇数個の場合は最後の変数が同時化変数として h で表示される.
@item
  dp_dvars_prefix: dp_vars_hweyl が 1 の時に後半部分の prefix を指定する.
  デフォールトは @tex $\partial$ @end tex
@item
  dp_dvars_origin: dp_vars_hweyl が 1 の時のインデックスの始まりの値.
@item 
conv_func: ユーザ定義の変換関数をよぶ.
@item 

@end itemize

@comment --- @example〜@end example は実行例の表示 ---
@example
[3] quotetotex(quote(1/(x+1)));
\frac@{ 1@} @{ (  @{x@}+ 1)@}
[4]  quotetotex(objtoquote(diff(x^x,x)));
   @{x@}^@{  @{x@}- 1@}   @{x@}+  \log( @{x@})   @{x@}^@{ @{x@}@}
[5] quotetotex_env("conv_rule",3);
[6] quotetotex(objtoquote( (alpha2beta+x_i_j)^2));
  @{\alpha@}_@{2,\beta@}^@{ 2@} +   2  @{x@}_@{i,j@}  @{\alpha@}_@{2,\beta@}+  @{x@}_@{i,j@}^@{ 2@}
@end example

@comment --- 参照(リンク)を書く ---
@table @t
@item 参照
@ref{objtoquote}
print_tex_form(contrib)
@end table

@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
 この関数は 2004年2月末から3月にかけて asir を 
 knoppix 版 texmacs に対応させるために書かれた. 
 Asir-contrib の print_tex_form がその原型であり, それを効率化しまた
 出力形式を改善した.
 OpenXM/src/kxx/ox_texmacs.c, OpenXM/src/texmacs も参照.
@item 
 OpenXM/src/asir-contrib/packages/src/noro_print.rr 1.1--1.8, 
 noro_print_default.rr 1.1--1.3 も参照.
@item 
 変更を受けたファイルは OpenXM_contrib2/asir2000 の下の次のファイル.
  builtin/strobj.c 1.14--1.43,
  include/ca.h 1.46, io/cexpr.c 1.18, io/pexpr.c 1.32, io.sexpr.c 1.29,
  parse/arith.c 1.12, parse/parse.h 1.28--1.29,
  parse/quote.c 1.7--1.8, 1.12.
@item 
  knoppix/math は 福岡大学の濱田さんが中心となり開発されている.
@item 
  dp_dvars_prefix, *_origin は builtin/strobj.c 1.46 で導入された.
@item
  Todo: quotetoterminalform (分散表現多項式の見易い出力).
@end itemize



@comment --- ◯◯◯◯  関数 objtoquote の説明 ◯◯◯◯ 
@node objtoquote,,, 実験的仕様の関数
@subsection @code{objtoquote}
@findex objtoquote

@comment --- 関数の簡単な説明 ---
@table @t
@item objtoquote(@var{ob})
:: オブジェクトと quote 型のデータに変換する.
@end table

@table @var
@item return
quote
@item ob
オブジェクト
@end table

@itemize @bullet
@item
@code{objtoquote(ob)} は, @var{ob} を quote 型のデータに変換する.
@end itemize

@example
[1150] quotetolist(quote(1+2));
[b_op,+,[internal,1],[internal,2]]
[1151] quotetolist(objtoquote(1+x));
[b_op,+,[internal,x],[internal,1]]3
@end example

@table @t
@item 参照
@ref{quotetotex} @ref{quotetolist}
@end table

@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数は quotetotex の前処理をするために書かれた.
@item asir-contrib の関数 quote_to_quote も参照.
@item OpenXM_contrib2/asir2000/builtin/print.c 1.16.
@end itemize


@comment --- ◯◯◯◯  関数 copyright の説明 ◯◯◯◯ 
@node copyright,,, 実験的仕様の関数
@subsection @code{copyright}
@findex copyright

@comment --- 関数の簡単な説明 ---
@table @t
@item copyright()
:: Risa/Asir の copyright 表示を文字列として戻す.
@end table

@table @var
@item return
文字列
@end table

@itemize @bullet
@item
Risa/Asir の copyright 表示を文字列として戻す.
@end itemize

@example
[1150] copyright();
This is Risa/Asir, Version 20040312 (Kobe Distribution).
Copyright (C) 1994-2000, all rights reserved, FUJITSU LABORATORIES LIMITED.
Copyright 2000-2003, Risa/Asir committers, http://www.openxm.org/.
GC 6.2(alpha6) copyright 1988-2003, H-J. Boehm, A. J. Demers, Xerox, SGI, HP.
PARI 2.0.17, copyright 1989-1999, C. Batut, K. Belabas, D. Bernardi,
   H. Cohen and M. Olivier.
@end example

@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数は texmacs 用に書かれた (2004-03).
@item OpenXM_contrib2/asir2000 の下の以下のファイルをみよ. builtin/miscf.c 1.21,
      parse/glob.c 1.47.
@end itemize



@comment --- ◯◯◯◯  関数 string_to_tb, ... の説明 ◯◯◯◯ 
@comment --- 複数の関数をまとめて説明する例 ---
@node string_to_tb tb_to_string write_to_tb,,, 実験的仕様の関数
@subsection @code{string_to_tb}, @code{tb_to_string}, @code{write_to_tb}
@findex string_to_tb
@findex tb_to_string
@findex write_to_tb

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item string_to_tb(@var{s})
@itemx tb_to_string(@var{tb})
@itemx write_to_tb(@var{s},@var{tb})
:: 文字列可変長配列型(text buffer)のデータの処理
@end table

@table @var
@item return
文字列可変長配列型(string_to_tb), 文字列型(tb_to_string)
@item s
文字列
@item tb
文字列可変長配列型
@end table

@itemize @bullet
@item
@code{string_to_tb(@var{s})} は, 文字列 @var{s} をはじめの要素とする
文字列可変長配列型オブジェクトを生成する.
@item
@code{tb_to_string_(@var{tb})} は,
文字列可変長配列型オブジェクト @var{tb} から通常の文字列オブジェクトを生成する.
@item
@code{write_to_tb(@var{s},@var{tb})} は, 文字列 @var{s} を
文字列可変長配列型オブジェクト @var{tb} へ書き出す.
@item @var{SS} を文字列変数とするとき,
@var{SS} += "文字列" で @var{SS} へ文字列を書き足していくことができるが,
無駄なメモリを大量に消費する.
代りに関数 @code{write_to_tb} を用いるべきである.
文字列可変長配列型オブジェクトは文字列の可変長の配列でありメモリ管理に優しい
データ構造である.
@end itemize

@example 
[219] T=string_to_tb("");

[220] write_to_tb("Hello",T);
0
[221] write_to_tb(" world!",T);
0
[222] tb_to_string(T);
Hello world!
@end example


@comment --- ChangeLog を書く. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
 この関数は 2004-3 に print_tex_form を効率化するために書かれた.
@item 
 OpenXM_contrib2/asir2000 の下の以下のファイルを見よ.
io/ox_asir.c 1.52, builtin/strobj.c 1.12--1.13, 1.16,
engine/str.c 1.5, parse/quote.c 1.9.
@item 
 rtostr が text buffer 型のデータに関しておそかった. 速度の改善は
 asir2000/io/pexpr_body.c 1.2, asir2000/parse/lex.c 1.32.
@end itemize



@comment --- ◯◯◯◯  関数 dp_gr_main の説明 ◯◯◯◯ 
@comment --- 複数の関数をまとめて説明する例 ---
@node dp_gr_main,,, 実験的仕様の関数
@subsection @code{dp_gr_main}
@findex dp_gr_main

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item dp_gr_main(@var{f} | v=@var{vv}, order=@var{oo}, homo=@var{n}, matrix=@var{m}, block=@var{b}, sugarweight=@var{sw})
:: dp_gr_main の新しいインタフェース.
@end table

@table @var
@item return
リスト (グレブナ基底. 再帰表現多項式か分散表現多項式のリスト)
@item f
リスト  (入力多項式系. 再帰表現多項式か分散表現多項式のリスト)
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@item n
0 か1 (homogenization をするか)
@item m
順序を matrix で表現する場合 (cf. dp_ord).
@item b
???
@item sw
Sugar strategy を適用するときの weight vector. 全ての要素は非負.
@end table

@itemize @bullet
@item
 @code{dp_gr_main(@var{f})} は, @var{f} のグレブナ基底を計算する.
 グレブナ基底は順序を変えるとその形が変わる.   asir ではいままで順序の指定方法が
 系統だっていなかった. 
 dp_gr_main の新しいインタフェースでは順序をある文法に従い指定する.
@comment  ~taka/this03/misc-2003/A2/dp
@item 順序 order は次の文法で定義する.  @{, @} は 0 回以上の繰り返しを意味する.
@example
  order         : '[' orderElement { ',' orderElement } ']'
  orderElement   :  weightVec | builtinOrder
  weightVec     : '[' weightElement { ',' weightElement } ']'
  builtiniOrder : '[' orderName  ',' setOfVariables ']'
  weightElement :   NUMBER | setOfVariables ',' NUMBER
  setOfVariables:  V | range(V,V)
  orderName    : @@grlex | @@glex | @@lex
@end example
ここで @code{V} は 変数名, @code{NUMBER} は整数をあわらす.
例1:  @code{v=[x,y,z,u,v], order=[[x,10,y,5,z,1],[@@grlex,range(x,v)]]}
は @code{x},@code{y},@code{z} がそれぞれ weight 10, 5, 1 をもつ
順序で比較したあと, @code{[x,y,z,u,v]} についての 
graded reverse lexicographic order を tie-breaker として用いることを意味する.
参考書: B.Sturmfels: Gr\"obner Bases and Convex Polytopes (1995).
M.Saito, B.Sturmfels, N.Takayama:
Gr\"obner Deformations of Hypergeometric Differential Equations (2000).
@item
  順序要素 (orderElement) の指定方法は 
 (1) 変数名または rangeで指定された変数の集合と重みの値の繰り返し
 (2) 重みの値を変数リストの順番に並べる方法
 (3) 変数名または rangeで指定された変数の集合と順序名の組
 の三通りの基礎的方法がある.
 似た指定方法が Macaulay, Singular, CoCoA, Kan/sm1 等の環論システムで 
 使用されていた. Risa/Asir の指定方法はこれらのシステムの指定方法を参考に
 さらに改良を加えたもので柔軟性が高い.
@item 
  order の tie-breaker は grlex がデフォールト.
@item 
  分散表現多項式を引数としたときは結果も分散表現多項式として戻る.
  order 指定にもちいるデフォールトの変数名はこのとき x0, x1, x2, ... となる.
@item
  オプションの値は option_list キーワードを用いてリストで与えてもよい.
  下の例を参照.
@end itemize

@example
[218] load("cyclic");
[219] V=vars(cyclic(4));
[c0,c1,c2,c3]
[220]dp_gr_main(cyclic(4) | v=V, order=[[c0,10,c1,1],[c2,5],[@@grlex,range(c0,c3)]]);
[ 10 1 0 0 ]
[ 0 0 5 0 ]
[ R R R R ]
[(-c3^6+c3^2)*c2^2+c3^4-1,c3^2*c2^3+c3^3*c2^2-c2-c3,
 (c3^4-1)*c1+c3^5-c3,(c2-c3)*c1+c3^4*c2^2+c3*c2-2*c3^2,-c1^2-2*c3*c1-c3^2,
 c0+c1+c2+c3]

[1151]  F=map(dp_ptod,katsura(4), vars(katsura(4)));
[(1)*<<1,0,0,0,0>>+(2)*<<0,1,0,0,0>>+ ... ]
[1152] dp_gr_main(F | order=[[range(x0,x3),1]]);
[ 1 1 1 1 0 ]
[ R R R R R ]
[(47774098944)*<<0,0,0,0,13>>+ ... ]

[1153] Opt=[["v",[x,y]], ["order",[[x,5,y,1]]]];  
[[v,[x,y]],[order,[[x,5,y,1]]]]
[1154]  dp_gr_main([x^2+y^2-1,x*y-1] | option_list=Opt);
[ 5 1 ]
[ R R ]
[-y^4+y^2-1,x+y^3-y]
@end example

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2003-12 から 2004-2 の始めに大きな修正が行われた.
@item 
 @code{setOfVariables}の表現のために range オブジェクトが導入された.
@item 
  グレブナ基底は順序を変えるとその形が変わる.   asir ではいままで順序の指定方法が
  系統だっていなかった. 
  dp_gr_main の新しいインタフェースでは順序をある文法に従い指定する.
@item 
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/gr.c 1.56--1.57,
builtin/dp-supp.c 1.27--1.31 (create_composite_order_spec),
builtin/dp.c 1.46--1.48 (parse_gr_option),
engine/Fgfs.c 1.20,
engine/dist.c 1.27--1.28
engine/nd.c 1.89,
include/ca.h 1.42--1.43,
io/pexpr.c 1.28,
io/sexpr.c 1.26,
parse/arith.c 1.11,
parse/glob.c 1.44-1.45,
parse/lex.c 1.29,
parse/parse.h 1.23--1.26
@item
 Todo: return キーワードで戻り値のデータを quote のリストにできるように.
  attribute, ring 構造体.
@end itemize

@comment --- ◯◯◯◯  関数 syz_pqr, xyz_stu の説明 ◯◯◯◯ 
@comment --- 複数の関数をまとめて説明する例 ---
@node asir-install.sh,,, 実験的仕様の関数
@subsection @code{asir-port.sh}, @code{asir-install.sh}
@findex asir-port.sh
@findex asir-install.sh

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item asir-install.sh
@itemx asir-port.sh
:: これは asir の内部コマンドではない. asir をネットワークからダウンロードかつ実行するシェルスクリプト
@end table


@itemize @bullet
@item
asir-port.sh は knoppix 専用である.
このコマンドは asir のバイナリおよび FLL で配布できない部分を
 ftp.math.kobe-u.ac.jp よりダウンロードして
/home/knoppix/.asir-tmp へセーブして, 実行する.
.asirrc および .TeXmacs/plugins/ox/progs/init-ox.scm もダウンロードする.
@item
asir-install.sh は Debian GNU Linux / openxm-binary*.deb 専用である.
asir-install.sh は asir をダウンロードして /usr/local/OpenXM/bin および
/usr/local/OpenXM/lib/asir へインストールする.
@end itemize


@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
 これらのシェルスクリプトは knoppix/math のために 2004/2, 3 月に書かれた.
@item 
  knoppix/math は福岡大学の濱田さんが中心となり開発されている.
@item 
  OpenXM/misc/packages/Linux/Debian の下の全てのファイル (2004-2-22 から
  2004-3 の末まで). ( ~taka/this03/misc-2003/A3/knoppix-03-05 (プライベートファイル) も見よ.)
  OpenXM/src/asir-port の下の次の各ファイル.
  Makefile 1.1--1.8, asir-install.sh 1.1--1.2, asir-port.sh 1.1--1.6.
@end itemize


@node get_struct_name,,, 実験的仕様の関数
@subsection @code{get_struct_name}, @code{get_element_names}, @code{get_element_at}, @code{put_element_at}
@findex get_struct_name
@findex get_element_names
@findex get_element_at
@findex put_element_at

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item get_struct_name(@var{s})
@itemx get_element_names(@var{s})
@itemx get_element_at(@var{s},@var{key})
@itemx put_element_at(@var{s},@var{key},@var{obj})
:: 構造体 @var{s} に対する操作
@end table

@table @var
@item return
文字列 (get_struct_name),
文字列のリスト (get_element_names),
オブジェクト (get_element_at),
オブジェクト (put_element_at)
@item s
構造体
@item key
文字列
@item obj
オブジェクト
@end table

@itemize @bullet
@item
 @code{get_struct_name(s)} は, 構造体 @var{s} の名前を戻す.
@item
 @code{get_element_names(s)} は, 構造体のメンバーの名前のリストを戻す. 
@item
 @code{get_element_at(s,key)} は構造体 s のメンバー key の値を戻す.
@item
 @code{put_element_at(s,key,obj)} は構造体 s のメンバー key の値を obj に設定する.
@end itemize

@example
[219]  struct point { x, y, color};
[220]  P = newstruct(point);
{0,0,0}
[221]  P->x = 10$ P->y=5$ P->color="red"$
[222]  get_element_names(P);
[x,y,color]
[223] put_element_at(P,"color","blue");
blue
[224] P->color;
bule
@end example

@table @t
@item 参照
@ref{newstruct}, @ref{struct}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item  構造体の定義を知らずに構造体を扱うユーザ関数を書くときに便利.
       asir-contrib の noro_print.rr を見よ.
@item  OpenXM_contrib2/asir2000/builtin/compobj.c 1.8.
@end itemize

@comment --- ◯◯◯◯  関数 dp_gr_main の説明 ◯◯◯◯ 
@node dp_weyl_gr_main,,, 実験的仕様の関数
@subsection @code{dp_weyl_gr_main}
@findex dp_weyl_gr_main

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item dp_weyl_gr_main(@var{f} | v=@var{vv}, order=@var{oo}, homo=@var{n}, matrix=@var{m}, block=@var{b}, sugarweight=@var{sw})
:: dp_weyl_gr_main の新しいインタフェース.  dp_gr_main と同じ形式である.
@end table

@table @var
@item return
リスト (グレブナ基底. 再帰表現多項式か分散表現多項式のリスト)
@item f
リスト  (入力多項式系. 再帰表現多項式か分散表現多項式のリスト)
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@item n
0 か1 (homogenization をするか). [テストまだ]
@item m
順序を matrix で表現する場合 (cf. dp_ord). [テストまだ]
@item b
???
@item sw
Sugar strategy を適用するときの weight vector. 全ての要素は非負. [テストまだ]
@end table

@itemize @bullet
@item
 @code{dp_weyl_gr_main(@var{f})} は, @var{f} のグレブナ基底を計算する.
 グレブナ基底は順序を変えるとその形が変わる.   asir ではいままで順序の指定方法が
 系統だっていなかった. 
 dp_weyl_gr_main の新しいインタフェースでは順序をある文法に従い指定する.
 指定方法については dp_gr_main のマニュアルを参照.
@item 
 分散表現多項式の各モノミアルの長さが偶数のときはワイル代数
 K[x_1, ..., x_n, d_1, ..., d_n]
で計算がおこなわれる. ワイル代数では x_i と d_i は非可換な掛け算規則 
 d_i x_i = x_i d_i +1 をみたし, x_i と x_j や d_i と d_j は可換である.
 また i と j が異なる場合は x_i と d_j も可換である.
@item 
 分散表現多項式の各モノミアルの長さが奇数のときは同次化ワイル代数
 K[x_1, ..., x_n, d_1, ..., d_n, h]
で計算がおこなわれる. 同次化ワイル代数では x_i と d_i は非可換な掛け算規則 
 d_i x_i = x_i d_i + h^2 
をみたし, h は任意の元と可換, その他の変数もワイル代数と同様な可換性の規則をみたす.
 詳しくは dp_gr_main で参照した Saito, Sturmfels, Takayama の教科書をみよ.
@end itemize

@example
[1220] F=sm1.gkz([ [[1,1,1,1],[0,1,3,4]], [0,0]]);  /* Command in asir-contrib*/
[[x4*dx4+x3*dx3+x2*dx2+x1*dx1,4*x4*dx4+3*x3*dx3+x2*dx2,-dx1*dx4+dx2*dx3,-dx2^2*dx4+dx1*dx3^2,dx1^2*dx3-dx2^3,-dx2*dx4^2+dx3^3],[x1,x2,x3,x4]]
[1221] V=[x1,x2,x3,x4,dx1,dx2,dx3,dx4]$
[1222] dp_weyl_gr_main(F[0] | v=V, order=[[dx1,1,dx2,1,dx3,1,dx4,1]]);
...
[1238] FF=map(dp_ptod,F[0],V);
[(1)*<<1,0,0,0,1,0,0,0>>+(1)*<<0,1,0,0,0,1,0,0>>+(1)*<<0,0,1,0,0,0,1,0>>+(1)*<<0,0,0,1,0,0,0,1>>,(1)*<<0,1,0,0,0,1,0,0>>+(3)*<<0,0,1,0,0,0,1,0>>+(4)*<<0,0,0,1,0,0,0,1>>,0,0,0,0]

[1244] FF=map(dp_ptod,F[0],V);
[(1)*<<1,0,0,0,1,0,0,0>>+(1)*<<0,1,0,0,0,1,0,0>>+(1)*<<0,0,1,0,0,0,1,0>>+(1)*<<0,0,0,1,0,0,0,1>>,(1)*<<0,1,0,0,0,1,0,0>>+(3)*<<0,0,1,0,0,0,1,0>>+(4)*<<0,0,0,1,0,0,0,1>>,(1)*<<0,0,0,0,0,1,1,0>>+(-1)*<<0,0,0,0,1,0,0,1>>,(1)*<<0,0,0,0,1,0,2,0>>+(-1)*<<0,0,0,0,0,2,0,1>>,(-1)*<<0,0,0,0,0,3,0,0>>+(1)*<<0,0,0,0,2,0,1,0>>,(1)*<<0,0,0,0,0,0,3,0>>+(-1)*<<0,0,0,0,0,1,0,2>>]

dp_weyl_gr_main(FF | v=V, order=[[0,0,0,0,1,1,1,1]]);

[1246] dp_weyl_gr_main(FF | v=V, order=[[dx1,1,dx2,1,dx3,1,dx4,1]]);
[ 0 0 0 0 1 1 1 1 ]
[ R R R R R R R R ]
 ...

@end example

@table @t
@item 参照
@ref{dp_gr_main}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item dp_gr_main のインタフェースが dp_weyl_gr_main へも導入された.
@item 
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/dp-supp.c 1.32--1.33
builtin/dp.c 1.49--1.50
@end itemize

@comment --- ◯◯◯◯  関数 dp_initial_term の説明 ◯◯◯◯ 
@node dp_initial_term,,, 実験的仕様の関数
@subsection @code{dp_initial_term}
@findex dp_initial_term

@comment --- 関数の簡単な説明 ---
@table @t
@item dp_initial_term(@var{f} | v=@var{vv}, order=@var{oo})
:: dp_initial_term は与えられた weight に対する先頭項の和を戻す.
@end table

@table @var
@item return
分散表現多項式または分散表現多項式のリスト.
@item f
分散表現多項式か分散表現多項式のリスト.
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@end table

@itemize @bullet
@item
 dp_initial_term は与えられた weight w に対する先頭項の和を戻す.
 これは多くの教科書で @tex ${\rm in}_w(f)$ @end tex 
 と書かれている.
@item
 順序を表すリストは dp_gr_main で定義した文法に従う.
 このリストの先頭が weight vector で無い場合はエラーとなる.
 たとえば order=[[@@lex,...]] はエラーとなる.
@item 
 結果は与えられた順序に関してソートされてるわけではない.
@end itemize

@example
[1220] F=<<2,0,0>>+<<1,1,0>>+<<0,0,1>>;
(1)*<<2,0,0>>+(1)*<<1,1,0>>+(1)*<<0,0,1>>
[1220] dp_initial_term(F | order=[[1,1,1]]);
[ 1 1 1 ]
[ R R R ]
(1)*<<2,0,0>>+(1)*<<1,1,0>>
[1221] dp_initial_term(F | v=[x,y,z], order=[[x,1]]);
[ 1 0 0 ]
[ R R R ]
(1)*<<2,0,0>>
@end example

@table @t
@item 参照
@ref{dp_gr_main}, @ref{dp_weyl_gr_main}, @ref{dp_order}, @ref{dp_hm}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/dp-supp.c 1.32
builtin/dp.c 1.49
@end itemize

@comment --- ◯◯◯◯  関数 dp_order の説明 ◯◯◯◯ 
@node dp_order,,, 実験的仕様の関数
@subsection @code{dp_order}
@findex dp_order

@comment --- 関数の簡単な説明 ---
@table @t
@item dp_order(@var{f} | v=@var{vv}, order=@var{oo})
:: dp_order は与えられた weight に対する次数の最大値を戻す.
@end table

@table @var
@item return
数か数のリスト
@item f
分散表現多項式か分散表現多項式のリスト.
@item vv
リスト  (変数のリスト)
@item oo
リスト  (順序をあらわすリスト)
@end table

@itemize @bullet
@item
 順序を表すリストは dp_gr_main で定義した文法に従う.
 このリストの先頭が weight vector で無い場合はエラーとなる.
 たとえば order=[[@@lex,...]] はエラーとなる.
@item
 dp_order は与えられた weight w に対する次数の最大値を戻す.
 これを @tex ${\rm ord}_w(f)$ @end tex 
 と書く論文や教科書もある.
@item 
 引数がリストの場合各要素の次数が計算される.
@end itemize

@example
[1220] F=<<2,0,0>>+<<1,1,0>>+<<0,0,1>>;
(1)*<<2,0,0>>+(1)*<<1,1,0>>+(1)*<<0,0,1>>
[1222] dp_order(F | order=[[1,1,1]]);
[ 1 1 1 ]
[ R R R ]
2
[1223] dp_order(F | v=[x,y,z], order=[[x,1]]);
[ 1 0 0 ]
[ R R R ]
@end example

@table @t
@item 参照
@ref{dp_gr_main}, @ref{dp_weyl_gr_main}, @ref{dp_initial_term}, @ref{dp_hm}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
  OpenXM_contrib2/asir2000 の下の次の各ファイルが修正をうけた.
builtin/dp-supp.c 1.32
builtin/dp.c 1.49
@end itemize


@comment  mapat
@node mapat,,, 実験的仕様の関数
@subsection @code{mapat}
@findex mapat

@table @t
@item mapat(@var{fname},@var{pos}[,@var{arg0}, @var{arg1}, ...])
:: @var{pos} に対する map 関数
@end table

@table @var
@item return
オブジェクト
@item pos
整数
@item arg0, arg1, arg2, ...
オブジェクト
@end table

@itemize @bullet
@item
@code{map} 関数は 0 番目の引数に対してしか動作しないが, @code{mapat}
関数は指定した番号の引数に対して @code{map} 関数を実行する.
@item
@code{mapat(fname,0,A0,A1,...)} は
@code{map(fname,A0,A1,...)} に等価である.
@item
次の副作用がある. まだ書いてない.
@end itemize

@example
[219] mapat(deg,1,x^2+y^3+x+y,[x,y]);
[2,3]
[220] mapat(subst,1,x+y+z,[x,y,z],2);
[y+z+2,x+z+2,x+y+2]
@end example

@table @t
@item 参照
@ref{map}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-6-22 にコミットされた.
 変更をうけたソースコードは builtin/pf.c, subst.c である.
@end itemize

@comment  list
@node list,,, 実験的仕様の関数
@subsection @code{list}
@findex list

@table @t
@item list([@var{arg0}, @var{arg1}, ...])
:: list を生成する.
@end table

@table @var
@item return
リスト
@item arg0, arg1, arg2, ...
オブジェクト
@end table

@itemize @bullet
@item
@var{arg0}, @var{arg1}, ... を要素とするリストを生成する.
@end itemize

@example
[219] list(1,2,3);
[1,2,3]
[220] list(1,2,[3,4]);
[1,2,[3,4]]
@end example

@table @t
@item 参照
@ref{cons}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-6-22 にコミットされた.
 変更をうけたソースコードは builtin/list.c である.
@end itemize


@node set_print_function,,, 実験的仕様の関数
@subsection @code{set_print_function}
@findex set_print_function

@comment --- 関数の簡単な説明 ---
@table @t
@item set_print_function([@var{fname}])
:: 画面表示用の関数を登録
@end table

@table @var
@item return
整数
@item fname
文字列
@end table

@itemize @bullet
@item
@code{set_print_function} は @code{fname(F)} を通常の画面表示関数の代わりによぶ.
@code 引数がない場合は画面表示関数をデフォールトへ戻す.
@code Asir-contrib はこの関数を用いて出力関数を Asir-contrib 用に変更している.
@end itemize

@example
[219] def my_output(F) {  
           print("Out: ",0); print(rtostr(F));
      }
[220] set_print_function("my_output");
Out: 0
[221]  1+2;
Out: 3
@end example

@table @t
@item 参照
@ref{rtostr}
@end table

@noindent
ChangeLog
@itemize @bullet
@item この関数は 2001-9-4 に asir-contrib のために導入された.
 変更をうけたソースコードは builtin/print.c 1.11 である.
@end itemize


@node small_jacobi,,, 実験的仕様の関数
@subsection @code{small_jacobi}
@findex small_jacobi

@comment --- 関数の簡単な説明 ---
@table @t
@item small_jacobi(@var{a},@var{m})
:: Jacobi 記号の計算
@end table

@table @var
@item return
整数
@item arg1, arg2
整数
@end table

@itemize @bullet
@item 
 @var{m} が素数のときは Legendre 記号とよばれ,
 x^2 = @var{a} mod @var{m} に解があるとき 1, 解がないとき -1 をもどす.
@item
Jacobi 記号は Legendre 記号の積で定義される (初等整数論の本参照).
@item
 この関数は machine int の範囲で jacobi 記号を計算する.
@end itemize

@example
[1286] small_jacobi(2,3);
-1
[1287] small_jacobi(2,7);
1
@end example

@table @t
@item 参照
http://members.jcom.home.ne.jp/yokolabo/asirlib/  
も見てね.
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item この関数の由来は不明.
@end itemize


@node quote_flatten,,, 実験的仕様の関数
@subsection @code{quote_flatten}
@findex quote_flatten

@comment --- 関数の簡単な説明 ---
@table @t
@item quote_flatten(@var{q},@var{op})
:: quote の括弧をとりさる.
@end table

@table @var
@item return
Quote
@item q
Quote
@item op
演算子を表す文字列.
@end table

@itemize @bullet
@item
Quote 型のデータは木構造をしている
( quotetolist 参照 ).
@code{quote_flatten()} は, @var{q} の中にあられる演算子 @var{op} 
の子供ノードを平等にする.
つまり演算子 @var{op} に関する括弧づけがあった場合それをすべてとりさる.
たとえば (1+2)+(3+4) という表現を 1+2+3+4 に変換する.
@item 
 現在の実装では n-ary の演算子は定義されていないので,
 1+2+3 は実は (1+2)+3 と表現されている.
 つまり + 演算子は左結合的である.
@end itemize

@example
[1288] flatten_quote(quote((1+2)+(3+4*(x+3))),"+");
quote(1+2+3+4*(x+3))
[1289] flatten_quote(quote( (x*y)*(p*3)-(x*y)*z),"*");
quote(x*y*p*3-x*y*z)
[1290] quotetolist(quote(1+2+3));
[b_op,+,[b_op,+,[internal,1],[internal,2]],[internal,3]]
@end example

@table @t
@item 参照
@ref{quotetolist}, @ref{print_tex_form}(contrib)
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
 この関数は 2004-7-7 から 2004-7-8 にかけて
 quote に関する操作を研究するために実験的に書かれた.
 OpenXM/fb で蓄積された公式の不要な括弧をとりはずし, tex 形式に変換するのに
 応用.
@item
 変更をうけたソースコードは 
 builtin/strobj.c 1.47,
 parse/eval.c 1.35,
 parse/parse.h 1.31,
 parse/quote.c 1.14--1.16.
@end itemize

@node assoc,,, 実験的仕様の関数
@subsection @code{assoc}
@findex assoc

@comment --- 関数の簡単な説明 ---
@table @t
@item assoc(@var{a},@var{b})
:: 連想リストをつくる
@end table

@table @var
@item return
List
@item a
List
@item b
List
@end table

@itemize @bullet
@item リスト @var{a}, @var{b} より
[[@var{a}[0],@var{b}[0]], [@var{a}[1],@var{b}[1]], ...]
なる新しいリストを生成する.
@end itemize

下の例では @code{A} に動物の名前が,
@code{B} に足の本数が入っている.
@code{assoc(A,B)} で動物と足の本数をペアにしたリストを生成する.

@example
[1192]  A=["dog","cat","snake"];
[dog,cat,snake]
[1193] B=[4,4,0];
[4,4,0]
[1194] assoc(A,B);
[[dog,4],[cat,4],[snake,0]]
@end example

@table @t
@item 参照
@ref{cons}, @ref{append}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@noindent
ChangeLog
@itemize @bullet
@item 
 この関数は 2004-6-28 に書かれた.
 変更をうけたソースコードは 
 builtin/list.c 1.9
 parse/eval.c 1.35,
 parse/parse.h 1.31,
 parse/quote.c 1.14--1.16.
@end itemize


@node sprintf,,, 実験的仕様の関数
@subsection @code{sprintf}
@findex sprintf

@table @t
@item sprintf(@var{format}[,@var{args}])
:: C に似たプリント関数
@end table

@table @var
@item return
文字列
@item format
文字列
@item args
オブジェクト
@end table

@itemize @bullet
@item
フォーマット文字列 @var{format } にしたがい @var{args} を文字列に変換する.
@item
フォーマット文字列の中に @code{%a} (any) が利用可能.
@var{args} の個数はフォーマット文字列の中の @code{%a} の個数に等しくすること.
@end itemize

@example
[0] sprintf("%a: rat = %a",10,x^2-1);
  10: rat = x^2-1
@end example

@table @t
@item 参照
@ref{rtostr}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item 
 この関数は 2004-7-13 にコミットされた.
 変更をうけたソースコードは builtin/strobj (1.50) である.
@item 
 @code{%a} は Maple の sprintf の真似か.
@end itemize


@node quote_to_funargs,,, 実験的仕様の関数
@subsection @code{quote_to_funargs}, @code{funargs_to_quote}, @code{remove_paren}
@findex quote_to_funargs
@findex funargs_to_quote
@findex remove_paren

@table @t
@item quote_to_funargs(@var{q})
::  quote を funarg 形式(リスト) へ.
@item funargs_to_quote(@var{f})
::  funarg 形式を quote へ.
@item remove_paren(@var{q})
::  上の関数を用いて書かれた余分な括弧を取り去る simplifier (asir-contrib マニュアルへ: todo)
@end table

@table @var
@item return
quote(funargs_to_quote, remove_paren) か リスト(quote_to_funargs)
@item q
quote
@item f
リスト 
@end table

@itemize @bullet
@item
 @code{quote_to_funargs} は quote 型のデータ (内部的には FNODE) を
quote への復元可能な形でリストへ変換する.
@code{quotetolist} は quote をリストへ変換するが, 一部の情報を捨てるため
もとの quote の復元はできない.
@item
 @code{quote_to_funargs} の戻り値は [fid, op, arg1, arg2] なる形式をしている.
ここで op はなにか謎 (Todo)
@item
 下の例で
 quote_to_funargs(FA[2]);
[34,[b_op,+,[internal,x],[internal,1]]]
となるが, この 34 も謎 (Todo).
@end itemize

次の例では (x+1)+(x+2) の括弧をはずして x+1+x+2 に変換している.
@example
[0] ctrl("print_quote",1) $

[1] Q=quote((x+1)+(x+2));
[b_op,+,[u_op,(),[b_op,+,[internal,x],[internal,1]]],
        [u_op,(),[b_op,+,[internal,x],[internal,2]]]]

[2] FA=quote_to_funargs(Q);
[0,<...quoted...>,
  [u_op,(),[b_op,+,[internal,x],[internal,1]]],
  [u_op,(),[b_op,+,[internal,x],[internal,2]]]]

[3] FA2=quote_to_funargs(FA[2])[1];
[b_op,+,[internal,x],[internal,1]]

[4] FA3=quote_to_funargs(FA[3])[1];
[b_op,+,[internal,x],[internal,2]]

[5] funargs_to_quote([FA[0],FA[1],FA2,FA3]);
[b_op,+,[b_op,+,[internal,x],[internal,1]],
        [b_op,+,[internal,x],[internal,2]]]
@end example

次の例は OpenXM/asir-contrib 版の asir で実行.
@example
[1287] load("noro_simplify.rr");
1
[1293] noro_simplify.remove_paren(quote( f(1-(x))));
quote(f(1-x))
@end example

@table @t
@item 参照
@ref{quotetolist}
@end table

@noindent
ChangeLog
@itemize @bullet
@item 
 このマニュアルは覚え書きである. 開発者が本格的なのを書くだろう.
@item 
 これらの関数は 2004-7-8 から開発のはじまっている quote の simplification 関連
 の実験的関数である.
 変更をうけたソースコードは多岐にわたるのでまだ書かない.
@item 
 括弧を取り去る問題は OpenXM/fb が蓄えている公式を tex で綺麗に表示するのが動機の一つ.
@item 
 2004-6-26 の計算代数セミナーにおいて, 中川さんが simplifier についていろいろ問題提起
をした (計算代数セミナービデオ参照).
@end itemize

@comment --- ◯◯◯◯  以下他の関数について真似して記述する. ◯◯◯◯ 

@comment 新しい関数の説明を書くためのテンプレートである. 消すな.
@comment --- ◯◯◯◯  関数 syz_pqr, xyz_stu の説明 ◯◯◯◯ 
@comment --- 複数の関数をまとめて説明する例 ---
@node xyz_pqr,,, 実験的仕様の関数
@subsection @code{xyz_pqr}, @code{syz_stu}
@findex xyz_pqr
@findex xyz_stu

@comment --- 関数の簡単な説明 ---
@comment --- @itemx は複数に対して説明を一つつける場合に使う ---
@table @t
@item xyz_pqr(@var{arg1},@var{arg2}[,@var{flag}])
@itemx xyz_stu(@var{arg1},@var{arg2})
:: xyz に関する操作.
@end table

@table @var
@item return
整数
@item arg1, arg2
整数
@item flag
0 または 1
@end table

@itemize @bullet
@item この項目は新しい関数の説明を書くためのテンプレートである. 消すな.
@item
@code{xyz_pqr()} は, @var{arg1}, @var{arg2} を pqr する.
@item
@var{flag} が 0 でないとき, モジュラ計算を行う.
@item
@code{xyz_stu()} は stu アルゴリズムを用いる.
@end itemize

@example
[219] xyz_pqr(1,2);
3
[220] xyz_pqr(1,2,1);
3
0
[221] xyz_stu(1,2);
3
@end example

@table @t
@item 参照
@ref{xyz_abc}
@end table

@comment --- ChangeLog を書く. 動機. ソースコードの位置. 変更日時 など CVSサーバを見るため
@comment --- openxm の外部からの寄与も述べる. Credit.
@noindent
ChangeLog
@itemize @bullet
@item この関数は 2004-3-1 から 2004-3-14 にかけて アルゴリズム xyz (論文
 http://www.afo.org/xyz.pdf ) を用いて書き直された.
 変更をうけたソースコードは xxxyy.rr, ppp.c である.
@item この関数は 2000 頃にはじめてのバージョンが書かれた. ソースは ppp.c である.
@end itemize

@comment --- おまじない ---
@node Index,,, Top
@unnumbered Index
@printindex fn
@printindex cp
@iftex
@vfill @eject
@end iftex
@summarycontents
@contents
@bye
@comment --- おまじない終り ---
